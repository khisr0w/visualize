!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
APIENTRY	.\include\rlgl.h	784;"	d
APIENTRY	.\include\rlgl.h	786;"	d
AttachAudioMixedProcessor	.\include\raylib.h	/^RLAPI void AttachAudioMixedProcessor(AudioCallback processor); \/\/ Attach audio stream processor to the entire audio pipeline, receives the samples as <float>s$/;"	p
AttachAudioStreamProcessor	.\include\raylib.h	/^RLAPI void AttachAudioStreamProcessor(AudioStream stream, AudioCallback processor); \/\/ Attach audio stream processor to stream, receives the samples as <float>s$/;"	p
AudioCallback	.\include\raylib.h	/^typedef void (*AudioCallback)(void *bufferData, unsigned int frames);$/;"	t
AudioStream	.\include\raylib.h	/^typedef struct AudioStream {$/;"	s
AudioStream	.\include\raylib.h	/^} AudioStream;$/;"	t	typeref:struct:AudioStream
AutomationEvent	.\include\raylib.h	/^typedef struct AutomationEvent {$/;"	s
AutomationEvent	.\include\raylib.h	/^} AutomationEvent;$/;"	t	typeref:struct:AutomationEvent
AutomationEventList	.\include\raylib.h	/^typedef struct AutomationEventList {$/;"	s
AutomationEventList	.\include\raylib.h	/^} AutomationEventList;$/;"	t	typeref:struct:AutomationEventList
BEIGE	.\include\raylib.h	182;"	d
BLACK	.\include\raylib.h	187;"	d
BLANK	.\include\raylib.h	188;"	d
BLEND_ADDITIVE	.\include\raylib.h	/^    BLEND_ADDITIVE,                 \/\/ Blend textures adding colors$/;"	e	enum:__anon17
BLEND_ADD_COLORS	.\include\raylib.h	/^    BLEND_ADD_COLORS,               \/\/ Blend textures adding colors (alternative)$/;"	e	enum:__anon17
BLEND_ALPHA	.\include\raylib.h	/^    BLEND_ALPHA = 0,                \/\/ Blend textures considering alpha (default)$/;"	e	enum:__anon17
BLEND_ALPHA_PREMULTIPLY	.\include\raylib.h	/^    BLEND_ALPHA_PREMULTIPLY,        \/\/ Blend premultiplied textures considering alpha$/;"	e	enum:__anon17
BLEND_CUSTOM	.\include\raylib.h	/^    BLEND_CUSTOM,                   \/\/ Blend textures using custom src\/dst factors (use rlSetBlendFactors())$/;"	e	enum:__anon17
BLEND_CUSTOM_SEPARATE	.\include\raylib.h	/^    BLEND_CUSTOM_SEPARATE           \/\/ Blend textures using custom rgb\/alpha separate src\/dst factors (use rlSetBlendFactorsSeparate())$/;"	e	enum:__anon17
BLEND_MULTIPLIED	.\include\raylib.h	/^    BLEND_MULTIPLIED,               \/\/ Blend textures multiplying colors$/;"	e	enum:__anon17
BLEND_SUBTRACT_COLORS	.\include\raylib.h	/^    BLEND_SUBTRACT_COLORS,          \/\/ Blend textures subtracting colors (alternative)$/;"	e	enum:__anon17
BLUE	.\include\raylib.h	177;"	d
BROWN	.\include\raylib.h	183;"	d
BeginBlendMode	.\include\raylib.h	/^RLAPI void BeginBlendMode(int mode);                              \/\/ Begin blending mode (alpha, additive, multiplied, subtract, custom)$/;"	p
BeginDrawing	.\include\raylib.h	/^RLAPI void BeginDrawing(void);                                    \/\/ Setup canvas (framebuffer) to start drawing$/;"	p
BeginMode2D	.\include\raylib.h	/^RLAPI void BeginMode2D(Camera2D camera);                          \/\/ Begin 2D mode with custom camera (2D)$/;"	p
BeginMode3D	.\include\raylib.h	/^RLAPI void BeginMode3D(Camera3D camera);                          \/\/ Begin 3D mode with custom camera (3D)$/;"	p
BeginScissorMode	.\include\raylib.h	/^RLAPI void BeginScissorMode(int x, int y, int width, int height); \/\/ Begin scissor mode (define screen area for following drawing)$/;"	p
BeginShaderMode	.\include\raylib.h	/^RLAPI void BeginShaderMode(Shader shader);                        \/\/ Begin custom shader drawing$/;"	p
BeginTextureMode	.\include\raylib.h	/^RLAPI void BeginTextureMode(RenderTexture2D target);              \/\/ Begin drawing to render texture$/;"	p
BeginVrStereoMode	.\include\raylib.h	/^RLAPI void BeginVrStereoMode(VrStereoConfig config);              \/\/ Begin stereo rendering (requires VR simulator)$/;"	p
BlendMode	.\include\raylib.h	/^} BlendMode;$/;"	t	typeref:enum:__anon17
BoneInfo	.\include\raylib.h	/^typedef struct BoneInfo {$/;"	s
BoneInfo	.\include\raylib.h	/^} BoneInfo;$/;"	t	typeref:struct:BoneInfo
BoundingBox	.\include\raylib.h	/^typedef struct BoundingBox {$/;"	s
BoundingBox	.\include\raylib.h	/^} BoundingBox;$/;"	t	typeref:struct:BoundingBox
CAMERA_CUSTOM	.\include\raylib.h	/^    CAMERA_CUSTOM = 0,              \/\/ Custom camera$/;"	e	enum:__anon19
CAMERA_FIRST_PERSON	.\include\raylib.h	/^    CAMERA_FIRST_PERSON,            \/\/ First person camera$/;"	e	enum:__anon19
CAMERA_FREE	.\include\raylib.h	/^    CAMERA_FREE,                    \/\/ Free camera$/;"	e	enum:__anon19
CAMERA_ORBITAL	.\include\raylib.h	/^    CAMERA_ORBITAL,                 \/\/ Orbital camera$/;"	e	enum:__anon19
CAMERA_ORTHOGRAPHIC	.\include\raylib.h	/^    CAMERA_ORTHOGRAPHIC             \/\/ Orthographic projection$/;"	e	enum:__anon20
CAMERA_PERSPECTIVE	.\include\raylib.h	/^    CAMERA_PERSPECTIVE = 0,         \/\/ Perspective projection$/;"	e	enum:__anon20
CAMERA_THIRD_PERSON	.\include\raylib.h	/^    CAMERA_THIRD_PERSON             \/\/ Third person camera$/;"	e	enum:__anon19
CLITERAL	.\include\raylib.h	138;"	d
CLITERAL	.\include\raylib.h	140;"	d
CUBEMAP_LAYOUT_AUTO_DETECT	.\include\raylib.h	/^    CUBEMAP_LAYOUT_AUTO_DETECT = 0,         \/\/ Automatically detect layout type$/;"	e	enum:__anon15
CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE	.\include\raylib.h	/^    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE,     \/\/ Layout is defined by a 4x3 cross with cubemap faces$/;"	e	enum:__anon15
CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR	.\include\raylib.h	/^    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR,     \/\/ Layout is defined by a 3x4 cross with cubemap faces$/;"	e	enum:__anon15
CUBEMAP_LAYOUT_LINE_HORIZONTAL	.\include\raylib.h	/^    CUBEMAP_LAYOUT_LINE_HORIZONTAL,         \/\/ Layout is defined by a horizontal line with faces$/;"	e	enum:__anon15
CUBEMAP_LAYOUT_LINE_VERTICAL	.\include\raylib.h	/^    CUBEMAP_LAYOUT_LINE_VERTICAL,           \/\/ Layout is defined by a vertical line with faces$/;"	e	enum:__anon15
CUBEMAP_LAYOUT_PANORAMA	.\include\raylib.h	/^    CUBEMAP_LAYOUT_PANORAMA                 \/\/ Layout is defined by a panorama image (equirrectangular map)$/;"	e	enum:__anon15
Camera	.\include\raylib.h	/^typedef Camera3D Camera;    \/\/ Camera type fallback, defaults to Camera3D$/;"	t
Camera2D	.\include\raylib.h	/^typedef struct Camera2D {$/;"	s
Camera2D	.\include\raylib.h	/^} Camera2D;$/;"	t	typeref:struct:Camera2D
Camera3D	.\include\raylib.h	/^typedef struct Camera3D {$/;"	s
Camera3D	.\include\raylib.h	/^} Camera3D;$/;"	t	typeref:struct:Camera3D
CameraMode	.\include\raylib.h	/^} CameraMode;$/;"	t	typeref:enum:__anon19
CameraProjection	.\include\raylib.h	/^} CameraProjection;$/;"	t	typeref:enum:__anon20
ChangeDirectory	.\include\raylib.h	/^RLAPI bool ChangeDirectory(const char *dir);                      \/\/ Change working directory, return true on success$/;"	p
CheckCollisionBoxSphere	.\include\raylib.h	/^RLAPI bool CheckCollisionBoxSphere(BoundingBox box, Vector3 center, float radius);                  \/\/ Check collision between box and sphere$/;"	p
CheckCollisionBoxes	.\include\raylib.h	/^RLAPI bool CheckCollisionBoxes(BoundingBox box1, BoundingBox box2);                                 \/\/ Check collision between two bounding boxes$/;"	p
CheckCollisionCircleRec	.\include\raylib.h	/^RLAPI bool CheckCollisionCircleRec(Vector2 center, float radius, Rectangle rec);                         \/\/ Check collision between circle and rectangle$/;"	p
CheckCollisionCircles	.\include\raylib.h	/^RLAPI bool CheckCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2);        \/\/ Check collision between two circles$/;"	p
CheckCollisionLines	.\include\raylib.h	/^RLAPI bool CheckCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint); \/\/ Check the collision between two lines defined by two points each, returns collision point by reference$/;"	p
CheckCollisionPointCircle	.\include\raylib.h	/^RLAPI bool CheckCollisionPointCircle(Vector2 point, Vector2 center, float radius);                       \/\/ Check if point is inside circle$/;"	p
CheckCollisionPointLine	.\include\raylib.h	/^RLAPI bool CheckCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, int threshold);                \/\/ Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]$/;"	p
CheckCollisionPointPoly	.\include\raylib.h	/^RLAPI bool CheckCollisionPointPoly(Vector2 point, Vector2 *points, int pointCount);                      \/\/ Check if point is within a polygon described by array of vertices$/;"	p
CheckCollisionPointRec	.\include\raylib.h	/^RLAPI bool CheckCollisionPointRec(Vector2 point, Rectangle rec);                                         \/\/ Check if point is inside rectangle$/;"	p
CheckCollisionPointTriangle	.\include\raylib.h	/^RLAPI bool CheckCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3);               \/\/ Check if point is inside a triangle$/;"	p
CheckCollisionRecs	.\include\raylib.h	/^RLAPI bool CheckCollisionRecs(Rectangle rec1, Rectangle rec2);                                           \/\/ Check collision between two rectangles$/;"	p
CheckCollisionSpheres	.\include\raylib.h	/^RLAPI bool CheckCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2);   \/\/ Check collision between two spheres$/;"	p
Clamp	.\include\raymath.h	/^RMAPI float Clamp(float value, float min, float max)$/;"	f
ClearBackground	.\include\raylib.h	/^RLAPI void ClearBackground(Color color);                          \/\/ Set background color (framebuffer clear color)$/;"	p
ClearWindowState	.\include\raylib.h	/^RLAPI void ClearWindowState(unsigned int flags);                  \/\/ Clear window configuration state flags$/;"	p
CloseAudioDevice	.\include\raylib.h	/^RLAPI void CloseAudioDevice(void);                                    \/\/ Close the audio device and context$/;"	p
CloseWindow	.\include\raylib.h	/^RLAPI void CloseWindow(void);                                     \/\/ Close window and unload OpenGL context$/;"	p
CodepointToUTF8	.\include\raylib.h	/^RLAPI const char *CodepointToUTF8(int codepoint, int *utf8Size);        \/\/ Encode one codepoint into UTF-8 byte array (array length returned as parameter)$/;"	p
Color	.\include\raylib.h	/^typedef struct Color {$/;"	s
Color	.\include\raylib.h	/^} Color;$/;"	t	typeref:struct:Color
ColorAlpha	.\include\raylib.h	/^RLAPI Color ColorAlpha(Color color, float alpha);                           \/\/ Get color with alpha applied, alpha goes from 0.0f to 1.0f$/;"	p
ColorAlphaBlend	.\include\raylib.h	/^RLAPI Color ColorAlphaBlend(Color dst, Color src, Color tint);              \/\/ Get src alpha-blended into dst color with tint$/;"	p
ColorBrightness	.\include\raylib.h	/^RLAPI Color ColorBrightness(Color color, float factor);                     \/\/ Get color with brightness correction, brightness factor goes from -1.0f to 1.0f$/;"	p
ColorContrast	.\include\raylib.h	/^RLAPI Color ColorContrast(Color color, float contrast);                     \/\/ Get color with contrast correction, contrast values between -1.0f and 1.0f$/;"	p
ColorFromHSV	.\include\raylib.h	/^RLAPI Color ColorFromHSV(float hue, float saturation, float value);         \/\/ Get a Color from HSV values, hue [0..360], saturation\/value [0..1]$/;"	p
ColorFromNormalized	.\include\raylib.h	/^RLAPI Color ColorFromNormalized(Vector4 normalized);                        \/\/ Get Color from normalized values [0..1]$/;"	p
ColorNormalize	.\include\raylib.h	/^RLAPI Vector4 ColorNormalize(Color color);                                  \/\/ Get Color normalized as float [0..1]$/;"	p
ColorTint	.\include\raylib.h	/^RLAPI Color ColorTint(Color color, Color tint);                             \/\/ Get color multiplied with another color$/;"	p
ColorToHSV	.\include\raylib.h	/^RLAPI Vector3 ColorToHSV(Color color);                                      \/\/ Get HSV values for a Color, hue [0..360], saturation\/value [0..1]$/;"	p
ColorToInt	.\include\raylib.h	/^RLAPI int ColorToInt(Color color);                                          \/\/ Get hexadecimal value for a Color$/;"	p
CompressData	.\include\raylib.h	/^RLAPI unsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize);        \/\/ Compress data (DEFLATE algorithm), memory must be MemFree()$/;"	p
ConfigFlags	.\include\raylib.h	/^} ConfigFlags;$/;"	t	typeref:enum:__anon1
CubemapLayout	.\include\raylib.h	/^} CubemapLayout;$/;"	t	typeref:enum:__anon15
DARKBLUE	.\include\raylib.h	178;"	d
DARKBROWN	.\include\raylib.h	184;"	d
DARKGRAY	.\include\raylib.h	166;"	d
DARKGREEN	.\include\raylib.h	175;"	d
DARKPURPLE	.\include\raylib.h	181;"	d
DEG2RAD	.\include\raylib.h	113;"	d
DEG2RAD	.\include\raymath.h	90;"	d
DEG2RAD	.\include\rlgl.h	843;"	d
DecodeDataBase64	.\include\raylib.h	/^RLAPI unsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize);                    \/\/ Decode Base64 string data, memory must be MemFree()$/;"	p
DecompressData	.\include\raylib.h	/^RLAPI unsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize);  \/\/ Decompress data (DEFLATE algorithm), memory must be MemFree()$/;"	p
DetachAudioMixedProcessor	.\include\raylib.h	/^RLAPI void DetachAudioMixedProcessor(AudioCallback processor); \/\/ Detach audio stream processor from the entire audio pipeline$/;"	p
DetachAudioStreamProcessor	.\include\raylib.h	/^RLAPI void DetachAudioStreamProcessor(AudioStream stream, AudioCallback processor); \/\/ Detach audio stream processor from stream$/;"	p
DirectoryExists	.\include\raylib.h	/^RLAPI bool DirectoryExists(const char *dirPath);                  \/\/ Check if a directory path exists$/;"	p
DisableCursor	.\include\raylib.h	/^RLAPI void DisableCursor(void);                                   \/\/ Disables cursor (lock cursor)$/;"	p
DisableEventWaiting	.\include\raylib.h	/^RLAPI void DisableEventWaiting(void);                             \/\/ Disable waiting for events on EndDrawing(), automatic events polling$/;"	p
DrawBillboard	.\include\raylib.h	/^RLAPI void DrawBillboard(Camera camera, Texture2D texture, Vector3 position, float size, Color tint);   \/\/ Draw a billboard texture$/;"	p
DrawBillboardPro	.\include\raylib.h	/^RLAPI void DrawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint); \/\/ Draw a billboard texture defined by source and rotation$/;"	p
DrawBillboardRec	.\include\raylib.h	/^RLAPI void DrawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint); \/\/ Draw a billboard texture defined by source$/;"	p
DrawBoundingBox	.\include\raylib.h	/^RLAPI void DrawBoundingBox(BoundingBox box, Color color);                                   \/\/ Draw bounding box (wires)$/;"	p
DrawCapsule	.\include\raylib.h	/^RLAPI void DrawCapsule(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color); \/\/ Draw a capsule with the center of its sphere caps at startPos and endPos$/;"	p
DrawCapsuleWires	.\include\raylib.h	/^RLAPI void DrawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, int slices, int rings, Color color); \/\/ Draw capsule wireframe with the center of its sphere caps at startPos and endPos$/;"	p
DrawCircle	.\include\raylib.h	/^RLAPI void DrawCircle(int centerX, int centerY, float radius, Color color);                              \/\/ Draw a color-filled circle$/;"	p
DrawCircle3D	.\include\raylib.h	/^RLAPI void DrawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color); \/\/ Draw a circle in 3D world space$/;"	p
DrawCircleGradient	.\include\raylib.h	/^RLAPI void DrawCircleGradient(int centerX, int centerY, float radius, Color color1, Color color2);       \/\/ Draw a gradient-filled circle$/;"	p
DrawCircleLines	.\include\raylib.h	/^RLAPI void DrawCircleLines(int centerX, int centerY, float radius, Color color);                         \/\/ Draw circle outline$/;"	p
DrawCircleLinesV	.\include\raylib.h	/^RLAPI void DrawCircleLinesV(Vector2 center, float radius, Color color);                                  \/\/ Draw circle outline (Vector version)$/;"	p
DrawCircleSector	.\include\raylib.h	/^RLAPI void DrawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color);      \/\/ Draw a piece of a circle$/;"	p
DrawCircleSectorLines	.\include\raylib.h	/^RLAPI void DrawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, int segments, Color color); \/\/ Draw circle sector outline$/;"	p
DrawCircleV	.\include\raylib.h	/^RLAPI void DrawCircleV(Vector2 center, float radius, Color color);                                       \/\/ Draw a color-filled circle (Vector version)$/;"	p
DrawCube	.\include\raylib.h	/^RLAPI void DrawCube(Vector3 position, float width, float height, float length, Color color);             \/\/ Draw cube$/;"	p
DrawCubeV	.\include\raylib.h	/^RLAPI void DrawCubeV(Vector3 position, Vector3 size, Color color);                                       \/\/ Draw cube (Vector version)$/;"	p
DrawCubeWires	.\include\raylib.h	/^RLAPI void DrawCubeWires(Vector3 position, float width, float height, float length, Color color);        \/\/ Draw cube wires$/;"	p
DrawCubeWiresV	.\include\raylib.h	/^RLAPI void DrawCubeWiresV(Vector3 position, Vector3 size, Color color);                                  \/\/ Draw cube wires (Vector version)$/;"	p
DrawCylinder	.\include\raylib.h	/^RLAPI void DrawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color); \/\/ Draw a cylinder\/cone$/;"	p
DrawCylinderEx	.\include\raylib.h	/^RLAPI void DrawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color); \/\/ Draw a cylinder with base at startPos and top at endPos$/;"	p
DrawCylinderWires	.\include\raylib.h	/^RLAPI void DrawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, int slices, Color color); \/\/ Draw a cylinder\/cone wires$/;"	p
DrawCylinderWiresEx	.\include\raylib.h	/^RLAPI void DrawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, int sides, Color color); \/\/ Draw a cylinder wires with base at startPos and top at endPos$/;"	p
DrawEllipse	.\include\raylib.h	/^RLAPI void DrawEllipse(int centerX, int centerY, float radiusH, float radiusV, Color color);             \/\/ Draw ellipse$/;"	p
DrawEllipseLines	.\include\raylib.h	/^RLAPI void DrawEllipseLines(int centerX, int centerY, float radiusH, float radiusV, Color color);        \/\/ Draw ellipse outline$/;"	p
DrawFPS	.\include\raylib.h	/^RLAPI void DrawFPS(int posX, int posY);                                                     \/\/ Draw current FPS$/;"	p
DrawGrid	.\include\raylib.h	/^RLAPI void DrawGrid(int slices, float spacing);                                                          \/\/ Draw a grid (centered at (0, 0, 0))$/;"	p
DrawLine	.\include\raylib.h	/^RLAPI void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color);                \/\/ Draw a line$/;"	p
DrawLine3D	.\include\raylib.h	/^RLAPI void DrawLine3D(Vector3 startPos, Vector3 endPos, Color color);                                    \/\/ Draw a line in 3D world space$/;"	p
DrawLineBezier	.\include\raylib.h	/^RLAPI void DrawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color);                   \/\/ Draw line segment cubic-bezier in-out interpolation$/;"	p
DrawLineEx	.\include\raylib.h	/^RLAPI void DrawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color);                       \/\/ Draw a line (using triangles\/quads)$/;"	p
DrawLineStrip	.\include\raylib.h	/^RLAPI void DrawLineStrip(Vector2 *points, int pointCount, Color color);                                  \/\/ Draw lines sequence (using gl lines)$/;"	p
DrawLineV	.\include\raylib.h	/^RLAPI void DrawLineV(Vector2 startPos, Vector2 endPos, Color color);                                     \/\/ Draw a line (using gl lines)$/;"	p
DrawMesh	.\include\raylib.h	/^RLAPI void DrawMesh(Mesh mesh, Material material, Matrix transform);                        \/\/ Draw a 3d mesh with material and transform$/;"	p
DrawMeshInstanced	.\include\raylib.h	/^RLAPI void DrawMeshInstanced(Mesh mesh, Material material, const Matrix *transforms, int instances); \/\/ Draw multiple mesh instances with material and different transforms$/;"	p
DrawModel	.\include\raylib.h	/^RLAPI void DrawModel(Model model, Vector3 position, float scale, Color tint);               \/\/ Draw a model (with texture if set)$/;"	p
DrawModelEx	.\include\raylib.h	/^RLAPI void DrawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint); \/\/ Draw a model with extended parameters$/;"	p
DrawModelWires	.\include\raylib.h	/^RLAPI void DrawModelWires(Model model, Vector3 position, float scale, Color tint);          \/\/ Draw a model wires (with texture if set)$/;"	p
DrawModelWiresEx	.\include\raylib.h	/^RLAPI void DrawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint); \/\/ Draw a model wires (with texture if set) with extended parameters$/;"	p
DrawPixel	.\include\raylib.h	/^RLAPI void DrawPixel(int posX, int posY, Color color);                                                   \/\/ Draw a pixel$/;"	p
DrawPixelV	.\include\raylib.h	/^RLAPI void DrawPixelV(Vector2 position, Color color);                                                    \/\/ Draw a pixel (Vector version)$/;"	p
DrawPlane	.\include\raylib.h	/^RLAPI void DrawPlane(Vector3 centerPos, Vector2 size, Color color);                                      \/\/ Draw a plane XZ$/;"	p
DrawPoint3D	.\include\raylib.h	/^RLAPI void DrawPoint3D(Vector3 position, Color color);                                                   \/\/ Draw a point in 3D space, actually a small line$/;"	p
DrawPoly	.\include\raylib.h	/^RLAPI void DrawPoly(Vector2 center, int sides, float radius, float rotation, Color color);               \/\/ Draw a regular polygon (Vector version)$/;"	p
DrawPolyLines	.\include\raylib.h	/^RLAPI void DrawPolyLines(Vector2 center, int sides, float radius, float rotation, Color color);          \/\/ Draw a polygon outline of n sides$/;"	p
DrawPolyLinesEx	.\include\raylib.h	/^RLAPI void DrawPolyLinesEx(Vector2 center, int sides, float radius, float rotation, float lineThick, Color color); \/\/ Draw a polygon outline of n sides with extended parameters$/;"	p
DrawRay	.\include\raylib.h	/^RLAPI void DrawRay(Ray ray, Color color);                                                                \/\/ Draw a ray line$/;"	p
DrawRectangle	.\include\raylib.h	/^RLAPI void DrawRectangle(int posX, int posY, int width, int height, Color color);                        \/\/ Draw a color-filled rectangle$/;"	p
DrawRectangleGradientEx	.\include\raylib.h	/^RLAPI void DrawRectangleGradientEx(Rectangle rec, Color col1, Color col2, Color col3, Color col4);       \/\/ Draw a gradient-filled rectangle with custom vertex colors$/;"	p
DrawRectangleGradientH	.\include\raylib.h	/^RLAPI void DrawRectangleGradientH(int posX, int posY, int width, int height, Color color1, Color color2);\/\/ Draw a horizontal-gradient-filled rectangle$/;"	p
DrawRectangleGradientV	.\include\raylib.h	/^RLAPI void DrawRectangleGradientV(int posX, int posY, int width, int height, Color color1, Color color2);\/\/ Draw a vertical-gradient-filled rectangle$/;"	p
DrawRectangleLines	.\include\raylib.h	/^RLAPI void DrawRectangleLines(int posX, int posY, int width, int height, Color color);                   \/\/ Draw rectangle outline$/;"	p
DrawRectangleLinesEx	.\include\raylib.h	/^RLAPI void DrawRectangleLinesEx(Rectangle rec, float lineThick, Color color);                            \/\/ Draw rectangle outline with extended parameters$/;"	p
DrawRectanglePro	.\include\raylib.h	/^RLAPI void DrawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color);                 \/\/ Draw a color-filled rectangle with pro parameters$/;"	p
DrawRectangleRec	.\include\raylib.h	/^RLAPI void DrawRectangleRec(Rectangle rec, Color color);                                                 \/\/ Draw a color-filled rectangle$/;"	p
DrawRectangleRounded	.\include\raylib.h	/^RLAPI void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color);              \/\/ Draw rectangle with rounded edges$/;"	p
DrawRectangleRoundedLines	.\include\raylib.h	/^RLAPI void DrawRectangleRoundedLines(Rectangle rec, float roundness, int segments, float lineThick, Color color); \/\/ Draw rectangle with rounded edges outline$/;"	p
DrawRectangleV	.\include\raylib.h	/^RLAPI void DrawRectangleV(Vector2 position, Vector2 size, Color color);                                  \/\/ Draw a color-filled rectangle (Vector version)$/;"	p
DrawRing	.\include\raylib.h	/^RLAPI void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color); \/\/ Draw ring$/;"	p
DrawRingLines	.\include\raylib.h	/^RLAPI void DrawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color);    \/\/ Draw ring outline$/;"	p
DrawSphere	.\include\raylib.h	/^RLAPI void DrawSphere(Vector3 centerPos, float radius, Color color);                                     \/\/ Draw sphere$/;"	p
DrawSphereEx	.\include\raylib.h	/^RLAPI void DrawSphereEx(Vector3 centerPos, float radius, int rings, int slices, Color color);            \/\/ Draw sphere with extended parameters$/;"	p
DrawSphereWires	.\include\raylib.h	/^RLAPI void DrawSphereWires(Vector3 centerPos, float radius, int rings, int slices, Color color);         \/\/ Draw sphere wires$/;"	p
DrawSplineBasis	.\include\raylib.h	/^RLAPI void DrawSplineBasis(Vector2 *points, int pointCount, float thick, Color color);                   \/\/ Draw spline: B-Spline, minimum 4 points$/;"	p
DrawSplineBezierCubic	.\include\raylib.h	/^RLAPI void DrawSplineBezierCubic(Vector2 *points, int pointCount, float thick, Color color);             \/\/ Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]$/;"	p
DrawSplineBezierQuadratic	.\include\raylib.h	/^RLAPI void DrawSplineBezierQuadratic(Vector2 *points, int pointCount, float thick, Color color);         \/\/ Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]$/;"	p
DrawSplineCatmullRom	.\include\raylib.h	/^RLAPI void DrawSplineCatmullRom(Vector2 *points, int pointCount, float thick, Color color);              \/\/ Draw spline: Catmull-Rom, minimum 4 points$/;"	p
DrawSplineLinear	.\include\raylib.h	/^RLAPI void DrawSplineLinear(Vector2 *points, int pointCount, float thick, Color color);                  \/\/ Draw spline: Linear, minimum 2 points$/;"	p
DrawSplineSegmentBasis	.\include\raylib.h	/^RLAPI void DrawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color); \/\/ Draw spline segment: B-Spline, 4 points$/;"	p
DrawSplineSegmentBezierCubic	.\include\raylib.h	/^RLAPI void DrawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color); \/\/ Draw spline segment: Cubic Bezier, 2 points, 2 control points$/;"	p
DrawSplineSegmentBezierQuadratic	.\include\raylib.h	/^RLAPI void DrawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color); \/\/ Draw spline segment: Quadratic Bezier, 2 points, 1 control point$/;"	p
DrawSplineSegmentCatmullRom	.\include\raylib.h	/^RLAPI void DrawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color); \/\/ Draw spline segment: Catmull-Rom, 4 points$/;"	p
DrawSplineSegmentLinear	.\include\raylib.h	/^RLAPI void DrawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color);                    \/\/ Draw spline segment: Linear, 2 points$/;"	p
DrawText	.\include\raylib.h	/^RLAPI void DrawText(const char *text, int posX, int posY, int fontSize, Color color);       \/\/ Draw text (using default font)$/;"	p
DrawTextCodepoint	.\include\raylib.h	/^RLAPI void DrawTextCodepoint(Font font, int codepoint, Vector2 position, float fontSize, Color tint); \/\/ Draw one character (codepoint)$/;"	p
DrawTextCodepoints	.\include\raylib.h	/^RLAPI void DrawTextCodepoints(Font font, const int *codepoints, int codepointCount, Vector2 position, float fontSize, float spacing, Color tint); \/\/ Draw multiple character (codepoint)$/;"	p
DrawTextEx	.\include\raylib.h	/^RLAPI void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint); \/\/ Draw text using font and additional parameters$/;"	p
DrawTextPro	.\include\raylib.h	/^RLAPI void DrawTextPro(Font font, const char *text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint); \/\/ Draw text using Font and pro parameters (rotation)$/;"	p
DrawTexture	.\include\raylib.h	/^RLAPI void DrawTexture(Texture2D texture, int posX, int posY, Color tint);                               \/\/ Draw a Texture2D$/;"	p
DrawTextureEx	.\include\raylib.h	/^RLAPI void DrawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint);  \/\/ Draw a Texture2D with extended parameters$/;"	p
DrawTextureNPatch	.\include\raylib.h	/^RLAPI void DrawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint); \/\/ Draws a texture (or part of it) that stretches or shrinks nicely$/;"	p
DrawTexturePro	.\include\raylib.h	/^RLAPI void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint); \/\/ Draw a part of a texture defined by a rectangle with 'pro' parameters$/;"	p
DrawTextureRec	.\include\raylib.h	/^RLAPI void DrawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint);            \/\/ Draw a part of a texture defined by a rectangle$/;"	p
DrawTextureV	.\include\raylib.h	/^RLAPI void DrawTextureV(Texture2D texture, Vector2 position, Color tint);                                \/\/ Draw a Texture2D with position defined as Vector2$/;"	p
DrawTriangle	.\include\raylib.h	/^RLAPI void DrawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color);                                \/\/ Draw a color-filled triangle (vertex in counter-clockwise order!)$/;"	p
DrawTriangle3D	.\include\raylib.h	/^RLAPI void DrawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color);                              \/\/ Draw a color-filled triangle (vertex in counter-clockwise order!)$/;"	p
DrawTriangleFan	.\include\raylib.h	/^RLAPI void DrawTriangleFan(Vector2 *points, int pointCount, Color color);                                \/\/ Draw a triangle fan defined by points (first vertex is the center)$/;"	p
DrawTriangleLines	.\include\raylib.h	/^RLAPI void DrawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color);                           \/\/ Draw triangle outline (vertex in counter-clockwise order!)$/;"	p
DrawTriangleStrip	.\include\raylib.h	/^RLAPI void DrawTriangleStrip(Vector2 *points, int pointCount, Color color);                              \/\/ Draw a triangle strip defined by points$/;"	p
DrawTriangleStrip3D	.\include\raylib.h	/^RLAPI void DrawTriangleStrip3D(Vector3 *points, int pointCount, Color color);                            \/\/ Draw a triangle strip defined by points$/;"	p
EPSILON	.\include\raymath.h	1104;"	d
EPSILON	.\include\raymath.h	1864;"	d
EPSILON	.\include\raymath.h	2175;"	d
EPSILON	.\include\raymath.h	218;"	d
EPSILON	.\include\raymath.h	516;"	d
EPSILON	.\include\raymath.h	86;"	d
EnableCursor	.\include\raylib.h	/^RLAPI void EnableCursor(void);                                    \/\/ Enables cursor (unlock cursor)$/;"	p
EnableEventWaiting	.\include\raylib.h	/^RLAPI void EnableEventWaiting(void);                              \/\/ Enable waiting for events on EndDrawing(), no automatic event polling$/;"	p
EncodeDataBase64	.\include\raylib.h	/^RLAPI char *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize);               \/\/ Encode data to Base64 string, memory must be MemFree()$/;"	p
EndBlendMode	.\include\raylib.h	/^RLAPI void EndBlendMode(void);                                    \/\/ End blending mode (reset to default: alpha blending)$/;"	p
EndDrawing	.\include\raylib.h	/^RLAPI void EndDrawing(void);                                      \/\/ End canvas drawing and swap buffers (double buffering)$/;"	p
EndMode2D	.\include\raylib.h	/^RLAPI void EndMode2D(void);                                       \/\/ Ends 2D mode with custom camera$/;"	p
EndMode3D	.\include\raylib.h	/^RLAPI void EndMode3D(void);                                       \/\/ Ends 3D mode and returns to default 2D orthographic mode$/;"	p
EndScissorMode	.\include\raylib.h	/^RLAPI void EndScissorMode(void);                                  \/\/ End scissor mode$/;"	p
EndShaderMode	.\include\raylib.h	/^RLAPI void EndShaderMode(void);                                   \/\/ End custom shader drawing (use default shader)$/;"	p
EndTextureMode	.\include\raylib.h	/^RLAPI void EndTextureMode(void);                                  \/\/ Ends drawing to render texture$/;"	p
EndVrStereoMode	.\include\raylib.h	/^RLAPI void EndVrStereoMode(void);                                 \/\/ End stereo rendering (requires VR simulator)$/;"	p
ExportAutomationEventList	.\include\raylib.h	/^RLAPI bool ExportAutomationEventList(AutomationEventList list, const char *fileName);   \/\/ Export automation events list as text file$/;"	p
ExportDataAsCode	.\include\raylib.h	/^RLAPI bool ExportDataAsCode(const unsigned char *data, int dataSize, const char *fileName); \/\/ Export data to code (.h), returns true on success$/;"	p
ExportFontAsCode	.\include\raylib.h	/^RLAPI bool ExportFontAsCode(Font font, const char *fileName);                               \/\/ Export font as code file, returns true on success$/;"	p
ExportImage	.\include\raylib.h	/^RLAPI bool ExportImage(Image image, const char *fileName);                                               \/\/ Export image data to file, returns true on success$/;"	p
ExportImageAsCode	.\include\raylib.h	/^RLAPI bool ExportImageAsCode(Image image, const char *fileName);                                         \/\/ Export image as code file defining an array of bytes, returns true on success$/;"	p
ExportImageToMemory	.\include\raylib.h	/^RLAPI unsigned char *ExportImageToMemory(Image image, const char *fileType, int *fileSize);              \/\/ Export image to memory buffer$/;"	p
ExportMesh	.\include\raylib.h	/^RLAPI bool ExportMesh(Mesh mesh, const char *fileName);                                     \/\/ Export mesh data to file, returns true on success$/;"	p
ExportWave	.\include\raylib.h	/^RLAPI bool ExportWave(Wave wave, const char *fileName);               \/\/ Export wave data to file, returns true on success$/;"	p
ExportWaveAsCode	.\include\raylib.h	/^RLAPI bool ExportWaveAsCode(Wave wave, const char *fileName);         \/\/ Export wave sample data to code (.h), returns true on success$/;"	p
ExtSupported	.\include\rlgl.h	/^    } ExtSupported;     \/\/ Extensions supported flags$/;"	m	struct:rlglData	typeref:struct:rlglData::__anon34
FLAG_BORDERLESS_WINDOWED_MODE	.\include\raylib.h	/^    FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000, \/\/ Set to run program in borderless windowed mode$/;"	e	enum:__anon1
FLAG_FULLSCREEN_MODE	.\include\raylib.h	/^    FLAG_FULLSCREEN_MODE    = 0x00000002,   \/\/ Set to run program in fullscreen$/;"	e	enum:__anon1
FLAG_INTERLACED_HINT	.\include\raylib.h	/^    FLAG_INTERLACED_HINT    = 0x00010000    \/\/ Set to try enabling interlaced video format (for V3D)$/;"	e	enum:__anon1
FLAG_MSAA_4X_HINT	.\include\raylib.h	/^    FLAG_MSAA_4X_HINT       = 0x00000020,   \/\/ Set to try enabling MSAA 4X$/;"	e	enum:__anon1
FLAG_VSYNC_HINT	.\include\raylib.h	/^    FLAG_VSYNC_HINT         = 0x00000040,   \/\/ Set to try enabling V-Sync on GPU$/;"	e	enum:__anon1
FLAG_WINDOW_ALWAYS_RUN	.\include\raylib.h	/^    FLAG_WINDOW_ALWAYS_RUN  = 0x00000100,   \/\/ Set to allow windows running while minimized$/;"	e	enum:__anon1
FLAG_WINDOW_HIDDEN	.\include\raylib.h	/^    FLAG_WINDOW_HIDDEN      = 0x00000080,   \/\/ Set to hide window$/;"	e	enum:__anon1
FLAG_WINDOW_HIGHDPI	.\include\raylib.h	/^    FLAG_WINDOW_HIGHDPI     = 0x00002000,   \/\/ Set to support HighDPI$/;"	e	enum:__anon1
FLAG_WINDOW_MAXIMIZED	.\include\raylib.h	/^    FLAG_WINDOW_MAXIMIZED   = 0x00000400,   \/\/ Set to maximize window (expanded to monitor)$/;"	e	enum:__anon1
FLAG_WINDOW_MINIMIZED	.\include\raylib.h	/^    FLAG_WINDOW_MINIMIZED   = 0x00000200,   \/\/ Set to minimize window (iconify)$/;"	e	enum:__anon1
FLAG_WINDOW_MOUSE_PASSTHROUGH	.\include\raylib.h	/^    FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000, \/\/ Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED$/;"	e	enum:__anon1
FLAG_WINDOW_RESIZABLE	.\include\raylib.h	/^    FLAG_WINDOW_RESIZABLE   = 0x00000004,   \/\/ Set to allow resizable window$/;"	e	enum:__anon1
FLAG_WINDOW_TOPMOST	.\include\raylib.h	/^    FLAG_WINDOW_TOPMOST     = 0x00001000,   \/\/ Set to window always on top$/;"	e	enum:__anon1
FLAG_WINDOW_TRANSPARENT	.\include\raylib.h	/^    FLAG_WINDOW_TRANSPARENT = 0x00000010,   \/\/ Set to allow transparent framebuffer$/;"	e	enum:__anon1
FLAG_WINDOW_UNDECORATED	.\include\raylib.h	/^    FLAG_WINDOW_UNDECORATED = 0x00000008,   \/\/ Set to disable window decoration (frame and buttons)$/;"	e	enum:__anon1
FLAG_WINDOW_UNFOCUSED	.\include\raylib.h	/^    FLAG_WINDOW_UNFOCUSED   = 0x00000800,   \/\/ Set to window non focused$/;"	e	enum:__anon1
FONT_BITMAP	.\include\raylib.h	/^    FONT_BITMAP,                    \/\/ Bitmap font generation, no anti-aliasing$/;"	e	enum:__anon16
FONT_DEFAULT	.\include\raylib.h	/^    FONT_DEFAULT = 0,               \/\/ Default font generation, anti-aliased$/;"	e	enum:__anon16
FONT_SDF	.\include\raylib.h	/^    FONT_SDF                        \/\/ SDF font generation, requires external shader$/;"	e	enum:__anon16
Fade	.\include\raylib.h	/^RLAPI Color Fade(Color color, float alpha);                                 \/\/ Get color with alpha applied, alpha goes from 0.0f to 1.0f$/;"	p
FileExists	.\include\raylib.h	/^RLAPI bool FileExists(const char *fileName);                      \/\/ Check if file exists$/;"	p
FilePathList	.\include\raylib.h	/^typedef struct FilePathList {$/;"	s
FilePathList	.\include\raylib.h	/^} FilePathList;$/;"	t	typeref:struct:FilePathList
FloatEquals	.\include\raymath.h	/^RMAPI int FloatEquals(float x, float y)$/;"	f
Font	.\include\raylib.h	/^typedef struct Font {$/;"	s
Font	.\include\raylib.h	/^} Font;$/;"	t	typeref:struct:Font
FontType	.\include\raylib.h	/^} FontType;$/;"	t	typeref:enum:__anon16
GAMEPAD_AXIS_LEFT_TRIGGER	.\include\raylib.h	/^    GAMEPAD_AXIS_LEFT_TRIGGER  = 4,     \/\/ Gamepad back trigger left, pressure level: [1..-1]$/;"	e	enum:__anon7
GAMEPAD_AXIS_LEFT_X	.\include\raylib.h	/^    GAMEPAD_AXIS_LEFT_X        = 0,     \/\/ Gamepad left stick X axis$/;"	e	enum:__anon7
GAMEPAD_AXIS_LEFT_Y	.\include\raylib.h	/^    GAMEPAD_AXIS_LEFT_Y        = 1,     \/\/ Gamepad left stick Y axis$/;"	e	enum:__anon7
GAMEPAD_AXIS_RIGHT_TRIGGER	.\include\raylib.h	/^    GAMEPAD_AXIS_RIGHT_TRIGGER = 5      \/\/ Gamepad back trigger right, pressure level: [1..-1]$/;"	e	enum:__anon7
GAMEPAD_AXIS_RIGHT_X	.\include\raylib.h	/^    GAMEPAD_AXIS_RIGHT_X       = 2,     \/\/ Gamepad right stick X axis$/;"	e	enum:__anon7
GAMEPAD_AXIS_RIGHT_Y	.\include\raylib.h	/^    GAMEPAD_AXIS_RIGHT_Y       = 3,     \/\/ Gamepad right stick Y axis$/;"	e	enum:__anon7
GAMEPAD_BUTTON_LEFT_FACE_DOWN	.\include\raylib.h	/^    GAMEPAD_BUTTON_LEFT_FACE_DOWN,      \/\/ Gamepad left DPAD down button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_LEFT_FACE_LEFT	.\include\raylib.h	/^    GAMEPAD_BUTTON_LEFT_FACE_LEFT,      \/\/ Gamepad left DPAD left button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_LEFT_FACE_RIGHT	.\include\raylib.h	/^    GAMEPAD_BUTTON_LEFT_FACE_RIGHT,     \/\/ Gamepad left DPAD right button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_LEFT_FACE_UP	.\include\raylib.h	/^    GAMEPAD_BUTTON_LEFT_FACE_UP,        \/\/ Gamepad left DPAD up button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_LEFT_THUMB	.\include\raylib.h	/^    GAMEPAD_BUTTON_LEFT_THUMB,          \/\/ Gamepad joystick pressed button left$/;"	e	enum:__anon6
GAMEPAD_BUTTON_LEFT_TRIGGER_1	.\include\raylib.h	/^    GAMEPAD_BUTTON_LEFT_TRIGGER_1,      \/\/ Gamepad top\/back trigger left (first), it could be a trailing button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_LEFT_TRIGGER_2	.\include\raylib.h	/^    GAMEPAD_BUTTON_LEFT_TRIGGER_2,      \/\/ Gamepad top\/back trigger left (second), it could be a trailing button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_MIDDLE	.\include\raylib.h	/^    GAMEPAD_BUTTON_MIDDLE,              \/\/ Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)$/;"	e	enum:__anon6
GAMEPAD_BUTTON_MIDDLE_LEFT	.\include\raylib.h	/^    GAMEPAD_BUTTON_MIDDLE_LEFT,         \/\/ Gamepad center buttons, left one (i.e. PS3: Select)$/;"	e	enum:__anon6
GAMEPAD_BUTTON_MIDDLE_RIGHT	.\include\raylib.h	/^    GAMEPAD_BUTTON_MIDDLE_RIGHT,        \/\/ Gamepad center buttons, right one (i.e. PS3: Start)$/;"	e	enum:__anon6
GAMEPAD_BUTTON_RIGHT_FACE_DOWN	.\include\raylib.h	/^    GAMEPAD_BUTTON_RIGHT_FACE_DOWN,     \/\/ Gamepad right button down (i.e. PS3: Cross, Xbox: A)$/;"	e	enum:__anon6
GAMEPAD_BUTTON_RIGHT_FACE_LEFT	.\include\raylib.h	/^    GAMEPAD_BUTTON_RIGHT_FACE_LEFT,     \/\/ Gamepad right button left (i.e. PS3: Circle, Xbox: B)$/;"	e	enum:__anon6
GAMEPAD_BUTTON_RIGHT_FACE_RIGHT	.\include\raylib.h	/^    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT,    \/\/ Gamepad right button right (i.e. PS3: Square, Xbox: X)$/;"	e	enum:__anon6
GAMEPAD_BUTTON_RIGHT_FACE_UP	.\include\raylib.h	/^    GAMEPAD_BUTTON_RIGHT_FACE_UP,       \/\/ Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)$/;"	e	enum:__anon6
GAMEPAD_BUTTON_RIGHT_THUMB	.\include\raylib.h	/^    GAMEPAD_BUTTON_RIGHT_THUMB          \/\/ Gamepad joystick pressed button right$/;"	e	enum:__anon6
GAMEPAD_BUTTON_RIGHT_TRIGGER_1	.\include\raylib.h	/^    GAMEPAD_BUTTON_RIGHT_TRIGGER_1,     \/\/ Gamepad top\/back trigger right (one), it could be a trailing button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_RIGHT_TRIGGER_2	.\include\raylib.h	/^    GAMEPAD_BUTTON_RIGHT_TRIGGER_2,     \/\/ Gamepad top\/back trigger right (second), it could be a trailing button$/;"	e	enum:__anon6
GAMEPAD_BUTTON_UNKNOWN	.\include\raylib.h	/^    GAMEPAD_BUTTON_UNKNOWN = 0,         \/\/ Unknown button, just for error checking$/;"	e	enum:__anon6
GESTURE_DOUBLETAP	.\include\raylib.h	/^    GESTURE_DOUBLETAP   = 2,        \/\/ Double tap gesture$/;"	e	enum:__anon18
GESTURE_DRAG	.\include\raylib.h	/^    GESTURE_DRAG        = 8,        \/\/ Drag gesture$/;"	e	enum:__anon18
GESTURE_HOLD	.\include\raylib.h	/^    GESTURE_HOLD        = 4,        \/\/ Hold gesture$/;"	e	enum:__anon18
GESTURE_NONE	.\include\raylib.h	/^    GESTURE_NONE        = 0,        \/\/ No gesture$/;"	e	enum:__anon18
GESTURE_PINCH_IN	.\include\raylib.h	/^    GESTURE_PINCH_IN    = 256,      \/\/ Pinch in gesture$/;"	e	enum:__anon18
GESTURE_PINCH_OUT	.\include\raylib.h	/^    GESTURE_PINCH_OUT   = 512       \/\/ Pinch out gesture$/;"	e	enum:__anon18
GESTURE_SWIPE_DOWN	.\include\raylib.h	/^    GESTURE_SWIPE_DOWN  = 128,      \/\/ Swipe down gesture$/;"	e	enum:__anon18
GESTURE_SWIPE_LEFT	.\include\raylib.h	/^    GESTURE_SWIPE_LEFT  = 32,       \/\/ Swipe left gesture$/;"	e	enum:__anon18
GESTURE_SWIPE_RIGHT	.\include\raylib.h	/^    GESTURE_SWIPE_RIGHT = 16,       \/\/ Swipe right gesture$/;"	e	enum:__anon18
GESTURE_SWIPE_UP	.\include\raylib.h	/^    GESTURE_SWIPE_UP    = 64,       \/\/ Swipe up gesture$/;"	e	enum:__anon18
GESTURE_TAP	.\include\raylib.h	/^    GESTURE_TAP         = 1,        \/\/ Tap gesture$/;"	e	enum:__anon18
GLAD_FREE	.\include\rlgl.h	800;"	d
GLAD_GLES2_IMPLEMENTATION	.\include\rlgl.h	814;"	d
GLAD_GL_IMPLEMENTATION	.\include\rlgl.h	802;"	d
GLAD_MALLOC	.\include\rlgl.h	799;"	d
GL_COMPRESSED_RGB8_ETC2	.\include\rlgl.h	869;"	d
GL_COMPRESSED_RGBA8_ETC2_EAC	.\include\rlgl.h	872;"	d
GL_COMPRESSED_RGBA_ASTC_4x4_KHR	.\include\rlgl.h	881;"	d
GL_COMPRESSED_RGBA_ASTC_8x8_KHR	.\include\rlgl.h	884;"	d
GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG	.\include\rlgl.h	878;"	d
GL_COMPRESSED_RGBA_S3TC_DXT1_EXT	.\include\rlgl.h	857;"	d
GL_COMPRESSED_RGBA_S3TC_DXT3_EXT	.\include\rlgl.h	860;"	d
GL_COMPRESSED_RGBA_S3TC_DXT5_EXT	.\include\rlgl.h	863;"	d
GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG	.\include\rlgl.h	875;"	d
GL_COMPRESSED_RGB_S3TC_DXT1_EXT	.\include\rlgl.h	854;"	d
GL_DRAW_FRAMEBUFFER	.\include\rlgl.h	909;"	d
GL_ETC1_RGB8_OES	.\include\rlgl.h	866;"	d
GL_GLEXT_PROTOTYPES	.\include\rlgl.h	808;"	d
GL_GLEXT_PROTOTYPES	.\include\rlgl.h	817;"	d
GL_LUMINANCE	.\include\rlgl.h	901;"	d
GL_LUMINANCE_ALPHA	.\include\rlgl.h	902;"	d
GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT	.\include\rlgl.h	2407;"	d
GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT	.\include\rlgl.h	888;"	d
GL_READ_FRAMEBUFFER	.\include\rlgl.h	908;"	d
GL_SHADING_LANGUAGE_VERSION	.\include\rlgl.h	850;"	d
GL_TEXTURE_MAX_ANISOTROPY_EXT	.\include\rlgl.h	891;"	d
GL_UNSIGNED_SHORT_4_4_4_4	.\include\rlgl.h	897;"	d
GL_UNSIGNED_SHORT_5_5_5_1	.\include\rlgl.h	896;"	d
GL_UNSIGNED_SHORT_5_6_5	.\include\rlgl.h	895;"	d
GOLD	.\include\raylib.h	168;"	d
GRAPHICS_API_OPENGL_21	.\include\rlgl.h	160;"	d
GRAPHICS_API_OPENGL_33	.\include\rlgl.h	154;"	d
GRAPHICS_API_OPENGL_33	.\include\rlgl.h	163;"	d
GRAPHICS_API_OPENGL_33	.\include\rlgl.h	176;"	d
GRAPHICS_API_OPENGL_33	.\include\rlgl.h	181;"	d
GRAPHICS_API_OPENGL_43	.\include\rlgl.h	166;"	d
GRAPHICS_API_OPENGL_ES2	.\include\rlgl.h	169;"	d
GRAPHICS_API_OPENGL_ES2	.\include\rlgl.h	186;"	d
GRAY	.\include\raylib.h	165;"	d
GREEN	.\include\raylib.h	173;"	d
GamepadAxis	.\include\raylib.h	/^} GamepadAxis;$/;"	t	typeref:enum:__anon7
GamepadButton	.\include\raylib.h	/^} GamepadButton;$/;"	t	typeref:enum:__anon6
GenImageCellular	.\include\raylib.h	/^RLAPI Image GenImageCellular(int width, int height, int tileSize);                                       \/\/ Generate image: cellular algorithm, bigger tileSize means bigger cells$/;"	p
GenImageChecked	.\include\raylib.h	/^RLAPI Image GenImageChecked(int width, int height, int checksX, int checksY, Color col1, Color col2);    \/\/ Generate image: checked$/;"	p
GenImageColor	.\include\raylib.h	/^RLAPI Image GenImageColor(int width, int height, Color color);                                           \/\/ Generate image: plain color$/;"	p
GenImageFontAtlas	.\include\raylib.h	/^RLAPI Image GenImageFontAtlas(const GlyphInfo *glyphs, Rectangle **glyphRecs, int glyphCount, int fontSize, int padding, int packMethod); \/\/ Generate image font atlas using chars info$/;"	p
GenImageGradientLinear	.\include\raylib.h	/^RLAPI Image GenImageGradientLinear(int width, int height, int direction, Color start, Color end);        \/\/ Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient$/;"	p
GenImageGradientRadial	.\include\raylib.h	/^RLAPI Image GenImageGradientRadial(int width, int height, float density, Color inner, Color outer);      \/\/ Generate image: radial gradient$/;"	p
GenImageGradientSquare	.\include\raylib.h	/^RLAPI Image GenImageGradientSquare(int width, int height, float density, Color inner, Color outer);      \/\/ Generate image: square gradient$/;"	p
GenImagePerlinNoise	.\include\raylib.h	/^RLAPI Image GenImagePerlinNoise(int width, int height, int offsetX, int offsetY, float scale);           \/\/ Generate image: perlin noise$/;"	p
GenImageText	.\include\raylib.h	/^RLAPI Image GenImageText(int width, int height, const char *text);                                       \/\/ Generate image: grayscale image from text data$/;"	p
GenImageWhiteNoise	.\include\raylib.h	/^RLAPI Image GenImageWhiteNoise(int width, int height, float factor);                                     \/\/ Generate image: white noise$/;"	p
GenMeshCone	.\include\raylib.h	/^RLAPI Mesh GenMeshCone(float radius, float height, int slices);                             \/\/ Generate cone\/pyramid mesh$/;"	p
GenMeshCube	.\include\raylib.h	/^RLAPI Mesh GenMeshCube(float width, float height, float length);                            \/\/ Generate cuboid mesh$/;"	p
GenMeshCubicmap	.\include\raylib.h	/^RLAPI Mesh GenMeshCubicmap(Image cubicmap, Vector3 cubeSize);                               \/\/ Generate cubes-based map mesh from image data$/;"	p
GenMeshCylinder	.\include\raylib.h	/^RLAPI Mesh GenMeshCylinder(float radius, float height, int slices);                         \/\/ Generate cylinder mesh$/;"	p
GenMeshHeightmap	.\include\raylib.h	/^RLAPI Mesh GenMeshHeightmap(Image heightmap, Vector3 size);                                 \/\/ Generate heightmap mesh from image data$/;"	p
GenMeshHemiSphere	.\include\raylib.h	/^RLAPI Mesh GenMeshHemiSphere(float radius, int rings, int slices);                          \/\/ Generate half-sphere mesh (no bottom cap)$/;"	p
GenMeshKnot	.\include\raylib.h	/^RLAPI Mesh GenMeshKnot(float radius, float size, int radSeg, int sides);                    \/\/ Generate trefoil knot mesh$/;"	p
GenMeshPlane	.\include\raylib.h	/^RLAPI Mesh GenMeshPlane(float width, float length, int resX, int resZ);                     \/\/ Generate plane mesh (with subdivisions)$/;"	p
GenMeshPoly	.\include\raylib.h	/^RLAPI Mesh GenMeshPoly(int sides, float radius);                                            \/\/ Generate polygonal mesh$/;"	p
GenMeshSphere	.\include\raylib.h	/^RLAPI Mesh GenMeshSphere(float radius, int rings, int slices);                              \/\/ Generate sphere mesh (standard sphere)$/;"	p
GenMeshTangents	.\include\raylib.h	/^RLAPI void GenMeshTangents(Mesh *mesh);                                                     \/\/ Compute mesh tangents$/;"	p
GenMeshTorus	.\include\raylib.h	/^RLAPI Mesh GenMeshTorus(float radius, float size, int radSeg, int sides);                   \/\/ Generate torus mesh$/;"	p
GenTextureMipmaps	.\include\raylib.h	/^RLAPI void GenTextureMipmaps(Texture2D *texture);                                                        \/\/ Generate GPU mipmaps for a texture$/;"	p
Gesture	.\include\raylib.h	/^} Gesture;$/;"	t	typeref:enum:__anon18
GetApplicationDirectory	.\include\raylib.h	/^RLAPI const char *GetApplicationDirectory(void);                  \/\/ Get the directory of the running application (uses static string)$/;"	p
GetCameraMatrix	.\include\raylib.h	/^RLAPI Matrix GetCameraMatrix(Camera camera);                      \/\/ Get camera transform matrix (view matrix)$/;"	p
GetCameraMatrix2D	.\include\raylib.h	/^RLAPI Matrix GetCameraMatrix2D(Camera2D camera);                  \/\/ Get camera 2d transform matrix$/;"	p
GetCharPressed	.\include\raylib.h	/^RLAPI int GetCharPressed(void);                               \/\/ Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty$/;"	p
GetClipboardText	.\include\raylib.h	/^RLAPI const char *GetClipboardText(void);                         \/\/ Get clipboard text content$/;"	p
GetCodepoint	.\include\raylib.h	/^RLAPI int GetCodepoint(const char *text, int *codepointSize);           \/\/ Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure$/;"	p
GetCodepointCount	.\include\raylib.h	/^RLAPI int GetCodepointCount(const char *text);                          \/\/ Get total number of codepoints in a UTF-8 encoded string$/;"	p
GetCodepointNext	.\include\raylib.h	/^RLAPI int GetCodepointNext(const char *text, int *codepointSize);       \/\/ Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure$/;"	p
GetCodepointPrevious	.\include\raylib.h	/^RLAPI int GetCodepointPrevious(const char *text, int *codepointSize);   \/\/ Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure$/;"	p
GetCollisionRec	.\include\raylib.h	/^RLAPI Rectangle GetCollisionRec(Rectangle rec1, Rectangle rec2);                                         \/\/ Get collision rectangle for two rectangles collision$/;"	p
GetColor	.\include\raylib.h	/^RLAPI Color GetColor(unsigned int hexValue);                                \/\/ Get Color structure from hexadecimal value$/;"	p
GetCurrentMonitor	.\include\raylib.h	/^RLAPI int GetCurrentMonitor(void);                                \/\/ Get current connected monitor$/;"	p
GetDirectoryPath	.\include\raylib.h	/^RLAPI const char *GetDirectoryPath(const char *filePath);         \/\/ Get full path for a given fileName with path (uses static string)$/;"	p
GetFPS	.\include\raylib.h	/^RLAPI int GetFPS(void);                                           \/\/ Get current FPS$/;"	p
GetFileExtension	.\include\raylib.h	/^RLAPI const char *GetFileExtension(const char *fileName);         \/\/ Get pointer to extension for a filename string (includes dot: '.png')$/;"	p
GetFileLength	.\include\raylib.h	/^RLAPI int GetFileLength(const char *fileName);                    \/\/ Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)$/;"	p
GetFileModTime	.\include\raylib.h	/^RLAPI long GetFileModTime(const char *fileName);                  \/\/ Get file modification time (last write time)$/;"	p
GetFileName	.\include\raylib.h	/^RLAPI const char *GetFileName(const char *filePath);              \/\/ Get pointer to filename for a path string$/;"	p
GetFileNameWithoutExt	.\include\raylib.h	/^RLAPI const char *GetFileNameWithoutExt(const char *filePath);    \/\/ Get filename string without extension (uses static string)$/;"	p
GetFontDefault	.\include\raylib.h	/^RLAPI Font GetFontDefault(void);                                                            \/\/ Get the default Font$/;"	p
GetFrameTime	.\include\raylib.h	/^RLAPI float GetFrameTime(void);                                   \/\/ Get time in seconds for last frame drawn (delta time)$/;"	p
GetGamepadAxisCount	.\include\raylib.h	/^RLAPI int GetGamepadAxisCount(int gamepad);                   \/\/ Get gamepad axis count for a gamepad$/;"	p
GetGamepadAxisMovement	.\include\raylib.h	/^RLAPI float GetGamepadAxisMovement(int gamepad, int axis);    \/\/ Get axis movement value for a gamepad axis$/;"	p
GetGamepadButtonPressed	.\include\raylib.h	/^RLAPI int GetGamepadButtonPressed(void);                      \/\/ Get the last gamepad button pressed$/;"	p
GetGamepadName	.\include\raylib.h	/^RLAPI const char *GetGamepadName(int gamepad);                \/\/ Get gamepad internal name id$/;"	p
GetGestureDetected	.\include\raylib.h	/^RLAPI int GetGestureDetected(void);                     \/\/ Get latest detected gesture$/;"	p
GetGestureDragAngle	.\include\raylib.h	/^RLAPI float GetGestureDragAngle(void);                  \/\/ Get gesture drag angle$/;"	p
GetGestureDragVector	.\include\raylib.h	/^RLAPI Vector2 GetGestureDragVector(void);               \/\/ Get gesture drag vector$/;"	p
GetGestureHoldDuration	.\include\raylib.h	/^RLAPI float GetGestureHoldDuration(void);               \/\/ Get gesture hold time in milliseconds$/;"	p
GetGesturePinchAngle	.\include\raylib.h	/^RLAPI float GetGesturePinchAngle(void);                 \/\/ Get gesture pinch angle$/;"	p
GetGesturePinchVector	.\include\raylib.h	/^RLAPI Vector2 GetGesturePinchVector(void);              \/\/ Get gesture pinch delta$/;"	p
GetGlyphAtlasRec	.\include\raylib.h	/^RLAPI Rectangle GetGlyphAtlasRec(Font font, int codepoint);                                 \/\/ Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found$/;"	p
GetGlyphIndex	.\include\raylib.h	/^RLAPI int GetGlyphIndex(Font font, int codepoint);                                          \/\/ Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found$/;"	p
GetGlyphInfo	.\include\raylib.h	/^RLAPI GlyphInfo GetGlyphInfo(Font font, int codepoint);                                     \/\/ Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found$/;"	p
GetImageAlphaBorder	.\include\raylib.h	/^RLAPI Rectangle GetImageAlphaBorder(Image image, float threshold);                                       \/\/ Get image alpha border rectangle$/;"	p
GetImageColor	.\include\raylib.h	/^RLAPI Color GetImageColor(Image image, int x, int y);                                                    \/\/ Get image pixel color at (x, y) position$/;"	p
GetKeyPressed	.\include\raylib.h	/^RLAPI int GetKeyPressed(void);                                \/\/ Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty$/;"	p
GetMasterVolume	.\include\raylib.h	/^RLAPI float GetMasterVolume(void);                                    \/\/ Get master volume (listener)$/;"	p
GetMeshBoundingBox	.\include\raylib.h	/^RLAPI BoundingBox GetMeshBoundingBox(Mesh mesh);                                            \/\/ Compute mesh bounding box limits$/;"	p
GetModelBoundingBox	.\include\raylib.h	/^RLAPI BoundingBox GetModelBoundingBox(Model model);                                         \/\/ Compute model bounding box limits (considers all meshes)$/;"	p
GetMonitorCount	.\include\raylib.h	/^RLAPI int GetMonitorCount(void);                                  \/\/ Get number of connected monitors$/;"	p
GetMonitorHeight	.\include\raylib.h	/^RLAPI int GetMonitorHeight(int monitor);                          \/\/ Get specified monitor height (current video mode used by monitor)$/;"	p
GetMonitorName	.\include\raylib.h	/^RLAPI const char *GetMonitorName(int monitor);                    \/\/ Get the human-readable, UTF-8 encoded name of the specified monitor$/;"	p
GetMonitorPhysicalHeight	.\include\raylib.h	/^RLAPI int GetMonitorPhysicalHeight(int monitor);                  \/\/ Get specified monitor physical height in millimetres$/;"	p
GetMonitorPhysicalWidth	.\include\raylib.h	/^RLAPI int GetMonitorPhysicalWidth(int monitor);                   \/\/ Get specified monitor physical width in millimetres$/;"	p
GetMonitorPosition	.\include\raylib.h	/^RLAPI Vector2 GetMonitorPosition(int monitor);                    \/\/ Get specified monitor position$/;"	p
GetMonitorRefreshRate	.\include\raylib.h	/^RLAPI int GetMonitorRefreshRate(int monitor);                     \/\/ Get specified monitor refresh rate$/;"	p
GetMonitorWidth	.\include\raylib.h	/^RLAPI int GetMonitorWidth(int monitor);                           \/\/ Get specified monitor width (current video mode used by monitor)$/;"	p
GetMouseDelta	.\include\raylib.h	/^RLAPI Vector2 GetMouseDelta(void);                            \/\/ Get mouse delta between frames$/;"	p
GetMousePosition	.\include\raylib.h	/^RLAPI Vector2 GetMousePosition(void);                         \/\/ Get mouse position XY$/;"	p
GetMouseRay	.\include\raylib.h	/^RLAPI Ray GetMouseRay(Vector2 mousePosition, Camera camera);      \/\/ Get a ray trace from mouse position$/;"	p
GetMouseWheelMove	.\include\raylib.h	/^RLAPI float GetMouseWheelMove(void);                          \/\/ Get mouse wheel movement for X or Y, whichever is larger$/;"	p
GetMouseWheelMoveV	.\include\raylib.h	/^RLAPI Vector2 GetMouseWheelMoveV(void);                       \/\/ Get mouse wheel movement for both X and Y$/;"	p
GetMouseX	.\include\raylib.h	/^RLAPI int GetMouseX(void);                                    \/\/ Get mouse position X$/;"	p
GetMouseY	.\include\raylib.h	/^RLAPI int GetMouseY(void);                                    \/\/ Get mouse position Y$/;"	p
GetMusicTimeLength	.\include\raylib.h	/^RLAPI float GetMusicTimeLength(Music music);                          \/\/ Get music time length (in seconds)$/;"	p
GetMusicTimePlayed	.\include\raylib.h	/^RLAPI float GetMusicTimePlayed(Music music);                          \/\/ Get current music time played (in seconds)$/;"	p
GetPixelColor	.\include\raylib.h	/^RLAPI Color GetPixelColor(void *srcPtr, int format);                        \/\/ Get Color from a source pixel pointer of certain format$/;"	p
GetPixelDataSize	.\include\raylib.h	/^RLAPI int GetPixelDataSize(int width, int height, int format);              \/\/ Get pixel data size in bytes for certain format$/;"	p
GetPrevDirectoryPath	.\include\raylib.h	/^RLAPI const char *GetPrevDirectoryPath(const char *dirPath);      \/\/ Get previous directory path for a given path (uses static string)$/;"	p
GetRandomValue	.\include\raylib.h	/^RLAPI int GetRandomValue(int min, int max);                       \/\/ Get a random value between min and max (both included)$/;"	p
GetRayCollisionBox	.\include\raylib.h	/^RLAPI RayCollision GetRayCollisionBox(Ray ray, BoundingBox box);                                    \/\/ Get collision info between ray and box$/;"	p
GetRayCollisionMesh	.\include\raylib.h	/^RLAPI RayCollision GetRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform);                       \/\/ Get collision info between ray and mesh$/;"	p
GetRayCollisionQuad	.\include\raylib.h	/^RLAPI RayCollision GetRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4);    \/\/ Get collision info between ray and quad$/;"	p
GetRayCollisionSphere	.\include\raylib.h	/^RLAPI RayCollision GetRayCollisionSphere(Ray ray, Vector3 center, float radius);                    \/\/ Get collision info between ray and sphere$/;"	p
GetRayCollisionTriangle	.\include\raylib.h	/^RLAPI RayCollision GetRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3);            \/\/ Get collision info between ray and triangle$/;"	p
GetRenderHeight	.\include\raylib.h	/^RLAPI int GetRenderHeight(void);                                  \/\/ Get current render height (it considers HiDPI)$/;"	p
GetRenderWidth	.\include\raylib.h	/^RLAPI int GetRenderWidth(void);                                   \/\/ Get current render width (it considers HiDPI)$/;"	p
GetScreenHeight	.\include\raylib.h	/^RLAPI int GetScreenHeight(void);                                  \/\/ Get current screen height$/;"	p
GetScreenToWorld2D	.\include\raylib.h	/^RLAPI Vector2 GetScreenToWorld2D(Vector2 position, Camera2D camera); \/\/ Get the world space position for a 2d camera screen space position$/;"	p
GetScreenWidth	.\include\raylib.h	/^RLAPI int GetScreenWidth(void);                                   \/\/ Get current screen width$/;"	p
GetShaderLocation	.\include\raylib.h	/^RLAPI int GetShaderLocation(Shader shader, const char *uniformName);       \/\/ Get shader uniform location$/;"	p
GetShaderLocationAttrib	.\include\raylib.h	/^RLAPI int GetShaderLocationAttrib(Shader shader, const char *attribName);  \/\/ Get shader attribute location$/;"	p
GetSplinePointBasis	.\include\raylib.h	/^RLAPI Vector2 GetSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);              \/\/ Get (evaluate) spline point: B-Spline$/;"	p
GetSplinePointBezierCubic	.\include\raylib.h	/^RLAPI Vector2 GetSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t);        \/\/ Get (evaluate) spline point: Cubic Bezier$/;"	p
GetSplinePointBezierQuad	.\include\raylib.h	/^RLAPI Vector2 GetSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t);                     \/\/ Get (evaluate) spline point: Quadratic Bezier$/;"	p
GetSplinePointCatmullRom	.\include\raylib.h	/^RLAPI Vector2 GetSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);         \/\/ Get (evaluate) spline point: Catmull-Rom$/;"	p
GetSplinePointLinear	.\include\raylib.h	/^RLAPI Vector2 GetSplinePointLinear(Vector2 startPos, Vector2 endPos, float t);                           \/\/ Get (evaluate) spline point: Linear$/;"	p
GetTime	.\include\raylib.h	/^RLAPI double GetTime(void);                                       \/\/ Get elapsed time in seconds since InitWindow()$/;"	p
GetTouchPointCount	.\include\raylib.h	/^RLAPI int GetTouchPointCount(void);                           \/\/ Get number of touch points$/;"	p
GetTouchPointId	.\include\raylib.h	/^RLAPI int GetTouchPointId(int index);                         \/\/ Get touch point identifier for given index$/;"	p
GetTouchPosition	.\include\raylib.h	/^RLAPI Vector2 GetTouchPosition(int index);                    \/\/ Get touch position XY for a touch point index (relative to screen size)$/;"	p
GetTouchX	.\include\raylib.h	/^RLAPI int GetTouchX(void);                                    \/\/ Get touch position X for touch point 0 (relative to screen size)$/;"	p
GetTouchY	.\include\raylib.h	/^RLAPI int GetTouchY(void);                                    \/\/ Get touch position Y for touch point 0 (relative to screen size)$/;"	p
GetWindowHandle	.\include\raylib.h	/^RLAPI void *GetWindowHandle(void);                                \/\/ Get native window handle$/;"	p
GetWindowPosition	.\include\raylib.h	/^RLAPI Vector2 GetWindowPosition(void);                            \/\/ Get window position XY on monitor$/;"	p
GetWindowScaleDPI	.\include\raylib.h	/^RLAPI Vector2 GetWindowScaleDPI(void);                            \/\/ Get window scale DPI factor$/;"	p
GetWorkingDirectory	.\include\raylib.h	/^RLAPI const char *GetWorkingDirectory(void);                      \/\/ Get current working directory (uses static string)$/;"	p
GetWorldToScreen	.\include\raylib.h	/^RLAPI Vector2 GetWorldToScreen(Vector3 position, Camera camera);  \/\/ Get the screen space position for a 3d world space position$/;"	p
GetWorldToScreen2D	.\include\raylib.h	/^RLAPI Vector2 GetWorldToScreen2D(Vector2 position, Camera2D camera); \/\/ Get the screen space position for a 2d camera world space position$/;"	p
GetWorldToScreenEx	.\include\raylib.h	/^RLAPI Vector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height); \/\/ Get size position for a 3d world space position$/;"	p
GlyphInfo	.\include\raylib.h	/^typedef struct GlyphInfo {$/;"	s
GlyphInfo	.\include\raylib.h	/^} GlyphInfo;$/;"	t	typeref:struct:GlyphInfo
HideCursor	.\include\raylib.h	/^RLAPI void HideCursor(void);                                      \/\/ Hides cursor$/;"	p
Image	.\include\raylib.h	/^typedef struct Image {$/;"	s
Image	.\include\raylib.h	/^} Image;$/;"	t	typeref:struct:Image
ImageAlphaClear	.\include\raylib.h	/^RLAPI void ImageAlphaClear(Image *image, Color color, float threshold);                                  \/\/ Clear alpha channel to desired color$/;"	p
ImageAlphaCrop	.\include\raylib.h	/^RLAPI void ImageAlphaCrop(Image *image, float threshold);                                                \/\/ Crop image depending on alpha value$/;"	p
ImageAlphaMask	.\include\raylib.h	/^RLAPI void ImageAlphaMask(Image *image, Image alphaMask);                                                \/\/ Apply alpha mask to image$/;"	p
ImageAlphaPremultiply	.\include\raylib.h	/^RLAPI void ImageAlphaPremultiply(Image *image);                                                          \/\/ Premultiply alpha channel$/;"	p
ImageBlurGaussian	.\include\raylib.h	/^RLAPI void ImageBlurGaussian(Image *image, int blurSize);                                                \/\/ Apply Gaussian blur using a box blur approximation$/;"	p
ImageClearBackground	.\include\raylib.h	/^RLAPI void ImageClearBackground(Image *dst, Color color);                                                \/\/ Clear image background with given color$/;"	p
ImageColorBrightness	.\include\raylib.h	/^RLAPI void ImageColorBrightness(Image *image, int brightness);                                           \/\/ Modify image color: brightness (-255 to 255)$/;"	p
ImageColorContrast	.\include\raylib.h	/^RLAPI void ImageColorContrast(Image *image, float contrast);                                             \/\/ Modify image color: contrast (-100 to 100)$/;"	p
ImageColorGrayscale	.\include\raylib.h	/^RLAPI void ImageColorGrayscale(Image *image);                                                            \/\/ Modify image color: grayscale$/;"	p
ImageColorInvert	.\include\raylib.h	/^RLAPI void ImageColorInvert(Image *image);                                                               \/\/ Modify image color: invert$/;"	p
ImageColorReplace	.\include\raylib.h	/^RLAPI void ImageColorReplace(Image *image, Color color, Color replace);                                  \/\/ Modify image color: replace color$/;"	p
ImageColorTint	.\include\raylib.h	/^RLAPI void ImageColorTint(Image *image, Color color);                                                    \/\/ Modify image color: tint$/;"	p
ImageCopy	.\include\raylib.h	/^RLAPI Image ImageCopy(Image image);                                                                      \/\/ Create an image duplicate (useful for transformations)$/;"	p
ImageCrop	.\include\raylib.h	/^RLAPI void ImageCrop(Image *image, Rectangle crop);                                                      \/\/ Crop an image to a defined rectangle$/;"	p
ImageDither	.\include\raylib.h	/^RLAPI void ImageDither(Image *image, int rBpp, int gBpp, int bBpp, int aBpp);                            \/\/ Dither image data to 16bpp or lower (Floyd-Steinberg dithering)$/;"	p
ImageDraw	.\include\raylib.h	/^RLAPI void ImageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint);             \/\/ Draw a source image within a destination image (tint applied to source)$/;"	p
ImageDrawCircle	.\include\raylib.h	/^RLAPI void ImageDrawCircle(Image *dst, int centerX, int centerY, int radius, Color color);               \/\/ Draw a filled circle within an image$/;"	p
ImageDrawCircleLines	.\include\raylib.h	/^RLAPI void ImageDrawCircleLines(Image *dst, int centerX, int centerY, int radius, Color color);          \/\/ Draw circle outline within an image$/;"	p
ImageDrawCircleLinesV	.\include\raylib.h	/^RLAPI void ImageDrawCircleLinesV(Image *dst, Vector2 center, int radius, Color color);                   \/\/ Draw circle outline within an image (Vector version)$/;"	p
ImageDrawCircleV	.\include\raylib.h	/^RLAPI void ImageDrawCircleV(Image *dst, Vector2 center, int radius, Color color);                        \/\/ Draw a filled circle within an image (Vector version)$/;"	p
ImageDrawLine	.\include\raylib.h	/^RLAPI void ImageDrawLine(Image *dst, int startPosX, int startPosY, int endPosX, int endPosY, Color color); \/\/ Draw line within an image$/;"	p
ImageDrawLineV	.\include\raylib.h	/^RLAPI void ImageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color);                          \/\/ Draw line within an image (Vector version)$/;"	p
ImageDrawPixel	.\include\raylib.h	/^RLAPI void ImageDrawPixel(Image *dst, int posX, int posY, Color color);                                  \/\/ Draw pixel within an image$/;"	p
ImageDrawPixelV	.\include\raylib.h	/^RLAPI void ImageDrawPixelV(Image *dst, Vector2 position, Color color);                                   \/\/ Draw pixel within an image (Vector version)$/;"	p
ImageDrawRectangle	.\include\raylib.h	/^RLAPI void ImageDrawRectangle(Image *dst, int posX, int posY, int width, int height, Color color);       \/\/ Draw rectangle within an image$/;"	p
ImageDrawRectangleLines	.\include\raylib.h	/^RLAPI void ImageDrawRectangleLines(Image *dst, Rectangle rec, int thick, Color color);                   \/\/ Draw rectangle lines within an image$/;"	p
ImageDrawRectangleRec	.\include\raylib.h	/^RLAPI void ImageDrawRectangleRec(Image *dst, Rectangle rec, Color color);                                \/\/ Draw rectangle within an image$/;"	p
ImageDrawRectangleV	.\include\raylib.h	/^RLAPI void ImageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color);                 \/\/ Draw rectangle within an image (Vector version)$/;"	p
ImageDrawText	.\include\raylib.h	/^RLAPI void ImageDrawText(Image *dst, const char *text, int posX, int posY, int fontSize, Color color);   \/\/ Draw text (using default font) within an image (destination)$/;"	p
ImageDrawTextEx	.\include\raylib.h	/^RLAPI void ImageDrawTextEx(Image *dst, Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint); \/\/ Draw text (custom sprite font) within an image (destination)$/;"	p
ImageFlipHorizontal	.\include\raylib.h	/^RLAPI void ImageFlipHorizontal(Image *image);                                                            \/\/ Flip image horizontally$/;"	p
ImageFlipVertical	.\include\raylib.h	/^RLAPI void ImageFlipVertical(Image *image);                                                              \/\/ Flip image vertically$/;"	p
ImageFormat	.\include\raylib.h	/^RLAPI void ImageFormat(Image *image, int newFormat);                                                     \/\/ Convert image data to desired format$/;"	p
ImageFromImage	.\include\raylib.h	/^RLAPI Image ImageFromImage(Image image, Rectangle rec);                                                  \/\/ Create an image from another image piece$/;"	p
ImageMipmaps	.\include\raylib.h	/^RLAPI void ImageMipmaps(Image *image);                                                                   \/\/ Compute all mipmap levels for a provided image$/;"	p
ImageResize	.\include\raylib.h	/^RLAPI void ImageResize(Image *image, int newWidth, int newHeight);                                       \/\/ Resize image (Bicubic scaling algorithm)$/;"	p
ImageResizeCanvas	.\include\raylib.h	/^RLAPI void ImageResizeCanvas(Image *image, int newWidth, int newHeight, int offsetX, int offsetY, Color fill);  \/\/ Resize canvas and fill with color$/;"	p
ImageResizeNN	.\include\raylib.h	/^RLAPI void ImageResizeNN(Image *image, int newWidth,int newHeight);                                      \/\/ Resize image (Nearest-Neighbor scaling algorithm)$/;"	p
ImageRotate	.\include\raylib.h	/^RLAPI void ImageRotate(Image *image, int degrees);                                                       \/\/ Rotate image by input angle in degrees (-359 to 359)$/;"	p
ImageRotateCCW	.\include\raylib.h	/^RLAPI void ImageRotateCCW(Image *image);                                                                 \/\/ Rotate image counter-clockwise 90deg$/;"	p
ImageRotateCW	.\include\raylib.h	/^RLAPI void ImageRotateCW(Image *image);                                                                  \/\/ Rotate image clockwise 90deg$/;"	p
ImageText	.\include\raylib.h	/^RLAPI Image ImageText(const char *text, int fontSize, Color color);                                      \/\/ Create an image from text (default font)$/;"	p
ImageTextEx	.\include\raylib.h	/^RLAPI Image ImageTextEx(Font font, const char *text, float fontSize, float spacing, Color tint);         \/\/ Create an image from text (custom sprite font)$/;"	p
ImageToPOT	.\include\raylib.h	/^RLAPI void ImageToPOT(Image *image, Color fill);                                                         \/\/ Convert image to POT (power-of-two)$/;"	p
InitAudioDevice	.\include\raylib.h	/^RLAPI void InitAudioDevice(void);                                     \/\/ Initialize audio device and context$/;"	p
InitWindow	.\include\raylib.h	/^RLAPI void InitWindow(int width, int height, const char *title);  \/\/ Initialize window and OpenGL context$/;"	p
IsAudioDeviceReady	.\include\raylib.h	/^RLAPI bool IsAudioDeviceReady(void);                                  \/\/ Check if audio device has been initialized successfully$/;"	p
IsAudioStreamPlaying	.\include\raylib.h	/^RLAPI bool IsAudioStreamPlaying(AudioStream stream);                  \/\/ Check if audio stream is playing$/;"	p
IsAudioStreamProcessed	.\include\raylib.h	/^RLAPI bool IsAudioStreamProcessed(AudioStream stream);                \/\/ Check if any audio stream buffers requires refill$/;"	p
IsAudioStreamReady	.\include\raylib.h	/^RLAPI bool IsAudioStreamReady(AudioStream stream);                    \/\/ Checks if an audio stream is ready$/;"	p
IsCursorHidden	.\include\raylib.h	/^RLAPI bool IsCursorHidden(void);                                  \/\/ Check if cursor is not visible$/;"	p
IsCursorOnScreen	.\include\raylib.h	/^RLAPI bool IsCursorOnScreen(void);                                \/\/ Check if cursor is on the screen$/;"	p
IsFileDropped	.\include\raylib.h	/^RLAPI bool IsFileDropped(void);                                   \/\/ Check if a file has been dropped into window$/;"	p
IsFileExtension	.\include\raylib.h	/^RLAPI bool IsFileExtension(const char *fileName, const char *ext); \/\/ Check file extension (including point: .png, .wav)$/;"	p
IsFontReady	.\include\raylib.h	/^RLAPI bool IsFontReady(Font font);                                                          \/\/ Check if a font is ready$/;"	p
IsGamepadAvailable	.\include\raylib.h	/^RLAPI bool IsGamepadAvailable(int gamepad);                   \/\/ Check if a gamepad is available$/;"	p
IsGamepadButtonDown	.\include\raylib.h	/^RLAPI bool IsGamepadButtonDown(int gamepad, int button);      \/\/ Check if a gamepad button is being pressed$/;"	p
IsGamepadButtonPressed	.\include\raylib.h	/^RLAPI bool IsGamepadButtonPressed(int gamepad, int button);   \/\/ Check if a gamepad button has been pressed once$/;"	p
IsGamepadButtonReleased	.\include\raylib.h	/^RLAPI bool IsGamepadButtonReleased(int gamepad, int button);  \/\/ Check if a gamepad button has been released once$/;"	p
IsGamepadButtonUp	.\include\raylib.h	/^RLAPI bool IsGamepadButtonUp(int gamepad, int button);        \/\/ Check if a gamepad button is NOT being pressed$/;"	p
IsGestureDetected	.\include\raylib.h	/^RLAPI bool IsGestureDetected(unsigned int gesture);     \/\/ Check if a gesture have been detected$/;"	p
IsImageReady	.\include\raylib.h	/^RLAPI bool IsImageReady(Image image);                                                                    \/\/ Check if an image is ready$/;"	p
IsKeyDown	.\include\raylib.h	/^RLAPI bool IsKeyDown(int key);                                \/\/ Check if a key is being pressed$/;"	p
IsKeyPressed	.\include\raylib.h	/^RLAPI bool IsKeyPressed(int key);                             \/\/ Check if a key has been pressed once$/;"	p
IsKeyPressedRepeat	.\include\raylib.h	/^RLAPI bool IsKeyPressedRepeat(int key);                       \/\/ Check if a key has been pressed again (Only PLATFORM_DESKTOP)$/;"	p
IsKeyReleased	.\include\raylib.h	/^RLAPI bool IsKeyReleased(int key);                            \/\/ Check if a key has been released once$/;"	p
IsKeyUp	.\include\raylib.h	/^RLAPI bool IsKeyUp(int key);                                  \/\/ Check if a key is NOT being pressed$/;"	p
IsMaterialReady	.\include\raylib.h	/^RLAPI bool IsMaterialReady(Material material);                                              \/\/ Check if a material is ready$/;"	p
IsModelAnimationValid	.\include\raylib.h	/^RLAPI bool IsModelAnimationValid(Model model, ModelAnimation anim);                         \/\/ Check model animation skeleton match$/;"	p
IsModelReady	.\include\raylib.h	/^RLAPI bool IsModelReady(Model model);                                                       \/\/ Check if a model is ready$/;"	p
IsMouseButtonDown	.\include\raylib.h	/^RLAPI bool IsMouseButtonDown(int button);                     \/\/ Check if a mouse button is being pressed$/;"	p
IsMouseButtonPressed	.\include\raylib.h	/^RLAPI bool IsMouseButtonPressed(int button);                  \/\/ Check if a mouse button has been pressed once$/;"	p
IsMouseButtonReleased	.\include\raylib.h	/^RLAPI bool IsMouseButtonReleased(int button);                 \/\/ Check if a mouse button has been released once$/;"	p
IsMouseButtonUp	.\include\raylib.h	/^RLAPI bool IsMouseButtonUp(int button);                       \/\/ Check if a mouse button is NOT being pressed$/;"	p
IsMusicReady	.\include\raylib.h	/^RLAPI bool IsMusicReady(Music music);                                 \/\/ Checks if a music stream is ready$/;"	p
IsMusicStreamPlaying	.\include\raylib.h	/^RLAPI bool IsMusicStreamPlaying(Music music);                         \/\/ Check if music is playing$/;"	p
IsPathFile	.\include\raylib.h	/^RLAPI bool IsPathFile(const char *path);                          \/\/ Check if a given path is a file or a directory$/;"	p
IsRenderTextureReady	.\include\raylib.h	/^RLAPI bool IsRenderTextureReady(RenderTexture2D target);                                                 \/\/ Check if a render texture is ready$/;"	p
IsShaderReady	.\include\raylib.h	/^RLAPI bool IsShaderReady(Shader shader);                                   \/\/ Check if a shader is ready$/;"	p
IsSoundPlaying	.\include\raylib.h	/^RLAPI bool IsSoundPlaying(Sound sound);                               \/\/ Check if a sound is currently playing$/;"	p
IsSoundReady	.\include\raylib.h	/^RLAPI bool IsSoundReady(Sound sound);                                 \/\/ Checks if a sound is ready$/;"	p
IsTextureReady	.\include\raylib.h	/^RLAPI bool IsTextureReady(Texture2D texture);                                                            \/\/ Check if a texture is ready$/;"	p
IsWaveReady	.\include\raylib.h	/^RLAPI bool IsWaveReady(Wave wave);                                    \/\/ Checks if wave data is ready$/;"	p
IsWindowFocused	.\include\raylib.h	/^RLAPI bool IsWindowFocused(void);                                 \/\/ Check if window is currently focused (only PLATFORM_DESKTOP)$/;"	p
IsWindowFullscreen	.\include\raylib.h	/^RLAPI bool IsWindowFullscreen(void);                              \/\/ Check if window is currently fullscreen$/;"	p
IsWindowHidden	.\include\raylib.h	/^RLAPI bool IsWindowHidden(void);                                  \/\/ Check if window is currently hidden (only PLATFORM_DESKTOP)$/;"	p
IsWindowMaximized	.\include\raylib.h	/^RLAPI bool IsWindowMaximized(void);                               \/\/ Check if window is currently maximized (only PLATFORM_DESKTOP)$/;"	p
IsWindowMinimized	.\include\raylib.h	/^RLAPI bool IsWindowMinimized(void);                               \/\/ Check if window is currently minimized (only PLATFORM_DESKTOP)$/;"	p
IsWindowReady	.\include\raylib.h	/^RLAPI bool IsWindowReady(void);                                   \/\/ Check if window has been initialized successfully$/;"	p
IsWindowResized	.\include\raylib.h	/^RLAPI bool IsWindowResized(void);                                 \/\/ Check if window has been resized last frame$/;"	p
IsWindowState	.\include\raylib.h	/^RLAPI bool IsWindowState(unsigned int flag);                      \/\/ Check if one specific window flag is enabled$/;"	p
KEY_A	.\include\raylib.h	/^    KEY_A               = 65,       \/\/ Key: A | a$/;"	e	enum:__anon3
KEY_APOSTROPHE	.\include\raylib.h	/^    KEY_APOSTROPHE      = 39,       \/\/ Key: '$/;"	e	enum:__anon3
KEY_B	.\include\raylib.h	/^    KEY_B               = 66,       \/\/ Key: B | b$/;"	e	enum:__anon3
KEY_BACK	.\include\raylib.h	/^    KEY_BACK            = 4,        \/\/ Key: Android back button$/;"	e	enum:__anon3
KEY_BACKSLASH	.\include\raylib.h	/^    KEY_BACKSLASH       = 92,       \/\/ Key: '\\'$/;"	e	enum:__anon3
KEY_BACKSPACE	.\include\raylib.h	/^    KEY_BACKSPACE       = 259,      \/\/ Key: Backspace$/;"	e	enum:__anon3
KEY_C	.\include\raylib.h	/^    KEY_C               = 67,       \/\/ Key: C | c$/;"	e	enum:__anon3
KEY_CAPS_LOCK	.\include\raylib.h	/^    KEY_CAPS_LOCK       = 280,      \/\/ Key: Caps lock$/;"	e	enum:__anon3
KEY_COMMA	.\include\raylib.h	/^    KEY_COMMA           = 44,       \/\/ Key: ,$/;"	e	enum:__anon3
KEY_D	.\include\raylib.h	/^    KEY_D               = 68,       \/\/ Key: D | d$/;"	e	enum:__anon3
KEY_DELETE	.\include\raylib.h	/^    KEY_DELETE          = 261,      \/\/ Key: Del$/;"	e	enum:__anon3
KEY_DOWN	.\include\raylib.h	/^    KEY_DOWN            = 264,      \/\/ Key: Cursor down$/;"	e	enum:__anon3
KEY_E	.\include\raylib.h	/^    KEY_E               = 69,       \/\/ Key: E | e$/;"	e	enum:__anon3
KEY_EIGHT	.\include\raylib.h	/^    KEY_EIGHT           = 56,       \/\/ Key: 8$/;"	e	enum:__anon3
KEY_END	.\include\raylib.h	/^    KEY_END             = 269,      \/\/ Key: End$/;"	e	enum:__anon3
KEY_ENTER	.\include\raylib.h	/^    KEY_ENTER           = 257,      \/\/ Key: Enter$/;"	e	enum:__anon3
KEY_EQUAL	.\include\raylib.h	/^    KEY_EQUAL           = 61,       \/\/ Key: =$/;"	e	enum:__anon3
KEY_ESCAPE	.\include\raylib.h	/^    KEY_ESCAPE          = 256,      \/\/ Key: Esc$/;"	e	enum:__anon3
KEY_F	.\include\raylib.h	/^    KEY_F               = 70,       \/\/ Key: F | f$/;"	e	enum:__anon3
KEY_F1	.\include\raylib.h	/^    KEY_F1              = 290,      \/\/ Key: F1$/;"	e	enum:__anon3
KEY_F10	.\include\raylib.h	/^    KEY_F10             = 299,      \/\/ Key: F10$/;"	e	enum:__anon3
KEY_F11	.\include\raylib.h	/^    KEY_F11             = 300,      \/\/ Key: F11$/;"	e	enum:__anon3
KEY_F12	.\include\raylib.h	/^    KEY_F12             = 301,      \/\/ Key: F12$/;"	e	enum:__anon3
KEY_F2	.\include\raylib.h	/^    KEY_F2              = 291,      \/\/ Key: F2$/;"	e	enum:__anon3
KEY_F3	.\include\raylib.h	/^    KEY_F3              = 292,      \/\/ Key: F3$/;"	e	enum:__anon3
KEY_F4	.\include\raylib.h	/^    KEY_F4              = 293,      \/\/ Key: F4$/;"	e	enum:__anon3
KEY_F5	.\include\raylib.h	/^    KEY_F5              = 294,      \/\/ Key: F5$/;"	e	enum:__anon3
KEY_F6	.\include\raylib.h	/^    KEY_F6              = 295,      \/\/ Key: F6$/;"	e	enum:__anon3
KEY_F7	.\include\raylib.h	/^    KEY_F7              = 296,      \/\/ Key: F7$/;"	e	enum:__anon3
KEY_F8	.\include\raylib.h	/^    KEY_F8              = 297,      \/\/ Key: F8$/;"	e	enum:__anon3
KEY_F9	.\include\raylib.h	/^    KEY_F9              = 298,      \/\/ Key: F9$/;"	e	enum:__anon3
KEY_FIVE	.\include\raylib.h	/^    KEY_FIVE            = 53,       \/\/ Key: 5$/;"	e	enum:__anon3
KEY_FOUR	.\include\raylib.h	/^    KEY_FOUR            = 52,       \/\/ Key: 4$/;"	e	enum:__anon3
KEY_G	.\include\raylib.h	/^    KEY_G               = 71,       \/\/ Key: G | g$/;"	e	enum:__anon3
KEY_GRAVE	.\include\raylib.h	/^    KEY_GRAVE           = 96,       \/\/ Key: `$/;"	e	enum:__anon3
KEY_H	.\include\raylib.h	/^    KEY_H               = 72,       \/\/ Key: H | h$/;"	e	enum:__anon3
KEY_HOME	.\include\raylib.h	/^    KEY_HOME            = 268,      \/\/ Key: Home$/;"	e	enum:__anon3
KEY_I	.\include\raylib.h	/^    KEY_I               = 73,       \/\/ Key: I | i$/;"	e	enum:__anon3
KEY_INSERT	.\include\raylib.h	/^    KEY_INSERT          = 260,      \/\/ Key: Ins$/;"	e	enum:__anon3
KEY_J	.\include\raylib.h	/^    KEY_J               = 74,       \/\/ Key: J | j$/;"	e	enum:__anon3
KEY_K	.\include\raylib.h	/^    KEY_K               = 75,       \/\/ Key: K | k$/;"	e	enum:__anon3
KEY_KB_MENU	.\include\raylib.h	/^    KEY_KB_MENU         = 348,      \/\/ Key: KB menu$/;"	e	enum:__anon3
KEY_KP_0	.\include\raylib.h	/^    KEY_KP_0            = 320,      \/\/ Key: Keypad 0$/;"	e	enum:__anon3
KEY_KP_1	.\include\raylib.h	/^    KEY_KP_1            = 321,      \/\/ Key: Keypad 1$/;"	e	enum:__anon3
KEY_KP_2	.\include\raylib.h	/^    KEY_KP_2            = 322,      \/\/ Key: Keypad 2$/;"	e	enum:__anon3
KEY_KP_3	.\include\raylib.h	/^    KEY_KP_3            = 323,      \/\/ Key: Keypad 3$/;"	e	enum:__anon3
KEY_KP_4	.\include\raylib.h	/^    KEY_KP_4            = 324,      \/\/ Key: Keypad 4$/;"	e	enum:__anon3
KEY_KP_5	.\include\raylib.h	/^    KEY_KP_5            = 325,      \/\/ Key: Keypad 5$/;"	e	enum:__anon3
KEY_KP_6	.\include\raylib.h	/^    KEY_KP_6            = 326,      \/\/ Key: Keypad 6$/;"	e	enum:__anon3
KEY_KP_7	.\include\raylib.h	/^    KEY_KP_7            = 327,      \/\/ Key: Keypad 7$/;"	e	enum:__anon3
KEY_KP_8	.\include\raylib.h	/^    KEY_KP_8            = 328,      \/\/ Key: Keypad 8$/;"	e	enum:__anon3
KEY_KP_9	.\include\raylib.h	/^    KEY_KP_9            = 329,      \/\/ Key: Keypad 9$/;"	e	enum:__anon3
KEY_KP_ADD	.\include\raylib.h	/^    KEY_KP_ADD          = 334,      \/\/ Key: Keypad +$/;"	e	enum:__anon3
KEY_KP_DECIMAL	.\include\raylib.h	/^    KEY_KP_DECIMAL      = 330,      \/\/ Key: Keypad .$/;"	e	enum:__anon3
KEY_KP_DIVIDE	.\include\raylib.h	/^    KEY_KP_DIVIDE       = 331,      \/\/ Key: Keypad \/$/;"	e	enum:__anon3
KEY_KP_ENTER	.\include\raylib.h	/^    KEY_KP_ENTER        = 335,      \/\/ Key: Keypad Enter$/;"	e	enum:__anon3
KEY_KP_EQUAL	.\include\raylib.h	/^    KEY_KP_EQUAL        = 336,      \/\/ Key: Keypad =$/;"	e	enum:__anon3
KEY_KP_MULTIPLY	.\include\raylib.h	/^    KEY_KP_MULTIPLY     = 332,      \/\/ Key: Keypad *$/;"	e	enum:__anon3
KEY_KP_SUBTRACT	.\include\raylib.h	/^    KEY_KP_SUBTRACT     = 333,      \/\/ Key: Keypad -$/;"	e	enum:__anon3
KEY_L	.\include\raylib.h	/^    KEY_L               = 76,       \/\/ Key: L | l$/;"	e	enum:__anon3
KEY_LEFT	.\include\raylib.h	/^    KEY_LEFT            = 263,      \/\/ Key: Cursor left$/;"	e	enum:__anon3
KEY_LEFT_ALT	.\include\raylib.h	/^    KEY_LEFT_ALT        = 342,      \/\/ Key: Alt left$/;"	e	enum:__anon3
KEY_LEFT_BRACKET	.\include\raylib.h	/^    KEY_LEFT_BRACKET    = 91,       \/\/ Key: [$/;"	e	enum:__anon3
KEY_LEFT_CONTROL	.\include\raylib.h	/^    KEY_LEFT_CONTROL    = 341,      \/\/ Key: Control left$/;"	e	enum:__anon3
KEY_LEFT_SHIFT	.\include\raylib.h	/^    KEY_LEFT_SHIFT      = 340,      \/\/ Key: Shift left$/;"	e	enum:__anon3
KEY_LEFT_SUPER	.\include\raylib.h	/^    KEY_LEFT_SUPER      = 343,      \/\/ Key: Super left$/;"	e	enum:__anon3
KEY_M	.\include\raylib.h	/^    KEY_M               = 77,       \/\/ Key: M | m$/;"	e	enum:__anon3
KEY_MENU	.\include\raylib.h	/^    KEY_MENU            = 82,       \/\/ Key: Android menu button$/;"	e	enum:__anon3
KEY_MINUS	.\include\raylib.h	/^    KEY_MINUS           = 45,       \/\/ Key: -$/;"	e	enum:__anon3
KEY_N	.\include\raylib.h	/^    KEY_N               = 78,       \/\/ Key: N | n$/;"	e	enum:__anon3
KEY_NINE	.\include\raylib.h	/^    KEY_NINE            = 57,       \/\/ Key: 9$/;"	e	enum:__anon3
KEY_NULL	.\include\raylib.h	/^    KEY_NULL            = 0,        \/\/ Key: NULL, used for no key pressed$/;"	e	enum:__anon3
KEY_NUM_LOCK	.\include\raylib.h	/^    KEY_NUM_LOCK        = 282,      \/\/ Key: Num lock$/;"	e	enum:__anon3
KEY_O	.\include\raylib.h	/^    KEY_O               = 79,       \/\/ Key: O | o$/;"	e	enum:__anon3
KEY_ONE	.\include\raylib.h	/^    KEY_ONE             = 49,       \/\/ Key: 1$/;"	e	enum:__anon3
KEY_P	.\include\raylib.h	/^    KEY_P               = 80,       \/\/ Key: P | p$/;"	e	enum:__anon3
KEY_PAGE_DOWN	.\include\raylib.h	/^    KEY_PAGE_DOWN       = 267,      \/\/ Key: Page down$/;"	e	enum:__anon3
KEY_PAGE_UP	.\include\raylib.h	/^    KEY_PAGE_UP         = 266,      \/\/ Key: Page up$/;"	e	enum:__anon3
KEY_PAUSE	.\include\raylib.h	/^    KEY_PAUSE           = 284,      \/\/ Key: Pause$/;"	e	enum:__anon3
KEY_PERIOD	.\include\raylib.h	/^    KEY_PERIOD          = 46,       \/\/ Key: .$/;"	e	enum:__anon3
KEY_PRINT_SCREEN	.\include\raylib.h	/^    KEY_PRINT_SCREEN    = 283,      \/\/ Key: Print screen$/;"	e	enum:__anon3
KEY_Q	.\include\raylib.h	/^    KEY_Q               = 81,       \/\/ Key: Q | q$/;"	e	enum:__anon3
KEY_R	.\include\raylib.h	/^    KEY_R               = 82,       \/\/ Key: R | r$/;"	e	enum:__anon3
KEY_RIGHT	.\include\raylib.h	/^    KEY_RIGHT           = 262,      \/\/ Key: Cursor right$/;"	e	enum:__anon3
KEY_RIGHT_ALT	.\include\raylib.h	/^    KEY_RIGHT_ALT       = 346,      \/\/ Key: Alt right$/;"	e	enum:__anon3
KEY_RIGHT_BRACKET	.\include\raylib.h	/^    KEY_RIGHT_BRACKET   = 93,       \/\/ Key: ]$/;"	e	enum:__anon3
KEY_RIGHT_CONTROL	.\include\raylib.h	/^    KEY_RIGHT_CONTROL   = 345,      \/\/ Key: Control right$/;"	e	enum:__anon3
KEY_RIGHT_SHIFT	.\include\raylib.h	/^    KEY_RIGHT_SHIFT     = 344,      \/\/ Key: Shift right$/;"	e	enum:__anon3
KEY_RIGHT_SUPER	.\include\raylib.h	/^    KEY_RIGHT_SUPER     = 347,      \/\/ Key: Super right$/;"	e	enum:__anon3
KEY_S	.\include\raylib.h	/^    KEY_S               = 83,       \/\/ Key: S | s$/;"	e	enum:__anon3
KEY_SCROLL_LOCK	.\include\raylib.h	/^    KEY_SCROLL_LOCK     = 281,      \/\/ Key: Scroll down$/;"	e	enum:__anon3
KEY_SEMICOLON	.\include\raylib.h	/^    KEY_SEMICOLON       = 59,       \/\/ Key: ;$/;"	e	enum:__anon3
KEY_SEVEN	.\include\raylib.h	/^    KEY_SEVEN           = 55,       \/\/ Key: 7$/;"	e	enum:__anon3
KEY_SIX	.\include\raylib.h	/^    KEY_SIX             = 54,       \/\/ Key: 6$/;"	e	enum:__anon3
KEY_SLASH	.\include\raylib.h	/^    KEY_SLASH           = 47,       \/\/ Key: \/$/;"	e	enum:__anon3
KEY_SPACE	.\include\raylib.h	/^    KEY_SPACE           = 32,       \/\/ Key: Space$/;"	e	enum:__anon3
KEY_T	.\include\raylib.h	/^    KEY_T               = 84,       \/\/ Key: T | t$/;"	e	enum:__anon3
KEY_TAB	.\include\raylib.h	/^    KEY_TAB             = 258,      \/\/ Key: Tab$/;"	e	enum:__anon3
KEY_THREE	.\include\raylib.h	/^    KEY_THREE           = 51,       \/\/ Key: 3$/;"	e	enum:__anon3
KEY_TWO	.\include\raylib.h	/^    KEY_TWO             = 50,       \/\/ Key: 2$/;"	e	enum:__anon3
KEY_U	.\include\raylib.h	/^    KEY_U               = 85,       \/\/ Key: U | u$/;"	e	enum:__anon3
KEY_UP	.\include\raylib.h	/^    KEY_UP              = 265,      \/\/ Key: Cursor up$/;"	e	enum:__anon3
KEY_V	.\include\raylib.h	/^    KEY_V               = 86,       \/\/ Key: V | v$/;"	e	enum:__anon3
KEY_VOLUME_DOWN	.\include\raylib.h	/^    KEY_VOLUME_DOWN     = 25        \/\/ Key: Android volume down button$/;"	e	enum:__anon3
KEY_VOLUME_UP	.\include\raylib.h	/^    KEY_VOLUME_UP       = 24,       \/\/ Key: Android volume up button$/;"	e	enum:__anon3
KEY_W	.\include\raylib.h	/^    KEY_W               = 87,       \/\/ Key: W | w$/;"	e	enum:__anon3
KEY_X	.\include\raylib.h	/^    KEY_X               = 88,       \/\/ Key: X | x$/;"	e	enum:__anon3
KEY_Y	.\include\raylib.h	/^    KEY_Y               = 89,       \/\/ Key: Y | y$/;"	e	enum:__anon3
KEY_Z	.\include\raylib.h	/^    KEY_Z               = 90,       \/\/ Key: Z | z$/;"	e	enum:__anon3
KEY_ZERO	.\include\raylib.h	/^    KEY_ZERO            = 48,       \/\/ Key: 0$/;"	e	enum:__anon3
KeyboardKey	.\include\raylib.h	/^} KeyboardKey;$/;"	t	typeref:enum:__anon3
LIGHTGRAY	.\include\raylib.h	164;"	d
LIME	.\include\raylib.h	174;"	d
LOG_ALL	.\include\raylib.h	/^    LOG_ALL = 0,        \/\/ Display all logs$/;"	e	enum:__anon2
LOG_DEBUG	.\include\raylib.h	/^    LOG_DEBUG,          \/\/ Debug logging, used for internal debugging, it should be disabled on release builds$/;"	e	enum:__anon2
LOG_ERROR	.\include\raylib.h	/^    LOG_ERROR,          \/\/ Error logging, used on unrecoverable failures$/;"	e	enum:__anon2
LOG_FATAL	.\include\raylib.h	/^    LOG_FATAL,          \/\/ Fatal logging, used to abort program: exit(EXIT_FAILURE)$/;"	e	enum:__anon2
LOG_INFO	.\include\raylib.h	/^    LOG_INFO,           \/\/ Info logging, used for program execution info$/;"	e	enum:__anon2
LOG_NONE	.\include\raylib.h	/^    LOG_NONE            \/\/ Disable logging$/;"	e	enum:__anon2
LOG_TRACE	.\include\raylib.h	/^    LOG_TRACE,          \/\/ Trace logging, intended for internal use only$/;"	e	enum:__anon2
LOG_WARNING	.\include\raylib.h	/^    LOG_WARNING,        \/\/ Warning logging, used on recoverable failures$/;"	e	enum:__anon2
Lerp	.\include\raymath.h	/^RMAPI float Lerp(float start, float end, float amount)$/;"	f
LoadAudioStream	.\include\raylib.h	/^RLAPI AudioStream LoadAudioStream(unsigned int sampleRate, unsigned int sampleSize, unsigned int channels); \/\/ Load audio stream (to stream raw audio pcm data)$/;"	p
LoadAutomationEventList	.\include\raylib.h	/^RLAPI AutomationEventList LoadAutomationEventList(const char *fileName);                \/\/ Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS$/;"	p
LoadCodepoints	.\include\raylib.h	/^RLAPI int *LoadCodepoints(const char *text, int *count);                \/\/ Load all codepoints from a UTF-8 text string, codepoints count returned by parameter$/;"	p
LoadDirectoryFiles	.\include\raylib.h	/^RLAPI FilePathList LoadDirectoryFiles(const char *dirPath);       \/\/ Load directory filepaths$/;"	p
LoadDirectoryFilesEx	.\include\raylib.h	/^RLAPI FilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs); \/\/ Load directory filepaths with extension filtering and recursive directory scan$/;"	p
LoadDroppedFiles	.\include\raylib.h	/^RLAPI FilePathList LoadDroppedFiles(void);                        \/\/ Load dropped filepaths$/;"	p
LoadFileData	.\include\raylib.h	/^RLAPI unsigned char *LoadFileData(const char *fileName, int *dataSize); \/\/ Load file data as byte array (read)$/;"	p
LoadFileDataCallback	.\include\raylib.h	/^typedef unsigned char *(*LoadFileDataCallback)(const char *fileName, int *dataSize);    \/\/ FileIO: Load binary data$/;"	t
LoadFileText	.\include\raylib.h	/^RLAPI char *LoadFileText(const char *fileName);                   \/\/ Load text data from file (read), returns a '\\0' terminated string$/;"	p
LoadFileTextCallback	.\include\raylib.h	/^typedef char *(*LoadFileTextCallback)(const char *fileName);            \/\/ FileIO: Load text data$/;"	t
LoadFont	.\include\raylib.h	/^RLAPI Font LoadFont(const char *fileName);                                                  \/\/ Load font from file into GPU memory (VRAM)$/;"	p
LoadFontData	.\include\raylib.h	/^RLAPI GlyphInfo *LoadFontData(const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount, int type); \/\/ Load font data for further use$/;"	p
LoadFontEx	.\include\raylib.h	/^RLAPI Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount);  \/\/ Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set$/;"	p
LoadFontFromImage	.\include\raylib.h	/^RLAPI Font LoadFontFromImage(Image image, Color key, int firstChar);                        \/\/ Load font from Image (XNA style)$/;"	p
LoadFontFromMemory	.\include\raylib.h	/^RLAPI Font LoadFontFromMemory(const char *fileType, const unsigned char *fileData, int dataSize, int fontSize, int *codepoints, int codepointCount); \/\/ Load font from memory buffer, fileType refers to extension: i.e. '.ttf'$/;"	p
LoadImage	.\include\raylib.h	/^RLAPI Image LoadImage(const char *fileName);                                                             \/\/ Load image from file into CPU memory (RAM)$/;"	p
LoadImageAnim	.\include\raylib.h	/^RLAPI Image LoadImageAnim(const char *fileName, int *frames);                                            \/\/ Load image sequence from file (frames appended to image.data)$/;"	p
LoadImageColors	.\include\raylib.h	/^RLAPI Color *LoadImageColors(Image image);                                                               \/\/ Load color data from image as a Color array (RGBA - 32bit)$/;"	p
LoadImageFromMemory	.\include\raylib.h	/^RLAPI Image LoadImageFromMemory(const char *fileType, const unsigned char *fileData, int dataSize);      \/\/ Load image from memory buffer, fileType refers to extension: i.e. '.png'$/;"	p
LoadImageFromScreen	.\include\raylib.h	/^RLAPI Image LoadImageFromScreen(void);                                                                   \/\/ Load image from screen buffer and (screenshot)$/;"	p
LoadImageFromTexture	.\include\raylib.h	/^RLAPI Image LoadImageFromTexture(Texture2D texture);                                                     \/\/ Load image from GPU texture data$/;"	p
LoadImagePalette	.\include\raylib.h	/^RLAPI Color *LoadImagePalette(Image image, int maxPaletteSize, int *colorCount);                         \/\/ Load colors palette from image as a Color array (RGBA - 32bit)$/;"	p
LoadImageRaw	.\include\raylib.h	/^RLAPI Image LoadImageRaw(const char *fileName, int width, int height, int format, int headerSize);       \/\/ Load image from RAW file data$/;"	p
LoadImageSvg	.\include\raylib.h	/^RLAPI Image LoadImageSvg(const char *fileNameOrString, int width, int height);                           \/\/ Load image from SVG file data or string with specified size$/;"	p
LoadMaterialDefault	.\include\raylib.h	/^RLAPI Material LoadMaterialDefault(void);                                                   \/\/ Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)$/;"	p
LoadMaterials	.\include\raylib.h	/^RLAPI Material *LoadMaterials(const char *fileName, int *materialCount);                    \/\/ Load materials from model file$/;"	p
LoadModel	.\include\raylib.h	/^RLAPI Model LoadModel(const char *fileName);                                                \/\/ Load model from files (meshes and materials)$/;"	p
LoadModelAnimations	.\include\raylib.h	/^RLAPI ModelAnimation *LoadModelAnimations(const char *fileName, int *animCount);            \/\/ Load model animations from file$/;"	p
LoadModelFromMesh	.\include\raylib.h	/^RLAPI Model LoadModelFromMesh(Mesh mesh);                                                   \/\/ Load model from generated mesh (default material)$/;"	p
LoadMusicStream	.\include\raylib.h	/^RLAPI Music LoadMusicStream(const char *fileName);                    \/\/ Load music stream from file$/;"	p
LoadMusicStreamFromMemory	.\include\raylib.h	/^RLAPI Music LoadMusicStreamFromMemory(const char *fileType, const unsigned char *data, int dataSize); \/\/ Load music stream from data$/;"	p
LoadRandomSequence	.\include\raylib.h	/^RLAPI int *LoadRandomSequence(unsigned int count, int min, int max); \/\/ Load random values sequence, no values repeated$/;"	p
LoadRenderTexture	.\include\raylib.h	/^RLAPI RenderTexture2D LoadRenderTexture(int width, int height);                                          \/\/ Load texture for rendering (framebuffer)$/;"	p
LoadShader	.\include\raylib.h	/^RLAPI Shader LoadShader(const char *vsFileName, const char *fsFileName);   \/\/ Load shader from files and bind default locations$/;"	p
LoadShaderFromMemory	.\include\raylib.h	/^RLAPI Shader LoadShaderFromMemory(const char *vsCode, const char *fsCode); \/\/ Load shader from code strings and bind default locations$/;"	p
LoadSound	.\include\raylib.h	/^RLAPI Sound LoadSound(const char *fileName);                          \/\/ Load sound from file$/;"	p
LoadSoundAlias	.\include\raylib.h	/^RLAPI Sound LoadSoundAlias(Sound source);                             \/\/ Create a new sound that shares the same sample data as the source sound, does not own the sound data$/;"	p
LoadSoundFromWave	.\include\raylib.h	/^RLAPI Sound LoadSoundFromWave(Wave wave);                             \/\/ Load sound from wave data$/;"	p
LoadTexture	.\include\raylib.h	/^RLAPI Texture2D LoadTexture(const char *fileName);                                                       \/\/ Load texture from file into GPU memory (VRAM)$/;"	p
LoadTextureCubemap	.\include\raylib.h	/^RLAPI TextureCubemap LoadTextureCubemap(Image image, int layout);                                        \/\/ Load cubemap from image, multiple image cubemap layouts supported$/;"	p
LoadTextureFromImage	.\include\raylib.h	/^RLAPI Texture2D LoadTextureFromImage(Image image);                                                       \/\/ Load texture from image data$/;"	p
LoadUTF8	.\include\raylib.h	/^RLAPI char *LoadUTF8(const int *codepoints, int length);                \/\/ Load UTF-8 text encoded from codepoints array$/;"	p
LoadVrStereoConfig	.\include\raylib.h	/^RLAPI VrStereoConfig LoadVrStereoConfig(VrDeviceInfo device);     \/\/ Load VR stereo config for VR simulator device parameters$/;"	p
LoadWave	.\include\raylib.h	/^RLAPI Wave LoadWave(const char *fileName);                            \/\/ Load wave data from file$/;"	p
LoadWaveFromMemory	.\include\raylib.h	/^RLAPI Wave LoadWaveFromMemory(const char *fileType, const unsigned char *fileData, int dataSize); \/\/ Load wave from memory buffer, fileType refers to extension: i.e. '.wav'$/;"	p
LoadWaveSamples	.\include\raylib.h	/^RLAPI float *LoadWaveSamples(Wave wave);                              \/\/ Load samples data from wave as a 32bit float data array$/;"	p
MAGENTA	.\include\raylib.h	189;"	d
MAROON	.\include\raylib.h	172;"	d
MATERIAL_MAP_ALBEDO	.\include\raylib.h	/^    MATERIAL_MAP_ALBEDO = 0,        \/\/ Albedo material (same as: MATERIAL_MAP_DIFFUSE)$/;"	e	enum:__anon8
MATERIAL_MAP_BRDF	.\include\raylib.h	/^    MATERIAL_MAP_BRDF               \/\/ Brdf material$/;"	e	enum:__anon8
MATERIAL_MAP_CUBEMAP	.\include\raylib.h	/^    MATERIAL_MAP_CUBEMAP,           \/\/ Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)$/;"	e	enum:__anon8
MATERIAL_MAP_DIFFUSE	.\include\raylib.h	759;"	d
MATERIAL_MAP_EMISSION	.\include\raylib.h	/^    MATERIAL_MAP_EMISSION,          \/\/ Emission material$/;"	e	enum:__anon8
MATERIAL_MAP_HEIGHT	.\include\raylib.h	/^    MATERIAL_MAP_HEIGHT,            \/\/ Heightmap material$/;"	e	enum:__anon8
MATERIAL_MAP_IRRADIANCE	.\include\raylib.h	/^    MATERIAL_MAP_IRRADIANCE,        \/\/ Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)$/;"	e	enum:__anon8
MATERIAL_MAP_METALNESS	.\include\raylib.h	/^    MATERIAL_MAP_METALNESS,         \/\/ Metalness material (same as: MATERIAL_MAP_SPECULAR)$/;"	e	enum:__anon8
MATERIAL_MAP_NORMAL	.\include\raylib.h	/^    MATERIAL_MAP_NORMAL,            \/\/ Normal material$/;"	e	enum:__anon8
MATERIAL_MAP_OCCLUSION	.\include\raylib.h	/^    MATERIAL_MAP_OCCLUSION,         \/\/ Ambient occlusion material$/;"	e	enum:__anon8
MATERIAL_MAP_PREFILTER	.\include\raylib.h	/^    MATERIAL_MAP_PREFILTER,         \/\/ Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)$/;"	e	enum:__anon8
MATERIAL_MAP_ROUGHNESS	.\include\raylib.h	/^    MATERIAL_MAP_ROUGHNESS,         \/\/ Roughness material$/;"	e	enum:__anon8
MATERIAL_MAP_SPECULAR	.\include\raylib.h	760;"	d
MAX	.\include\rlgl.h	3368;"	d
MIN	.\include\rlgl.h	3367;"	d
MOUSE_BUTTON_BACK	.\include\raylib.h	/^    MOUSE_BUTTON_BACK    = 6,       \/\/ Mouse button back (advanced mouse device)$/;"	e	enum:__anon4
MOUSE_BUTTON_EXTRA	.\include\raylib.h	/^    MOUSE_BUTTON_EXTRA   = 4,       \/\/ Mouse button extra (advanced mouse device)$/;"	e	enum:__anon4
MOUSE_BUTTON_FORWARD	.\include\raylib.h	/^    MOUSE_BUTTON_FORWARD = 5,       \/\/ Mouse button forward (advanced mouse device)$/;"	e	enum:__anon4
MOUSE_BUTTON_LEFT	.\include\raylib.h	/^    MOUSE_BUTTON_LEFT    = 0,       \/\/ Mouse button left$/;"	e	enum:__anon4
MOUSE_BUTTON_MIDDLE	.\include\raylib.h	/^    MOUSE_BUTTON_MIDDLE  = 2,       \/\/ Mouse button middle (pressed wheel)$/;"	e	enum:__anon4
MOUSE_BUTTON_RIGHT	.\include\raylib.h	/^    MOUSE_BUTTON_RIGHT   = 1,       \/\/ Mouse button right$/;"	e	enum:__anon4
MOUSE_BUTTON_SIDE	.\include\raylib.h	/^    MOUSE_BUTTON_SIDE    = 3,       \/\/ Mouse button side (advanced mouse device)$/;"	e	enum:__anon4
MOUSE_CURSOR_ARROW	.\include\raylib.h	/^    MOUSE_CURSOR_ARROW         = 1,     \/\/ Arrow shape$/;"	e	enum:__anon5
MOUSE_CURSOR_CROSSHAIR	.\include\raylib.h	/^    MOUSE_CURSOR_CROSSHAIR     = 3,     \/\/ Cross shape$/;"	e	enum:__anon5
MOUSE_CURSOR_DEFAULT	.\include\raylib.h	/^    MOUSE_CURSOR_DEFAULT       = 0,     \/\/ Default pointer shape$/;"	e	enum:__anon5
MOUSE_CURSOR_IBEAM	.\include\raylib.h	/^    MOUSE_CURSOR_IBEAM         = 2,     \/\/ Text writing cursor shape$/;"	e	enum:__anon5
MOUSE_CURSOR_NOT_ALLOWED	.\include\raylib.h	/^    MOUSE_CURSOR_NOT_ALLOWED   = 10     \/\/ The operation-not-allowed shape$/;"	e	enum:__anon5
MOUSE_CURSOR_POINTING_HAND	.\include\raylib.h	/^    MOUSE_CURSOR_POINTING_HAND = 4,     \/\/ Pointing hand cursor$/;"	e	enum:__anon5
MOUSE_CURSOR_RESIZE_ALL	.\include\raylib.h	/^    MOUSE_CURSOR_RESIZE_ALL    = 9,     \/\/ The omnidirectional resize\/move cursor shape$/;"	e	enum:__anon5
MOUSE_CURSOR_RESIZE_EW	.\include\raylib.h	/^    MOUSE_CURSOR_RESIZE_EW     = 5,     \/\/ Horizontal resize\/move arrow shape$/;"	e	enum:__anon5
MOUSE_CURSOR_RESIZE_NESW	.\include\raylib.h	/^    MOUSE_CURSOR_RESIZE_NESW   = 8,     \/\/ The top-right to bottom-left diagonal resize\/move arrow shape$/;"	e	enum:__anon5
MOUSE_CURSOR_RESIZE_NS	.\include\raylib.h	/^    MOUSE_CURSOR_RESIZE_NS     = 6,     \/\/ Vertical resize\/move arrow shape$/;"	e	enum:__anon5
MOUSE_CURSOR_RESIZE_NWSE	.\include\raylib.h	/^    MOUSE_CURSOR_RESIZE_NWSE   = 7,     \/\/ Top-left to bottom-right diagonal resize\/move arrow shape$/;"	e	enum:__anon5
MOUSE_LEFT_BUTTON	.\include\raylib.h	682;"	d
MOUSE_MIDDLE_BUTTON	.\include\raylib.h	684;"	d
MOUSE_RIGHT_BUTTON	.\include\raylib.h	683;"	d
Material	.\include\raylib.h	/^typedef struct Material {$/;"	s
Material	.\include\raylib.h	/^} Material;$/;"	t	typeref:struct:Material
MaterialMap	.\include\raylib.h	/^typedef struct MaterialMap {$/;"	s
MaterialMap	.\include\raylib.h	/^} MaterialMap;$/;"	t	typeref:struct:MaterialMap
MaterialMapIndex	.\include\raylib.h	/^} MaterialMapIndex;$/;"	t	typeref:enum:__anon8
Matrix	.\include\raylib.h	/^typedef struct Matrix {$/;"	s
Matrix	.\include\raylib.h	/^} Matrix;$/;"	t	typeref:struct:Matrix
Matrix	.\include\raymath.h	/^typedef struct Matrix {$/;"	s
Matrix	.\include\raymath.h	/^} Matrix;$/;"	t	typeref:struct:Matrix
Matrix	.\include\rlgl.h	/^typedef struct Matrix {$/;"	s
Matrix	.\include\rlgl.h	/^} Matrix;$/;"	t	typeref:struct:Matrix
MatrixAdd	.\include\raymath.h	/^RMAPI Matrix MatrixAdd(Matrix left, Matrix right)$/;"	f
MatrixDeterminant	.\include\raymath.h	/^RMAPI float MatrixDeterminant(Matrix mat)$/;"	f
MatrixFrustum	.\include\raymath.h	/^RMAPI Matrix MatrixFrustum(double left, double right, double bottom, double top, double near, double far)$/;"	f
MatrixIdentity	.\include\raymath.h	/^RMAPI Matrix MatrixIdentity(void)$/;"	f
MatrixInvert	.\include\raymath.h	/^RMAPI Matrix MatrixInvert(Matrix mat)$/;"	f
MatrixLookAt	.\include\raymath.h	/^RMAPI Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)$/;"	f
MatrixMultiply	.\include\raymath.h	/^RMAPI Matrix MatrixMultiply(Matrix left, Matrix right)$/;"	f
MatrixOrtho	.\include\raymath.h	/^RMAPI Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)$/;"	f
MatrixPerspective	.\include\raymath.h	/^RMAPI Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)$/;"	f
MatrixRotate	.\include\raymath.h	/^RMAPI Matrix MatrixRotate(Vector3 axis, float angle)$/;"	f
MatrixRotateX	.\include\raymath.h	/^RMAPI Matrix MatrixRotateX(float angle)$/;"	f
MatrixRotateXYZ	.\include\raymath.h	/^RMAPI Matrix MatrixRotateXYZ(Vector3 angle)$/;"	f
MatrixRotateY	.\include\raymath.h	/^RMAPI Matrix MatrixRotateY(float angle)$/;"	f
MatrixRotateZ	.\include\raymath.h	/^RMAPI Matrix MatrixRotateZ(float angle)$/;"	f
MatrixRotateZYX	.\include\raymath.h	/^RMAPI Matrix MatrixRotateZYX(Vector3 angle)$/;"	f
MatrixScale	.\include\raymath.h	/^RMAPI Matrix MatrixScale(float x, float y, float z)$/;"	f
MatrixSubtract	.\include\raymath.h	/^RMAPI Matrix MatrixSubtract(Matrix left, Matrix right)$/;"	f
MatrixToFloat	.\include\raymath.h	99;"	d
MatrixToFloatV	.\include\raymath.h	/^RMAPI float16 MatrixToFloatV(Matrix mat)$/;"	f
MatrixTrace	.\include\raymath.h	/^RMAPI float MatrixTrace(Matrix mat)$/;"	f
MatrixTranslate	.\include\raymath.h	/^RMAPI Matrix MatrixTranslate(float x, float y, float z)$/;"	f
MatrixTranspose	.\include\raymath.h	/^RMAPI Matrix MatrixTranspose(Matrix mat)$/;"	f
MaximizeWindow	.\include\raylib.h	/^RLAPI void MaximizeWindow(void);                                  \/\/ Set window state: maximized, if resizable (only PLATFORM_DESKTOP)$/;"	p
MeasureText	.\include\raylib.h	/^RLAPI int MeasureText(const char *text, int fontSize);                                      \/\/ Measure string width for default font$/;"	p
MeasureTextEx	.\include\raylib.h	/^RLAPI Vector2 MeasureTextEx(Font font, const char *text, float fontSize, float spacing);    \/\/ Measure string size for Font$/;"	p
MemAlloc	.\include\raylib.h	/^RLAPI void *MemAlloc(unsigned int size);                          \/\/ Internal memory allocator$/;"	p
MemFree	.\include\raylib.h	/^RLAPI void MemFree(void *ptr);                                    \/\/ Internal memory free$/;"	p
MemRealloc	.\include\raylib.h	/^RLAPI void *MemRealloc(void *ptr, unsigned int size);             \/\/ Internal memory reallocator$/;"	p
Mesh	.\include\raylib.h	/^typedef struct Mesh {$/;"	s
Mesh	.\include\raylib.h	/^} Mesh;$/;"	t	typeref:struct:Mesh
MinimizeWindow	.\include\raylib.h	/^RLAPI void MinimizeWindow(void);                                  \/\/ Set window state: minimized, if resizable (only PLATFORM_DESKTOP)$/;"	p
Model	.\include\raylib.h	/^typedef struct Model {$/;"	s
Model	.\include\raylib.h	/^} Model;$/;"	t	typeref:struct:Model
ModelAnimation	.\include\raylib.h	/^typedef struct ModelAnimation {$/;"	s
ModelAnimation	.\include\raylib.h	/^} ModelAnimation;$/;"	t	typeref:struct:ModelAnimation
MouseButton	.\include\raylib.h	/^} MouseButton;$/;"	t	typeref:enum:__anon4
MouseCursor	.\include\raylib.h	/^} MouseCursor;$/;"	t	typeref:enum:__anon5
Music	.\include\raylib.h	/^typedef struct Music {$/;"	s
Music	.\include\raylib.h	/^} Music;$/;"	t	typeref:struct:Music
NPATCH_NINE_PATCH	.\include\raylib.h	/^    NPATCH_NINE_PATCH = 0,          \/\/ Npatch layout: 3x3 tiles$/;"	e	enum:__anon21
NPATCH_THREE_PATCH_HORIZONTAL	.\include\raylib.h	/^    NPATCH_THREE_PATCH_HORIZONTAL   \/\/ Npatch layout: 3x1 tiles$/;"	e	enum:__anon21
NPATCH_THREE_PATCH_VERTICAL	.\include\raylib.h	/^    NPATCH_THREE_PATCH_VERTICAL,    \/\/ Npatch layout: 1x3 tiles$/;"	e	enum:__anon21
NPatchInfo	.\include\raylib.h	/^typedef struct NPatchInfo {$/;"	s
NPatchInfo	.\include\raylib.h	/^} NPatchInfo;$/;"	t	typeref:struct:NPatchInfo
NPatchLayout	.\include\raylib.h	/^} NPatchLayout;$/;"	t	typeref:enum:__anon21
Normalize	.\include\raymath.h	/^RMAPI float Normalize(float value, float start, float end)$/;"	f
ORANGE	.\include\raylib.h	169;"	d
OpenURL	.\include\raylib.h	/^RLAPI void OpenURL(const char *url);                              \/\/ Open URL with default system browser (if available)$/;"	p
PFNGLDRAWARRAYSINSTANCEDEXTPROC	.\include\rlgl.h	/^    typedef void (GL_APIENTRYP PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);$/;"	t
PFNGLDRAWELEMENTSINSTANCEDEXTPROC	.\include\rlgl.h	/^    typedef void (GL_APIENTRYP PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);$/;"	t
PFNGLVERTEXATTRIBDIVISOREXTPROC	.\include\rlgl.h	/^    typedef void (GL_APIENTRYP PFNGLVERTEXATTRIBDIVISOREXTPROC) (GLuint index, GLuint divisor);$/;"	t
PI	.\include\raylib.h	110;"	d
PI	.\include\raymath.h	82;"	d
PI	.\include\rlgl.h	840;"	d
PINK	.\include\raylib.h	170;"	d
PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,   \/\/ 8 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA    \/\/ 2 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_DXT1_RGB	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_DXT1_RGB,        \/\/ 4 bpp (no alpha)$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_DXT1_RGBA	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_DXT1_RGBA,       \/\/ 4 bpp (1 bit alpha)$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_DXT3_RGBA	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_DXT3_RGBA,       \/\/ 8 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_DXT5_RGBA	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_DXT5_RGBA,       \/\/ 8 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_ETC1_RGB	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_ETC1_RGB,        \/\/ 4 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,   \/\/ 8 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_ETC2_RGB	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_ETC2_RGB,        \/\/ 4 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_PVRT_RGB	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_PVRT_RGB,        \/\/ 4 bpp$/;"	e	enum:__anon12
PIXELFORMAT_COMPRESSED_PVRT_RGBA	.\include\raylib.h	/^    PIXELFORMAT_COMPRESSED_PVRT_RGBA,       \/\/ 4 bpp$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_GRAYSCALE	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1, \/\/ 8 bit per pixel (no alpha)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,    \/\/ 8*2 bpp (2 channels)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R16	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R16,           \/\/ 16 bpp (1 channel - half float)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R16G16B16	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R16G16B16,     \/\/ 16*3 bpp (3 channels - half float)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R16G16B16A16	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,  \/\/ 16*4 bpp (4 channels - half float)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R32	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R32,           \/\/ 32 bpp (1 channel - float)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R32G32B32	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R32G32B32,     \/\/ 32*3 bpp (3 channels - float)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R32G32B32A32	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,  \/\/ 32*4 bpp (4 channels - float)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R4G4B4A4	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,      \/\/ 16 bpp (4 bit alpha)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R5G5B5A1	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,      \/\/ 16 bpp (1 bit alpha)$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R5G6B5	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R5G6B5,        \/\/ 16 bpp$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R8G8B8	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R8G8B8,        \/\/ 24 bpp$/;"	e	enum:__anon12
PIXELFORMAT_UNCOMPRESSED_R8G8B8A8	.\include\raylib.h	/^    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,      \/\/ 32 bpp$/;"	e	enum:__anon12
PURPLE	.\include\raylib.h	179;"	d
PauseAudioStream	.\include\raylib.h	/^RLAPI void PauseAudioStream(AudioStream stream);                      \/\/ Pause audio stream$/;"	p
PauseMusicStream	.\include\raylib.h	/^RLAPI void PauseMusicStream(Music music);                             \/\/ Pause music playing$/;"	p
PauseSound	.\include\raylib.h	/^RLAPI void PauseSound(Sound sound);                                   \/\/ Pause a sound$/;"	p
PixelFormat	.\include\raylib.h	/^} PixelFormat;$/;"	t	typeref:enum:__anon12
PlayAudioStream	.\include\raylib.h	/^RLAPI void PlayAudioStream(AudioStream stream);                       \/\/ Play audio stream$/;"	p
PlayAutomationEvent	.\include\raylib.h	/^RLAPI void PlayAutomationEvent(AutomationEvent event);                                  \/\/ Play a recorded automation event$/;"	p
PlayMusicStream	.\include\raylib.h	/^RLAPI void PlayMusicStream(Music music);                              \/\/ Start music playing$/;"	p
PlaySound	.\include\raylib.h	/^RLAPI void PlaySound(Sound sound);                                    \/\/ Play a sound$/;"	p
PollInputEvents	.\include\raylib.h	/^RLAPI void PollInputEvents(void);                                 \/\/ Register all input events$/;"	p
Quaternion	.\include\raylib.h	/^typedef Vector4 Quaternion;$/;"	t
Quaternion	.\include\raymath.h	/^typedef Vector4 Quaternion;$/;"	t
QuaternionAdd	.\include\raymath.h	/^RMAPI Quaternion QuaternionAdd(Quaternion q1, Quaternion q2)$/;"	f
QuaternionAddValue	.\include\raymath.h	/^RMAPI Quaternion QuaternionAddValue(Quaternion q, float add)$/;"	f
QuaternionDivide	.\include\raymath.h	/^RMAPI Quaternion QuaternionDivide(Quaternion q1, Quaternion q2)$/;"	f
QuaternionEquals	.\include\raymath.h	/^RMAPI int QuaternionEquals(Quaternion p, Quaternion q)$/;"	f
QuaternionFromAxisAngle	.\include\raymath.h	/^RMAPI Quaternion QuaternionFromAxisAngle(Vector3 axis, float angle)$/;"	f
QuaternionFromEuler	.\include\raymath.h	/^RMAPI Quaternion QuaternionFromEuler(float pitch, float yaw, float roll)$/;"	f
QuaternionFromMatrix	.\include\raymath.h	/^RMAPI Quaternion QuaternionFromMatrix(Matrix mat)$/;"	f
QuaternionFromVector3ToVector3	.\include\raymath.h	/^RMAPI Quaternion QuaternionFromVector3ToVector3(Vector3 from, Vector3 to)$/;"	f
QuaternionIdentity	.\include\raymath.h	/^RMAPI Quaternion QuaternionIdentity(void)$/;"	f
QuaternionInvert	.\include\raymath.h	/^RMAPI Quaternion QuaternionInvert(Quaternion q)$/;"	f
QuaternionLength	.\include\raymath.h	/^RMAPI float QuaternionLength(Quaternion q)$/;"	f
QuaternionLerp	.\include\raymath.h	/^RMAPI Quaternion QuaternionLerp(Quaternion q1, Quaternion q2, float amount)$/;"	f
QuaternionMultiply	.\include\raymath.h	/^RMAPI Quaternion QuaternionMultiply(Quaternion q1, Quaternion q2)$/;"	f
QuaternionNlerp	.\include\raymath.h	/^RMAPI Quaternion QuaternionNlerp(Quaternion q1, Quaternion q2, float amount)$/;"	f
QuaternionNormalize	.\include\raymath.h	/^RMAPI Quaternion QuaternionNormalize(Quaternion q)$/;"	f
QuaternionScale	.\include\raymath.h	/^RMAPI Quaternion QuaternionScale(Quaternion q, float mul)$/;"	f
QuaternionSlerp	.\include\raymath.h	/^RMAPI Quaternion QuaternionSlerp(Quaternion q1, Quaternion q2, float amount)$/;"	f
QuaternionSubtract	.\include\raymath.h	/^RMAPI Quaternion QuaternionSubtract(Quaternion q1, Quaternion q2)$/;"	f
QuaternionSubtractValue	.\include\raymath.h	/^RMAPI Quaternion QuaternionSubtractValue(Quaternion q, float sub)$/;"	f
QuaternionToAxisAngle	.\include\raymath.h	/^RMAPI void QuaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle)$/;"	f
QuaternionToEuler	.\include\raymath.h	/^RMAPI Vector3 QuaternionToEuler(Quaternion q)$/;"	f
QuaternionToMatrix	.\include\raymath.h	/^RMAPI Matrix QuaternionToMatrix(Quaternion q)$/;"	f
QuaternionTransform	.\include\raymath.h	/^RMAPI Quaternion QuaternionTransform(Quaternion q, Matrix mat)$/;"	f
RAD2DEG	.\include\raylib.h	116;"	d
RAD2DEG	.\include\raymath.h	94;"	d
RAD2DEG	.\include\rlgl.h	846;"	d
RAYLIB_H	.\include\raylib.h	80;"	d
RAYLIB_VERSION	.\include\raylib.h	87;"	d
RAYLIB_VERSION_MAJOR	.\include\raylib.h	84;"	d
RAYLIB_VERSION_MINOR	.\include\raylib.h	85;"	d
RAYLIB_VERSION_PATCH	.\include\raylib.h	86;"	d
RAYMATH_H	.\include\raymath.h	53;"	d
RAYWHITE	.\include\raylib.h	190;"	d
RED	.\include\raylib.h	171;"	d
RENDER_H	.\src\render.h	33;"	d
RLAPI	.\include\raylib.h	103;"	d
RLAPI	.\include\raylib.h	96;"	d
RLAPI	.\include\raylib.h	98;"	d
RLAPI	.\include\rlgl.h	116;"	d
RLAPI	.\include\rlgl.h	118;"	d
RLAPI	.\include\rlgl.h	124;"	d
RLGL	.\include\rlgl.h	/^static rlglData RLGL = { 0 };$/;"	v
RLGL_H	.\include\rlgl.h	108;"	d
RLGL_RENDER_TEXTURES_HINT	.\include\rlgl.h	191;"	d
RLGL_VERSION	.\include\rlgl.h	110;"	d
RL_ATTACHMENT_COLOR_CHANNEL0	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL0 = 0,       \/\/ Framebuffer attachment type: color 0$/;"	e	enum:__anon30
RL_ATTACHMENT_COLOR_CHANNEL1	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL1 = 1,       \/\/ Framebuffer attachment type: color 1$/;"	e	enum:__anon30
RL_ATTACHMENT_COLOR_CHANNEL2	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL2 = 2,       \/\/ Framebuffer attachment type: color 2$/;"	e	enum:__anon30
RL_ATTACHMENT_COLOR_CHANNEL3	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL3 = 3,       \/\/ Framebuffer attachment type: color 3$/;"	e	enum:__anon30
RL_ATTACHMENT_COLOR_CHANNEL4	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL4 = 4,       \/\/ Framebuffer attachment type: color 4$/;"	e	enum:__anon30
RL_ATTACHMENT_COLOR_CHANNEL5	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL5 = 5,       \/\/ Framebuffer attachment type: color 5$/;"	e	enum:__anon30
RL_ATTACHMENT_COLOR_CHANNEL6	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL6 = 6,       \/\/ Framebuffer attachment type: color 6$/;"	e	enum:__anon30
RL_ATTACHMENT_COLOR_CHANNEL7	.\include\rlgl.h	/^    RL_ATTACHMENT_COLOR_CHANNEL7 = 7,       \/\/ Framebuffer attachment type: color 7$/;"	e	enum:__anon30
RL_ATTACHMENT_CUBEMAP_NEGATIVE_X	.\include\rlgl.h	/^    RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1,   \/\/ Framebuffer texture attachment type: cubemap, -X side$/;"	e	enum:__anon31
RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y	.\include\rlgl.h	/^    RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3,   \/\/ Framebuffer texture attachment type: cubemap, -Y side$/;"	e	enum:__anon31
RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z	.\include\rlgl.h	/^    RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5,   \/\/ Framebuffer texture attachment type: cubemap, -Z side$/;"	e	enum:__anon31
RL_ATTACHMENT_CUBEMAP_POSITIVE_X	.\include\rlgl.h	/^    RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0,   \/\/ Framebuffer texture attachment type: cubemap, +X side$/;"	e	enum:__anon31
RL_ATTACHMENT_CUBEMAP_POSITIVE_Y	.\include\rlgl.h	/^    RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2,   \/\/ Framebuffer texture attachment type: cubemap, +Y side$/;"	e	enum:__anon31
RL_ATTACHMENT_CUBEMAP_POSITIVE_Z	.\include\rlgl.h	/^    RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4,   \/\/ Framebuffer texture attachment type: cubemap, +Z side$/;"	e	enum:__anon31
RL_ATTACHMENT_DEPTH	.\include\rlgl.h	/^    RL_ATTACHMENT_DEPTH = 100,              \/\/ Framebuffer attachment type: depth$/;"	e	enum:__anon30
RL_ATTACHMENT_RENDERBUFFER	.\include\rlgl.h	/^    RL_ATTACHMENT_RENDERBUFFER = 200,       \/\/ Framebuffer texture attachment type: renderbuffer$/;"	e	enum:__anon31
RL_ATTACHMENT_STENCIL	.\include\rlgl.h	/^    RL_ATTACHMENT_STENCIL = 200,            \/\/ Framebuffer attachment type: stencil$/;"	e	enum:__anon30
RL_ATTACHMENT_TEXTURE2D	.\include\rlgl.h	/^    RL_ATTACHMENT_TEXTURE2D = 100,          \/\/ Framebuffer texture attachment type: texture2d$/;"	e	enum:__anon31
RL_BLEND_ADDITIVE	.\include\rlgl.h	/^    RL_BLEND_ADDITIVE,                  \/\/ Blend textures adding colors$/;"	e	enum:__anon26
RL_BLEND_ADD_COLORS	.\include\rlgl.h	/^    RL_BLEND_ADD_COLORS,                \/\/ Blend textures adding colors (alternative)$/;"	e	enum:__anon26
RL_BLEND_ALPHA	.\include\rlgl.h	/^    RL_BLEND_ALPHA = 0,                 \/\/ Blend textures considering alpha (default)$/;"	e	enum:__anon26
RL_BLEND_ALPHA_PREMULTIPLY	.\include\rlgl.h	/^    RL_BLEND_ALPHA_PREMULTIPLY,         \/\/ Blend premultiplied textures considering alpha$/;"	e	enum:__anon26
RL_BLEND_COLOR	.\include\rlgl.h	319;"	d
RL_BLEND_CUSTOM	.\include\rlgl.h	/^    RL_BLEND_CUSTOM,                    \/\/ Blend textures using custom src\/dst factors (use rlSetBlendFactors())$/;"	e	enum:__anon26
RL_BLEND_CUSTOM_SEPARATE	.\include\rlgl.h	/^    RL_BLEND_CUSTOM_SEPARATE            \/\/ Blend textures using custom src\/dst factors (use rlSetBlendFactorsSeparate())$/;"	e	enum:__anon26
RL_BLEND_DST_ALPHA	.\include\rlgl.h	317;"	d
RL_BLEND_DST_RGB	.\include\rlgl.h	315;"	d
RL_BLEND_EQUATION	.\include\rlgl.h	312;"	d
RL_BLEND_EQUATION_ALPHA	.\include\rlgl.h	314;"	d
RL_BLEND_EQUATION_RGB	.\include\rlgl.h	313;"	d
RL_BLEND_MULTIPLIED	.\include\rlgl.h	/^    RL_BLEND_MULTIPLIED,                \/\/ Blend textures multiplying colors$/;"	e	enum:__anon26
RL_BLEND_SRC_ALPHA	.\include\rlgl.h	318;"	d
RL_BLEND_SRC_RGB	.\include\rlgl.h	316;"	d
RL_BLEND_SUBTRACT_COLORS	.\include\rlgl.h	/^    RL_BLEND_SUBTRACT_COLORS,           \/\/ Blend textures subtracting colors (alternative)$/;"	e	enum:__anon26
RL_BOOL_TYPE	.\include\raylib.h	200;"	d
RL_CALLOC	.\include\raylib.h	125;"	d
RL_CALLOC	.\include\rlgl.h	138;"	d
RL_COLOR_TYPE	.\include\raylib.h	154;"	d
RL_COMPUTE_SHADER	.\include\rlgl.h	287;"	d
RL_CONSTANT_ALPHA	.\include\rlgl.h	303;"	d
RL_CONSTANT_COLOR	.\include\rlgl.h	301;"	d
RL_CULL_DISTANCE_FAR	.\include\rlgl.h	236;"	d
RL_CULL_DISTANCE_NEAR	.\include\rlgl.h	233;"	d
RL_CULL_FACE_BACK	.\include\rlgl.h	/^    RL_CULL_FACE_BACK$/;"	e	enum:__anon32
RL_CULL_FACE_FRONT	.\include\rlgl.h	/^    RL_CULL_FACE_FRONT = 0,$/;"	e	enum:__anon32
RL_DEFAULT_BATCH_BUFFERS	.\include\rlgl.h	212;"	d
RL_DEFAULT_BATCH_BUFFER_ELEMENTS	.\include\rlgl.h	202;"	d
RL_DEFAULT_BATCH_BUFFER_ELEMENTS	.\include\rlgl.h	208;"	d
RL_DEFAULT_BATCH_DRAWCALLS	.\include\rlgl.h	215;"	d
RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS	.\include\rlgl.h	218;"	d
RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR	.\include\rlgl.h	924;"	d
RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL	.\include\rlgl.h	921;"	d
RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION	.\include\rlgl.h	915;"	d
RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT	.\include\rlgl.h	927;"	d
RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD	.\include\rlgl.h	918;"	d
RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2	.\include\rlgl.h	930;"	d
RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0	.\include\rlgl.h	952;"	d
RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1	.\include\rlgl.h	955;"	d
RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2	.\include\rlgl.h	958;"	d
RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR	.\include\rlgl.h	949;"	d
RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL	.\include\rlgl.h	943;"	d
RL_DEFAULT_SHADER_UNIFORM_NAME_MVP	.\include\rlgl.h	934;"	d
RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL	.\include\rlgl.h	946;"	d
RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION	.\include\rlgl.h	940;"	d
RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW	.\include\rlgl.h	937;"	d
RL_DST_ALPHA	.\include\rlgl.h	296;"	d
RL_DST_COLOR	.\include\rlgl.h	298;"	d
RL_DYNAMIC_COPY	.\include\rlgl.h	282;"	d
RL_DYNAMIC_DRAW	.\include\rlgl.h	280;"	d
RL_DYNAMIC_READ	.\include\rlgl.h	281;"	d
RL_FLOAT	.\include\rlgl.h	271;"	d
RL_FRAGMENT_SHADER	.\include\rlgl.h	285;"	d
RL_FREE	.\include\raylib.h	131;"	d
RL_FREE	.\include\rlgl.h	144;"	d
RL_FUNC_ADD	.\include\rlgl.h	307;"	d
RL_FUNC_REVERSE_SUBTRACT	.\include\rlgl.h	311;"	d
RL_FUNC_SUBTRACT	.\include\rlgl.h	310;"	d
RL_LINES	.\include\rlgl.h	265;"	d
RL_LOG_ALL	.\include\rlgl.h	/^    RL_LOG_ALL = 0,             \/\/ Display all logs$/;"	e	enum:__anon23
RL_LOG_DEBUG	.\include\rlgl.h	/^    RL_LOG_DEBUG,               \/\/ Debug logging, used for internal debugging, it should be disabled on release builds$/;"	e	enum:__anon23
RL_LOG_ERROR	.\include\rlgl.h	/^    RL_LOG_ERROR,               \/\/ Error logging, used on unrecoverable failures$/;"	e	enum:__anon23
RL_LOG_FATAL	.\include\rlgl.h	/^    RL_LOG_FATAL,               \/\/ Fatal logging, used to abort program: exit(EXIT_FAILURE)$/;"	e	enum:__anon23
RL_LOG_INFO	.\include\rlgl.h	/^    RL_LOG_INFO,                \/\/ Info logging, used for program execution info$/;"	e	enum:__anon23
RL_LOG_NONE	.\include\rlgl.h	/^    RL_LOG_NONE                 \/\/ Disable logging$/;"	e	enum:__anon23
RL_LOG_TRACE	.\include\rlgl.h	/^    RL_LOG_TRACE,               \/\/ Trace logging, intended for internal use only$/;"	e	enum:__anon23
RL_LOG_WARNING	.\include\rlgl.h	/^    RL_LOG_WARNING,             \/\/ Warning logging, used on recoverable failures$/;"	e	enum:__anon23
RL_MALLOC	.\include\raylib.h	122;"	d
RL_MALLOC	.\include\rlgl.h	135;"	d
RL_MATRIX_TYPE	.\include\raylib.h	160;"	d
RL_MATRIX_TYPE	.\include\raymath.h	154;"	d
RL_MATRIX_TYPE	.\include\rlgl.h	340;"	d
RL_MAX	.\include\rlgl.h	309;"	d
RL_MAX_MATRIX_STACK_SIZE	.\include\rlgl.h	223;"	d
RL_MAX_SHADER_LOCATIONS	.\include\rlgl.h	228;"	d
RL_MIN	.\include\rlgl.h	308;"	d
RL_MODELVIEW	.\include\rlgl.h	260;"	d
RL_ONE	.\include\rlgl.h	291;"	d
RL_ONE_MINUS_CONSTANT_ALPHA	.\include\rlgl.h	304;"	d
RL_ONE_MINUS_CONSTANT_COLOR	.\include\rlgl.h	302;"	d
RL_ONE_MINUS_DST_ALPHA	.\include\rlgl.h	297;"	d
RL_ONE_MINUS_DST_COLOR	.\include\rlgl.h	299;"	d
RL_ONE_MINUS_SRC_ALPHA	.\include\rlgl.h	295;"	d
RL_ONE_MINUS_SRC_COLOR	.\include\rlgl.h	293;"	d
RL_OPENGL_11	.\include\rlgl.h	/^    RL_OPENGL_11 = 1,           \/\/ OpenGL 1.1$/;"	e	enum:__anon22
RL_OPENGL_21	.\include\rlgl.h	/^    RL_OPENGL_21,               \/\/ OpenGL 2.1 (GLSL 120)$/;"	e	enum:__anon22
RL_OPENGL_33	.\include\rlgl.h	/^    RL_OPENGL_33,               \/\/ OpenGL 3.3 (GLSL 330)$/;"	e	enum:__anon22
RL_OPENGL_43	.\include\rlgl.h	/^    RL_OPENGL_43,               \/\/ OpenGL 4.3 (using GLSL 330)$/;"	e	enum:__anon22
RL_OPENGL_ES_20	.\include\rlgl.h	/^    RL_OPENGL_ES_20,            \/\/ OpenGL ES 2.0 (GLSL 100)$/;"	e	enum:__anon22
RL_OPENGL_ES_30	.\include\rlgl.h	/^    RL_OPENGL_ES_30             \/\/ OpenGL ES 3.0 (GLSL 300 es)$/;"	e	enum:__anon22
RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA,       \/\/ 8 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA        \/\/ 2 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_DXT1_RGB	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_DXT1_RGB,            \/\/ 4 bpp (no alpha)$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA,           \/\/ 4 bpp (1 bit alpha)$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA,           \/\/ 8 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA,           \/\/ 8 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_ETC1_RGB	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_ETC1_RGB,            \/\/ 4 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA,       \/\/ 8 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_ETC2_RGB	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_ETC2_RGB,            \/\/ 4 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_PVRT_RGB	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_PVRT_RGB,            \/\/ 4 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA	.\include\rlgl.h	/^    RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA,           \/\/ 4 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,     \/\/ 8 bit per pixel (no alpha)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA,        \/\/ 8*2 bpp (2 channels)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R16	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R16,               \/\/ 16 bpp (1 channel - half float)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16,         \/\/ 16*3 bpp (3 channels - half float)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16,      \/\/ 16*4 bpp (4 channels - half float)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R32	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R32,               \/\/ 32 bpp (1 channel - float)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32,         \/\/ 32*3 bpp (3 channels - float)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32,      \/\/ 32*4 bpp (4 channels - float)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4,          \/\/ 16 bpp (4 bit alpha)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1,          \/\/ 16 bpp (1 bit alpha)$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5,            \/\/ 16 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8,            \/\/ 24 bpp$/;"	e	enum:__anon24
RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8	.\include\rlgl.h	/^    RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8,          \/\/ 32 bpp$/;"	e	enum:__anon24
RL_PROJECTION	.\include\rlgl.h	261;"	d
RL_QUADS	.\include\rlgl.h	267;"	d
RL_QUATERNION_TYPE	.\include\raylib.h	159;"	d
RL_QUATERNION_TYPE	.\include\raymath.h	143;"	d
RL_REALLOC	.\include\raylib.h	128;"	d
RL_REALLOC	.\include\rlgl.h	141;"	d
RL_RECTANGLE_TYPE	.\include\raylib.h	155;"	d
RL_SHADER_ATTRIB_FLOAT	.\include\rlgl.h	/^    RL_SHADER_ATTRIB_FLOAT = 0,         \/\/ Shader attribute type: float$/;"	e	enum:__anon29
RL_SHADER_ATTRIB_VEC2	.\include\rlgl.h	/^    RL_SHADER_ATTRIB_VEC2,              \/\/ Shader attribute type: vec2 (2 float)$/;"	e	enum:__anon29
RL_SHADER_ATTRIB_VEC3	.\include\rlgl.h	/^    RL_SHADER_ATTRIB_VEC3,              \/\/ Shader attribute type: vec3 (3 float)$/;"	e	enum:__anon29
RL_SHADER_ATTRIB_VEC4	.\include\rlgl.h	/^    RL_SHADER_ATTRIB_VEC4               \/\/ Shader attribute type: vec4 (4 float)$/;"	e	enum:__anon29
RL_SHADER_LOC_COLOR_AMBIENT	.\include\rlgl.h	/^    RL_SHADER_LOC_COLOR_AMBIENT,        \/\/ Shader location: vector uniform: ambient color$/;"	e	enum:__anon27
RL_SHADER_LOC_COLOR_DIFFUSE	.\include\rlgl.h	/^    RL_SHADER_LOC_COLOR_DIFFUSE,        \/\/ Shader location: vector uniform: diffuse color$/;"	e	enum:__anon27
RL_SHADER_LOC_COLOR_SPECULAR	.\include\rlgl.h	/^    RL_SHADER_LOC_COLOR_SPECULAR,       \/\/ Shader location: vector uniform: specular color$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_ALBEDO	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_ALBEDO,           \/\/ Shader location: sampler2d texture: albedo (same as: RL_SHADER_LOC_MAP_DIFFUSE)$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_BRDF	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_BRDF              \/\/ Shader location: sampler2d texture: brdf$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_CUBEMAP	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_CUBEMAP,          \/\/ Shader location: samplerCube texture: cubemap$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_DIFFUSE	.\include\rlgl.h	493;"	d
RL_SHADER_LOC_MAP_EMISSION	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_EMISSION,         \/\/ Shader location: sampler2d texture: emission$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_HEIGHT	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_HEIGHT,           \/\/ Shader location: sampler2d texture: height$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_IRRADIANCE	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_IRRADIANCE,       \/\/ Shader location: samplerCube texture: irradiance$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_METALNESS	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_METALNESS,        \/\/ Shader location: sampler2d texture: metalness (same as: RL_SHADER_LOC_MAP_SPECULAR)$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_NORMAL	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_NORMAL,           \/\/ Shader location: sampler2d texture: normal$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_OCCLUSION	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_OCCLUSION,        \/\/ Shader location: sampler2d texture: occlusion$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_PREFILTER	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_PREFILTER,        \/\/ Shader location: samplerCube texture: prefilter$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_ROUGHNESS	.\include\rlgl.h	/^    RL_SHADER_LOC_MAP_ROUGHNESS,        \/\/ Shader location: sampler2d texture: roughness$/;"	e	enum:__anon27
RL_SHADER_LOC_MAP_SPECULAR	.\include\rlgl.h	494;"	d
RL_SHADER_LOC_MATRIX_MODEL	.\include\rlgl.h	/^    RL_SHADER_LOC_MATRIX_MODEL,         \/\/ Shader location: matrix uniform: model (transform)$/;"	e	enum:__anon27
RL_SHADER_LOC_MATRIX_MVP	.\include\rlgl.h	/^    RL_SHADER_LOC_MATRIX_MVP,           \/\/ Shader location: matrix uniform: model-view-projection$/;"	e	enum:__anon27
RL_SHADER_LOC_MATRIX_NORMAL	.\include\rlgl.h	/^    RL_SHADER_LOC_MATRIX_NORMAL,        \/\/ Shader location: matrix uniform: normal$/;"	e	enum:__anon27
RL_SHADER_LOC_MATRIX_PROJECTION	.\include\rlgl.h	/^    RL_SHADER_LOC_MATRIX_PROJECTION,    \/\/ Shader location: matrix uniform: projection$/;"	e	enum:__anon27
RL_SHADER_LOC_MATRIX_VIEW	.\include\rlgl.h	/^    RL_SHADER_LOC_MATRIX_VIEW,          \/\/ Shader location: matrix uniform: view (camera transform)$/;"	e	enum:__anon27
RL_SHADER_LOC_VECTOR_VIEW	.\include\rlgl.h	/^    RL_SHADER_LOC_VECTOR_VIEW,          \/\/ Shader location: vector uniform: view$/;"	e	enum:__anon27
RL_SHADER_LOC_VERTEX_COLOR	.\include\rlgl.h	/^    RL_SHADER_LOC_VERTEX_COLOR,         \/\/ Shader location: vertex attribute: color$/;"	e	enum:__anon27
RL_SHADER_LOC_VERTEX_NORMAL	.\include\rlgl.h	/^    RL_SHADER_LOC_VERTEX_NORMAL,        \/\/ Shader location: vertex attribute: normal$/;"	e	enum:__anon27
RL_SHADER_LOC_VERTEX_POSITION	.\include\rlgl.h	/^    RL_SHADER_LOC_VERTEX_POSITION = 0,  \/\/ Shader location: vertex attribute: position$/;"	e	enum:__anon27
RL_SHADER_LOC_VERTEX_TANGENT	.\include\rlgl.h	/^    RL_SHADER_LOC_VERTEX_TANGENT,       \/\/ Shader location: vertex attribute: tangent$/;"	e	enum:__anon27
RL_SHADER_LOC_VERTEX_TEXCOORD01	.\include\rlgl.h	/^    RL_SHADER_LOC_VERTEX_TEXCOORD01,    \/\/ Shader location: vertex attribute: texcoord01$/;"	e	enum:__anon27
RL_SHADER_LOC_VERTEX_TEXCOORD02	.\include\rlgl.h	/^    RL_SHADER_LOC_VERTEX_TEXCOORD02,    \/\/ Shader location: vertex attribute: texcoord02$/;"	e	enum:__anon27
RL_SHADER_UNIFORM_FLOAT	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_FLOAT = 0,        \/\/ Shader uniform type: float$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_INT	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_INT,              \/\/ Shader uniform type: int$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_IVEC2	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_IVEC2,            \/\/ Shader uniform type: ivec2 (2 int)$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_IVEC3	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_IVEC3,            \/\/ Shader uniform type: ivec3 (3 int)$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_IVEC4	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_IVEC4,            \/\/ Shader uniform type: ivec4 (4 int)$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_SAMPLER2D	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_SAMPLER2D         \/\/ Shader uniform type: sampler2d$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_VEC2	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_VEC2,             \/\/ Shader uniform type: vec2 (2 float)$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_VEC3	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_VEC3,             \/\/ Shader uniform type: vec3 (3 float)$/;"	e	enum:__anon28
RL_SHADER_UNIFORM_VEC4	.\include\rlgl.h	/^    RL_SHADER_UNIFORM_VEC4,             \/\/ Shader uniform type: vec4 (4 float)$/;"	e	enum:__anon28
RL_SRC_ALPHA	.\include\rlgl.h	294;"	d
RL_SRC_ALPHA_SATURATE	.\include\rlgl.h	300;"	d
RL_SRC_COLOR	.\include\rlgl.h	292;"	d
RL_STATIC_COPY	.\include\rlgl.h	279;"	d
RL_STATIC_DRAW	.\include\rlgl.h	277;"	d
RL_STATIC_READ	.\include\rlgl.h	278;"	d
RL_STREAM_COPY	.\include\rlgl.h	276;"	d
RL_STREAM_DRAW	.\include\rlgl.h	274;"	d
RL_STREAM_READ	.\include\rlgl.h	275;"	d
RL_TEXTURE	.\include\rlgl.h	262;"	d
RL_TEXTURE_FILTER_ANISOTROPIC	.\include\rlgl.h	251;"	d
RL_TEXTURE_FILTER_ANISOTROPIC_16X	.\include\rlgl.h	/^    RL_TEXTURE_FILTER_ANISOTROPIC_16X,  \/\/ Anisotropic filtering 16x$/;"	e	enum:__anon25
RL_TEXTURE_FILTER_ANISOTROPIC_4X	.\include\rlgl.h	/^    RL_TEXTURE_FILTER_ANISOTROPIC_4X,   \/\/ Anisotropic filtering 4x$/;"	e	enum:__anon25
RL_TEXTURE_FILTER_ANISOTROPIC_8X	.\include\rlgl.h	/^    RL_TEXTURE_FILTER_ANISOTROPIC_8X,   \/\/ Anisotropic filtering 8x$/;"	e	enum:__anon25
RL_TEXTURE_FILTER_BILINEAR	.\include\rlgl.h	/^    RL_TEXTURE_FILTER_BILINEAR,         \/\/ Linear filtering$/;"	e	enum:__anon25
RL_TEXTURE_FILTER_LINEAR	.\include\rlgl.h	246;"	d
RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST	.\include\rlgl.h	249;"	d
RL_TEXTURE_FILTER_MIP_LINEAR	.\include\rlgl.h	250;"	d
RL_TEXTURE_FILTER_MIP_NEAREST	.\include\rlgl.h	247;"	d
RL_TEXTURE_FILTER_NEAREST	.\include\rlgl.h	245;"	d
RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR	.\include\rlgl.h	248;"	d
RL_TEXTURE_FILTER_POINT	.\include\rlgl.h	/^    RL_TEXTURE_FILTER_POINT = 0,        \/\/ No filter, just pixel approximation$/;"	e	enum:__anon25
RL_TEXTURE_FILTER_TRILINEAR	.\include\rlgl.h	/^    RL_TEXTURE_FILTER_TRILINEAR,        \/\/ Trilinear filtering (linear with mipmaps)$/;"	e	enum:__anon25
RL_TEXTURE_MAG_FILTER	.\include\rlgl.h	242;"	d
RL_TEXTURE_MIN_FILTER	.\include\rlgl.h	243;"	d
RL_TEXTURE_MIPMAP_BIAS_RATIO	.\include\rlgl.h	252;"	d
RL_TEXTURE_WRAP_CLAMP	.\include\rlgl.h	255;"	d
RL_TEXTURE_WRAP_MIRROR_CLAMP	.\include\rlgl.h	257;"	d
RL_TEXTURE_WRAP_MIRROR_REPEAT	.\include\rlgl.h	256;"	d
RL_TEXTURE_WRAP_REPEAT	.\include\rlgl.h	254;"	d
RL_TEXTURE_WRAP_S	.\include\rlgl.h	240;"	d
RL_TEXTURE_WRAP_T	.\include\rlgl.h	241;"	d
RL_TRIANGLES	.\include\rlgl.h	266;"	d
RL_UNSIGNED_BYTE	.\include\rlgl.h	270;"	d
RL_VECTOR2_TYPE	.\include\raylib.h	156;"	d
RL_VECTOR2_TYPE	.\include\raymath.h	116;"	d
RL_VECTOR3_TYPE	.\include\raylib.h	157;"	d
RL_VECTOR3_TYPE	.\include\raymath.h	126;"	d
RL_VECTOR4_TYPE	.\include\raylib.h	158;"	d
RL_VECTOR4_TYPE	.\include\raymath.h	137;"	d
RL_VERTEX_SHADER	.\include\rlgl.h	286;"	d
RL_ZERO	.\include\rlgl.h	290;"	d
RMAPI	.\include\raymath.h	62;"	d
RMAPI	.\include\raymath.h	64;"	d
RMAPI	.\include\raymath.h	66;"	d
RMAPI	.\include\raymath.h	69;"	d
RMAPI	.\include\raymath.h	72;"	d
RMAPI	.\include\raymath.h	74;"	d
Ray	.\include\raylib.h	/^typedef struct Ray {$/;"	s
Ray	.\include\raylib.h	/^} Ray;$/;"	t	typeref:struct:Ray
RayCollision	.\include\raylib.h	/^typedef struct RayCollision {$/;"	s
RayCollision	.\include\raylib.h	/^} RayCollision;$/;"	t	typeref:struct:RayCollision
Rectangle	.\include\raylib.h	/^typedef struct Rectangle {$/;"	s
Rectangle	.\include\raylib.h	/^} Rectangle;$/;"	t	typeref:struct:Rectangle
Remap	.\include\raymath.h	/^RMAPI float Remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd)$/;"	f
RenderTexture	.\include\raylib.h	/^typedef struct RenderTexture {$/;"	s
RenderTexture	.\include\raylib.h	/^} RenderTexture;$/;"	t	typeref:struct:RenderTexture
RenderTexture2D	.\include\raylib.h	/^typedef RenderTexture RenderTexture2D;$/;"	t
RestoreWindow	.\include\raylib.h	/^RLAPI void RestoreWindow(void);                                   \/\/ Set window state: not minimized\/maximized (only PLATFORM_DESKTOP)$/;"	p
ResumeAudioStream	.\include\raylib.h	/^RLAPI void ResumeAudioStream(AudioStream stream);                     \/\/ Resume audio stream$/;"	p
ResumeMusicStream	.\include\raylib.h	/^RLAPI void ResumeMusicStream(Music music);                            \/\/ Resume playing paused music$/;"	p
ResumeSound	.\include\raylib.h	/^RLAPI void ResumeSound(Sound sound);                                  \/\/ Resume a paused sound$/;"	p
SHADER_ATTRIB_FLOAT	.\include\raylib.h	/^    SHADER_ATTRIB_FLOAT = 0,        \/\/ Shader attribute type: float$/;"	e	enum:__anon11
SHADER_ATTRIB_VEC2	.\include\raylib.h	/^    SHADER_ATTRIB_VEC2,             \/\/ Shader attribute type: vec2 (2 float)$/;"	e	enum:__anon11
SHADER_ATTRIB_VEC3	.\include\raylib.h	/^    SHADER_ATTRIB_VEC3,             \/\/ Shader attribute type: vec3 (3 float)$/;"	e	enum:__anon11
SHADER_ATTRIB_VEC4	.\include\raylib.h	/^    SHADER_ATTRIB_VEC4              \/\/ Shader attribute type: vec4 (4 float)$/;"	e	enum:__anon11
SHADER_LOC_COLOR_AMBIENT	.\include\raylib.h	/^    SHADER_LOC_COLOR_AMBIENT,       \/\/ Shader location: vector uniform: ambient color$/;"	e	enum:__anon9
SHADER_LOC_COLOR_DIFFUSE	.\include\raylib.h	/^    SHADER_LOC_COLOR_DIFFUSE,       \/\/ Shader location: vector uniform: diffuse color$/;"	e	enum:__anon9
SHADER_LOC_COLOR_SPECULAR	.\include\raylib.h	/^    SHADER_LOC_COLOR_SPECULAR,      \/\/ Shader location: vector uniform: specular color$/;"	e	enum:__anon9
SHADER_LOC_MAP_ALBEDO	.\include\raylib.h	/^    SHADER_LOC_MAP_ALBEDO,          \/\/ Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)$/;"	e	enum:__anon9
SHADER_LOC_MAP_BRDF	.\include\raylib.h	/^    SHADER_LOC_MAP_BRDF             \/\/ Shader location: sampler2d texture: brdf$/;"	e	enum:__anon9
SHADER_LOC_MAP_CUBEMAP	.\include\raylib.h	/^    SHADER_LOC_MAP_CUBEMAP,         \/\/ Shader location: samplerCube texture: cubemap$/;"	e	enum:__anon9
SHADER_LOC_MAP_DIFFUSE	.\include\raylib.h	792;"	d
SHADER_LOC_MAP_EMISSION	.\include\raylib.h	/^    SHADER_LOC_MAP_EMISSION,        \/\/ Shader location: sampler2d texture: emission$/;"	e	enum:__anon9
SHADER_LOC_MAP_HEIGHT	.\include\raylib.h	/^    SHADER_LOC_MAP_HEIGHT,          \/\/ Shader location: sampler2d texture: height$/;"	e	enum:__anon9
SHADER_LOC_MAP_IRRADIANCE	.\include\raylib.h	/^    SHADER_LOC_MAP_IRRADIANCE,      \/\/ Shader location: samplerCube texture: irradiance$/;"	e	enum:__anon9
SHADER_LOC_MAP_METALNESS	.\include\raylib.h	/^    SHADER_LOC_MAP_METALNESS,       \/\/ Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)$/;"	e	enum:__anon9
SHADER_LOC_MAP_NORMAL	.\include\raylib.h	/^    SHADER_LOC_MAP_NORMAL,          \/\/ Shader location: sampler2d texture: normal$/;"	e	enum:__anon9
SHADER_LOC_MAP_OCCLUSION	.\include\raylib.h	/^    SHADER_LOC_MAP_OCCLUSION,       \/\/ Shader location: sampler2d texture: occlusion$/;"	e	enum:__anon9
SHADER_LOC_MAP_PREFILTER	.\include\raylib.h	/^    SHADER_LOC_MAP_PREFILTER,       \/\/ Shader location: samplerCube texture: prefilter$/;"	e	enum:__anon9
SHADER_LOC_MAP_ROUGHNESS	.\include\raylib.h	/^    SHADER_LOC_MAP_ROUGHNESS,       \/\/ Shader location: sampler2d texture: roughness$/;"	e	enum:__anon9
SHADER_LOC_MAP_SPECULAR	.\include\raylib.h	793;"	d
SHADER_LOC_MATRIX_MODEL	.\include\raylib.h	/^    SHADER_LOC_MATRIX_MODEL,        \/\/ Shader location: matrix uniform: model (transform)$/;"	e	enum:__anon9
SHADER_LOC_MATRIX_MVP	.\include\raylib.h	/^    SHADER_LOC_MATRIX_MVP,          \/\/ Shader location: matrix uniform: model-view-projection$/;"	e	enum:__anon9
SHADER_LOC_MATRIX_NORMAL	.\include\raylib.h	/^    SHADER_LOC_MATRIX_NORMAL,       \/\/ Shader location: matrix uniform: normal$/;"	e	enum:__anon9
SHADER_LOC_MATRIX_PROJECTION	.\include\raylib.h	/^    SHADER_LOC_MATRIX_PROJECTION,   \/\/ Shader location: matrix uniform: projection$/;"	e	enum:__anon9
SHADER_LOC_MATRIX_VIEW	.\include\raylib.h	/^    SHADER_LOC_MATRIX_VIEW,         \/\/ Shader location: matrix uniform: view (camera transform)$/;"	e	enum:__anon9
SHADER_LOC_VECTOR_VIEW	.\include\raylib.h	/^    SHADER_LOC_VECTOR_VIEW,         \/\/ Shader location: vector uniform: view$/;"	e	enum:__anon9
SHADER_LOC_VERTEX_COLOR	.\include\raylib.h	/^    SHADER_LOC_VERTEX_COLOR,        \/\/ Shader location: vertex attribute: color$/;"	e	enum:__anon9
SHADER_LOC_VERTEX_NORMAL	.\include\raylib.h	/^    SHADER_LOC_VERTEX_NORMAL,       \/\/ Shader location: vertex attribute: normal$/;"	e	enum:__anon9
SHADER_LOC_VERTEX_POSITION	.\include\raylib.h	/^    SHADER_LOC_VERTEX_POSITION = 0, \/\/ Shader location: vertex attribute: position$/;"	e	enum:__anon9
SHADER_LOC_VERTEX_TANGENT	.\include\raylib.h	/^    SHADER_LOC_VERTEX_TANGENT,      \/\/ Shader location: vertex attribute: tangent$/;"	e	enum:__anon9
SHADER_LOC_VERTEX_TEXCOORD01	.\include\raylib.h	/^    SHADER_LOC_VERTEX_TEXCOORD01,   \/\/ Shader location: vertex attribute: texcoord01$/;"	e	enum:__anon9
SHADER_LOC_VERTEX_TEXCOORD02	.\include\raylib.h	/^    SHADER_LOC_VERTEX_TEXCOORD02,   \/\/ Shader location: vertex attribute: texcoord02$/;"	e	enum:__anon9
SHADER_UNIFORM_FLOAT	.\include\raylib.h	/^    SHADER_UNIFORM_FLOAT = 0,       \/\/ Shader uniform type: float$/;"	e	enum:__anon10
SHADER_UNIFORM_INT	.\include\raylib.h	/^    SHADER_UNIFORM_INT,             \/\/ Shader uniform type: int$/;"	e	enum:__anon10
SHADER_UNIFORM_IVEC2	.\include\raylib.h	/^    SHADER_UNIFORM_IVEC2,           \/\/ Shader uniform type: ivec2 (2 int)$/;"	e	enum:__anon10
SHADER_UNIFORM_IVEC3	.\include\raylib.h	/^    SHADER_UNIFORM_IVEC3,           \/\/ Shader uniform type: ivec3 (3 int)$/;"	e	enum:__anon10
SHADER_UNIFORM_IVEC4	.\include\raylib.h	/^    SHADER_UNIFORM_IVEC4,           \/\/ Shader uniform type: ivec4 (4 int)$/;"	e	enum:__anon10
SHADER_UNIFORM_SAMPLER2D	.\include\raylib.h	/^    SHADER_UNIFORM_SAMPLER2D        \/\/ Shader uniform type: sampler2d$/;"	e	enum:__anon10
SHADER_UNIFORM_VEC2	.\include\raylib.h	/^    SHADER_UNIFORM_VEC2,            \/\/ Shader uniform type: vec2 (2 float)$/;"	e	enum:__anon10
SHADER_UNIFORM_VEC3	.\include\raylib.h	/^    SHADER_UNIFORM_VEC3,            \/\/ Shader uniform type: vec3 (3 float)$/;"	e	enum:__anon10
SHADER_UNIFORM_VEC4	.\include\raylib.h	/^    SHADER_UNIFORM_VEC4,            \/\/ Shader uniform type: vec4 (4 float)$/;"	e	enum:__anon10
SKYBLUE	.\include\raylib.h	176;"	d
SaveFileData	.\include\raylib.h	/^RLAPI bool SaveFileData(const char *fileName, void *data, int dataSize); \/\/ Save data to file from byte array (write), returns true on success$/;"	p
SaveFileDataCallback	.\include\raylib.h	/^typedef bool (*SaveFileDataCallback)(const char *fileName, void *data, int dataSize);   \/\/ FileIO: Save binary data$/;"	t
SaveFileText	.\include\raylib.h	/^RLAPI bool SaveFileText(const char *fileName, char *text);        \/\/ Save text data to file (write), string must be '\\0' terminated, returns true on success$/;"	p
SaveFileTextCallback	.\include\raylib.h	/^typedef bool (*SaveFileTextCallback)(const char *fileName, char *text); \/\/ FileIO: Save text data$/;"	t
SeekMusicStream	.\include\raylib.h	/^RLAPI void SeekMusicStream(Music music, float position);              \/\/ Seek music to a position (in seconds)$/;"	p
SetAudioStreamBufferSizeDefault	.\include\raylib.h	/^RLAPI void SetAudioStreamBufferSizeDefault(int size);                 \/\/ Default size for new audio streams$/;"	p
SetAudioStreamCallback	.\include\raylib.h	/^RLAPI void SetAudioStreamCallback(AudioStream stream, AudioCallback callback); \/\/ Audio thread callback to request new data$/;"	p
SetAudioStreamPan	.\include\raylib.h	/^RLAPI void SetAudioStreamPan(AudioStream stream, float pan);          \/\/ Set pan for audio stream (0.5 is centered)$/;"	p
SetAudioStreamPitch	.\include\raylib.h	/^RLAPI void SetAudioStreamPitch(AudioStream stream, float pitch);      \/\/ Set pitch for audio stream (1.0 is base level)$/;"	p
SetAudioStreamVolume	.\include\raylib.h	/^RLAPI void SetAudioStreamVolume(AudioStream stream, float volume);    \/\/ Set volume for audio stream (1.0 is max level)$/;"	p
SetAutomationEventBaseFrame	.\include\raylib.h	/^RLAPI void SetAutomationEventBaseFrame(int frame);                                      \/\/ Set automation event internal base frame to start recording$/;"	p
SetAutomationEventList	.\include\raylib.h	/^RLAPI void SetAutomationEventList(AutomationEventList *list);                           \/\/ Set automation event list to record to$/;"	p
SetClipboardText	.\include\raylib.h	/^RLAPI void SetClipboardText(const char *text);                    \/\/ Set clipboard text content$/;"	p
SetConfigFlags	.\include\raylib.h	/^RLAPI void SetConfigFlags(unsigned int flags);                    \/\/ Setup init configuration flags (view FLAGS)$/;"	p
SetExitKey	.\include\raylib.h	/^RLAPI void SetExitKey(int key);                               \/\/ Set a custom key to exit program (default is ESC)$/;"	p
SetGamepadMappings	.\include\raylib.h	/^RLAPI int SetGamepadMappings(const char *mappings);           \/\/ Set internal gamepad mappings (SDL_GameControllerDB)$/;"	p
SetGesturesEnabled	.\include\raylib.h	/^RLAPI void SetGesturesEnabled(unsigned int flags);      \/\/ Enable a set of gestures using flags$/;"	p
SetLoadFileDataCallback	.\include\raylib.h	/^RLAPI void SetLoadFileDataCallback(LoadFileDataCallback callback); \/\/ Set custom file binary data loader$/;"	p
SetLoadFileTextCallback	.\include\raylib.h	/^RLAPI void SetLoadFileTextCallback(LoadFileTextCallback callback); \/\/ Set custom file text data loader$/;"	p
SetMasterVolume	.\include\raylib.h	/^RLAPI void SetMasterVolume(float volume);                             \/\/ Set master volume (listener)$/;"	p
SetMaterialTexture	.\include\raylib.h	/^RLAPI void SetMaterialTexture(Material *material, int mapType, Texture2D texture);          \/\/ Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)$/;"	p
SetModelMeshMaterial	.\include\raylib.h	/^RLAPI void SetModelMeshMaterial(Model *model, int meshId, int materialId);                  \/\/ Set material for a mesh$/;"	p
SetMouseCursor	.\include\raylib.h	/^RLAPI void SetMouseCursor(int cursor);                        \/\/ Set mouse cursor$/;"	p
SetMouseOffset	.\include\raylib.h	/^RLAPI void SetMouseOffset(int offsetX, int offsetY);          \/\/ Set mouse offset$/;"	p
SetMousePosition	.\include\raylib.h	/^RLAPI void SetMousePosition(int x, int y);                    \/\/ Set mouse position XY$/;"	p
SetMouseScale	.\include\raylib.h	/^RLAPI void SetMouseScale(float scaleX, float scaleY);         \/\/ Set mouse scaling$/;"	p
SetMusicPan	.\include\raylib.h	/^RLAPI void SetMusicPan(Music music, float pan);                       \/\/ Set pan for a music (0.5 is center)$/;"	p
SetMusicPitch	.\include\raylib.h	/^RLAPI void SetMusicPitch(Music music, float pitch);                   \/\/ Set pitch for a music (1.0 is base level)$/;"	p
SetMusicVolume	.\include\raylib.h	/^RLAPI void SetMusicVolume(Music music, float volume);                 \/\/ Set volume for music (1.0 is max level)$/;"	p
SetPixelColor	.\include\raylib.h	/^RLAPI void SetPixelColor(void *dstPtr, Color color, int format);            \/\/ Set color formatted into destination pixel pointer$/;"	p
SetRandomSeed	.\include\raylib.h	/^RLAPI void SetRandomSeed(unsigned int seed);                      \/\/ Set the seed for the random number generator$/;"	p
SetSaveFileDataCallback	.\include\raylib.h	/^RLAPI void SetSaveFileDataCallback(SaveFileDataCallback callback); \/\/ Set custom file binary data saver$/;"	p
SetSaveFileTextCallback	.\include\raylib.h	/^RLAPI void SetSaveFileTextCallback(SaveFileTextCallback callback); \/\/ Set custom file text data saver$/;"	p
SetShaderValue	.\include\raylib.h	/^RLAPI void SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType);               \/\/ Set shader uniform value$/;"	p
SetShaderValueMatrix	.\include\raylib.h	/^RLAPI void SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat);         \/\/ Set shader uniform value (matrix 4x4)$/;"	p
SetShaderValueTexture	.\include\raylib.h	/^RLAPI void SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture); \/\/ Set shader uniform value for texture (sampler2d)$/;"	p
SetShaderValueV	.\include\raylib.h	/^RLAPI void SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count);   \/\/ Set shader uniform value vector$/;"	p
SetShapesTexture	.\include\raylib.h	/^RLAPI void SetShapesTexture(Texture2D texture, Rectangle source);       \/\/ Set texture and rectangle to be used on shapes drawing$/;"	p
SetSoundPan	.\include\raylib.h	/^RLAPI void SetSoundPan(Sound sound, float pan);                       \/\/ Set pan for a sound (0.5 is center)$/;"	p
SetSoundPitch	.\include\raylib.h	/^RLAPI void SetSoundPitch(Sound sound, float pitch);                   \/\/ Set pitch for a sound (1.0 is base level)$/;"	p
SetSoundVolume	.\include\raylib.h	/^RLAPI void SetSoundVolume(Sound sound, float volume);                 \/\/ Set volume for a sound (1.0 is max level)$/;"	p
SetTargetFPS	.\include\raylib.h	/^RLAPI void SetTargetFPS(int fps);                                 \/\/ Set target FPS (maximum)$/;"	p
SetTextLineSpacing	.\include\raylib.h	/^RLAPI void SetTextLineSpacing(int spacing);                                                 \/\/ Set vertical line spacing when drawing with line-breaks$/;"	p
SetTextureFilter	.\include\raylib.h	/^RLAPI void SetTextureFilter(Texture2D texture, int filter);                                              \/\/ Set texture scaling filter mode$/;"	p
SetTextureWrap	.\include\raylib.h	/^RLAPI void SetTextureWrap(Texture2D texture, int wrap);                                                  \/\/ Set texture wrapping mode$/;"	p
SetTraceLogCallback	.\include\raylib.h	/^RLAPI void SetTraceLogCallback(TraceLogCallback callback);         \/\/ Set custom trace log$/;"	p
SetTraceLogLevel	.\include\raylib.h	/^RLAPI void SetTraceLogLevel(int logLevel);                        \/\/ Set the current threshold (minimum) log level$/;"	p
SetWindowFocused	.\include\raylib.h	/^RLAPI void SetWindowFocused(void);                                \/\/ Set window focused (only PLATFORM_DESKTOP)$/;"	p
SetWindowIcon	.\include\raylib.h	/^RLAPI void SetWindowIcon(Image image);                            \/\/ Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)$/;"	p
SetWindowIcons	.\include\raylib.h	/^RLAPI void SetWindowIcons(Image *images, int count);              \/\/ Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)$/;"	p
SetWindowMaxSize	.\include\raylib.h	/^RLAPI void SetWindowMaxSize(int width, int height);               \/\/ Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)$/;"	p
SetWindowMinSize	.\include\raylib.h	/^RLAPI void SetWindowMinSize(int width, int height);               \/\/ Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)$/;"	p
SetWindowMonitor	.\include\raylib.h	/^RLAPI void SetWindowMonitor(int monitor);                         \/\/ Set monitor for the current window$/;"	p
SetWindowOpacity	.\include\raylib.h	/^RLAPI void SetWindowOpacity(float opacity);                       \/\/ Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)$/;"	p
SetWindowPosition	.\include\raylib.h	/^RLAPI void SetWindowPosition(int x, int y);                       \/\/ Set window position on screen (only PLATFORM_DESKTOP)$/;"	p
SetWindowSize	.\include\raylib.h	/^RLAPI void SetWindowSize(int width, int height);                  \/\/ Set window dimensions$/;"	p
SetWindowState	.\include\raylib.h	/^RLAPI void SetWindowState(unsigned int flags);                    \/\/ Set window configuration state using flags (only PLATFORM_DESKTOP)$/;"	p
SetWindowTitle	.\include\raylib.h	/^RLAPI void SetWindowTitle(const char *title);                     \/\/ Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB)$/;"	p
Shader	.\include\raylib.h	/^typedef struct Shader {$/;"	s
Shader	.\include\raylib.h	/^} Shader;$/;"	t	typeref:struct:Shader
ShaderAttributeDataType	.\include\raylib.h	/^} ShaderAttributeDataType;$/;"	t	typeref:enum:__anon11
ShaderLocationIndex	.\include\raylib.h	/^} ShaderLocationIndex;$/;"	t	typeref:enum:__anon9
ShaderUniformDataType	.\include\raylib.h	/^} ShaderUniformDataType;$/;"	t	typeref:enum:__anon10
ShowCursor	.\include\raylib.h	/^RLAPI void ShowCursor(void);                                      \/\/ Shows cursor$/;"	p
Sound	.\include\raylib.h	/^typedef struct Sound {$/;"	s
Sound	.\include\raylib.h	/^} Sound;$/;"	t	typeref:struct:Sound
StartAutomationEventRecording	.\include\raylib.h	/^RLAPI void StartAutomationEventRecording(void);                                         \/\/ Start recording automation events (AutomationEventList must be set)$/;"	p
State	.\include\rlgl.h	/^    } State;            \/\/ Renderer state$/;"	m	struct:rlglData	typeref:struct:rlglData::__anon33
StopAudioStream	.\include\raylib.h	/^RLAPI void StopAudioStream(AudioStream stream);                       \/\/ Stop audio stream$/;"	p
StopAutomationEventRecording	.\include\raylib.h	/^RLAPI void StopAutomationEventRecording(void);                                          \/\/ Stop recording automation events$/;"	p
StopMusicStream	.\include\raylib.h	/^RLAPI void StopMusicStream(Music music);                              \/\/ Stop music playing$/;"	p
StopSound	.\include\raylib.h	/^RLAPI void StopSound(Sound sound);                                    \/\/ Stop playing a sound$/;"	p
SwapScreenBuffer	.\include\raylib.h	/^RLAPI void SwapScreenBuffer(void);                                \/\/ Swap back buffer with front buffer (screen drawing)$/;"	p
TEXTURE_FILTER_ANISOTROPIC_16X	.\include\raylib.h	/^    TEXTURE_FILTER_ANISOTROPIC_16X,         \/\/ Anisotropic filtering 16x$/;"	e	enum:__anon13
TEXTURE_FILTER_ANISOTROPIC_4X	.\include\raylib.h	/^    TEXTURE_FILTER_ANISOTROPIC_4X,          \/\/ Anisotropic filtering 4x$/;"	e	enum:__anon13
TEXTURE_FILTER_ANISOTROPIC_8X	.\include\raylib.h	/^    TEXTURE_FILTER_ANISOTROPIC_8X,          \/\/ Anisotropic filtering 8x$/;"	e	enum:__anon13
TEXTURE_FILTER_BILINEAR	.\include\raylib.h	/^    TEXTURE_FILTER_BILINEAR,                \/\/ Linear filtering$/;"	e	enum:__anon13
TEXTURE_FILTER_POINT	.\include\raylib.h	/^    TEXTURE_FILTER_POINT = 0,               \/\/ No filter, just pixel approximation$/;"	e	enum:__anon13
TEXTURE_FILTER_TRILINEAR	.\include\raylib.h	/^    TEXTURE_FILTER_TRILINEAR,               \/\/ Trilinear filtering (linear with mipmaps)$/;"	e	enum:__anon13
TEXTURE_WRAP_CLAMP	.\include\raylib.h	/^    TEXTURE_WRAP_CLAMP,                     \/\/ Clamps texture to edge pixel in tiled mode$/;"	e	enum:__anon14
TEXTURE_WRAP_MIRROR_CLAMP	.\include\raylib.h	/^    TEXTURE_WRAP_MIRROR_CLAMP               \/\/ Mirrors and clamps to border the texture in tiled mode$/;"	e	enum:__anon14
TEXTURE_WRAP_MIRROR_REPEAT	.\include\raylib.h	/^    TEXTURE_WRAP_MIRROR_REPEAT,             \/\/ Mirrors and repeats the texture in tiled mode$/;"	e	enum:__anon14
TEXTURE_WRAP_REPEAT	.\include\raylib.h	/^    TEXTURE_WRAP_REPEAT = 0,                \/\/ Repeats texture in tiled mode$/;"	e	enum:__anon14
TRACELOG	.\include\rlgl.h	129;"	d
TRACELOGD	.\include\rlgl.h	130;"	d
TakeScreenshot	.\include\raylib.h	/^RLAPI void TakeScreenshot(const char *fileName);                  \/\/ Takes a screenshot of current screen (filename extension defines format)$/;"	p
TextAppend	.\include\raylib.h	/^RLAPI void TextAppend(char *text, const char *append, int *position);                       \/\/ Append text at specific position and move cursor!$/;"	p
TextCopy	.\include\raylib.h	/^RLAPI int TextCopy(char *dst, const char *src);                                             \/\/ Copy one string to another, returns bytes copied$/;"	p
TextFindIndex	.\include\raylib.h	/^RLAPI int TextFindIndex(const char *text, const char *find);                                \/\/ Find first text occurrence within a string$/;"	p
TextFormat	.\include\raylib.h	/^RLAPI const char *TextFormat(const char *text, ...);                                        \/\/ Text formatting with variables (sprintf() style)$/;"	p
TextInsert	.\include\raylib.h	/^RLAPI char *TextInsert(const char *text, const char *insert, int position);                 \/\/ Insert text in a position (WARNING: memory must be freed!)$/;"	p
TextIsEqual	.\include\raylib.h	/^RLAPI bool TextIsEqual(const char *text1, const char *text2);                               \/\/ Check if two text string are equal$/;"	p
TextJoin	.\include\raylib.h	/^RLAPI const char *TextJoin(const char **textList, int count, const char *delimiter);        \/\/ Join text strings with delimiter$/;"	p
TextLength	.\include\raylib.h	/^RLAPI unsigned int TextLength(const char *text);                                            \/\/ Get text length, checks for '\\0' ending$/;"	p
TextReplace	.\include\raylib.h	/^RLAPI char *TextReplace(char *text, const char *replace, const char *by);                   \/\/ Replace text string (WARNING: memory must be freed!)$/;"	p
TextSplit	.\include\raylib.h	/^RLAPI const char **TextSplit(const char *text, char delimiter, int *count);                 \/\/ Split text into multiple strings$/;"	p
TextSubtext	.\include\raylib.h	/^RLAPI const char *TextSubtext(const char *text, int position, int length);                  \/\/ Get a piece of a text string$/;"	p
TextToInteger	.\include\raylib.h	/^RLAPI int TextToInteger(const char *text);                            \/\/ Get integer value from text (negative values not supported)$/;"	p
TextToLower	.\include\raylib.h	/^RLAPI const char *TextToLower(const char *text);                      \/\/ Get lower case version of provided string$/;"	p
TextToPascal	.\include\raylib.h	/^RLAPI const char *TextToPascal(const char *text);                     \/\/ Get Pascal case notation version of provided string$/;"	p
TextToUpper	.\include\raylib.h	/^RLAPI const char *TextToUpper(const char *text);                      \/\/ Get upper case version of provided string$/;"	p
Texture	.\include\raylib.h	/^typedef struct Texture {$/;"	s
Texture	.\include\raylib.h	/^} Texture;$/;"	t	typeref:struct:Texture
Texture2D	.\include\raylib.h	/^typedef Texture Texture2D;$/;"	t
TextureCubemap	.\include\raylib.h	/^typedef Texture TextureCubemap;$/;"	t
TextureFilter	.\include\raylib.h	/^} TextureFilter;$/;"	t	typeref:enum:__anon13
TextureWrap	.\include\raylib.h	/^} TextureWrap;$/;"	t	typeref:enum:__anon14
ToggleBorderlessWindowed	.\include\raylib.h	/^RLAPI void ToggleBorderlessWindowed(void);                        \/\/ Toggle window state: borderless windowed (only PLATFORM_DESKTOP)$/;"	p
ToggleFullscreen	.\include\raylib.h	/^RLAPI void ToggleFullscreen(void);                                \/\/ Toggle window state: fullscreen\/windowed (only PLATFORM_DESKTOP)$/;"	p
TraceLog	.\include\raylib.h	/^RLAPI void TraceLog(int logLevel, const char *text, ...);         \/\/ Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)$/;"	p
TraceLogCallback	.\include\raylib.h	/^typedef void (*TraceLogCallback)(int logLevel, const char *text, va_list args);  \/\/ Logging: Redirect trace log messages$/;"	t
TraceLogLevel	.\include\raylib.h	/^} TraceLogLevel;$/;"	t	typeref:enum:__anon2
Transform	.\include\raylib.h	/^typedef struct Transform {$/;"	s
Transform	.\include\raylib.h	/^} Transform;$/;"	t	typeref:struct:Transform
UnloadAudioStream	.\include\raylib.h	/^RLAPI void UnloadAudioStream(AudioStream stream);                     \/\/ Unload audio stream and free memory$/;"	p
UnloadAutomationEventList	.\include\raylib.h	/^RLAPI void UnloadAutomationEventList(AutomationEventList *list);                        \/\/ Unload automation events list from file$/;"	p
UnloadCodepoints	.\include\raylib.h	/^RLAPI void UnloadCodepoints(int *codepoints);                           \/\/ Unload codepoints data from memory$/;"	p
UnloadDirectoryFiles	.\include\raylib.h	/^RLAPI void UnloadDirectoryFiles(FilePathList files);              \/\/ Unload filepaths$/;"	p
UnloadDroppedFiles	.\include\raylib.h	/^RLAPI void UnloadDroppedFiles(FilePathList files);                \/\/ Unload dropped filepaths$/;"	p
UnloadFileData	.\include\raylib.h	/^RLAPI void UnloadFileData(unsigned char *data);                   \/\/ Unload file data allocated by LoadFileData()$/;"	p
UnloadFileText	.\include\raylib.h	/^RLAPI void UnloadFileText(char *text);                            \/\/ Unload file text data allocated by LoadFileText()$/;"	p
UnloadFont	.\include\raylib.h	/^RLAPI void UnloadFont(Font font);                                                           \/\/ Unload font from GPU memory (VRAM)$/;"	p
UnloadFontData	.\include\raylib.h	/^RLAPI void UnloadFontData(GlyphInfo *glyphs, int glyphCount);                               \/\/ Unload font chars info data (RAM)$/;"	p
UnloadImage	.\include\raylib.h	/^RLAPI void UnloadImage(Image image);                                                                     \/\/ Unload image from CPU memory (RAM)$/;"	p
UnloadImageColors	.\include\raylib.h	/^RLAPI void UnloadImageColors(Color *colors);                                                             \/\/ Unload color data loaded with LoadImageColors()$/;"	p
UnloadImagePalette	.\include\raylib.h	/^RLAPI void UnloadImagePalette(Color *colors);                                                            \/\/ Unload colors palette loaded with LoadImagePalette()$/;"	p
UnloadMaterial	.\include\raylib.h	/^RLAPI void UnloadMaterial(Material material);                                               \/\/ Unload material from GPU memory (VRAM)$/;"	p
UnloadMesh	.\include\raylib.h	/^RLAPI void UnloadMesh(Mesh mesh);                                                           \/\/ Unload mesh data from CPU and GPU$/;"	p
UnloadModel	.\include\raylib.h	/^RLAPI void UnloadModel(Model model);                                                        \/\/ Unload model (including meshes) from memory (RAM and\/or VRAM)$/;"	p
UnloadModelAnimation	.\include\raylib.h	/^RLAPI void UnloadModelAnimation(ModelAnimation anim);                                       \/\/ Unload animation data$/;"	p
UnloadModelAnimations	.\include\raylib.h	/^RLAPI void UnloadModelAnimations(ModelAnimation *animations, int animCount);                \/\/ Unload animation array data$/;"	p
UnloadMusicStream	.\include\raylib.h	/^RLAPI void UnloadMusicStream(Music music);                            \/\/ Unload music stream$/;"	p
UnloadRandomSequence	.\include\raylib.h	/^RLAPI void UnloadRandomSequence(int *sequence);                   \/\/ Unload random values sequence$/;"	p
UnloadRenderTexture	.\include\raylib.h	/^RLAPI void UnloadRenderTexture(RenderTexture2D target);                                                  \/\/ Unload render texture from GPU memory (VRAM)$/;"	p
UnloadShader	.\include\raylib.h	/^RLAPI void UnloadShader(Shader shader);                                    \/\/ Unload shader from GPU memory (VRAM)$/;"	p
UnloadSound	.\include\raylib.h	/^RLAPI void UnloadSound(Sound sound);                                  \/\/ Unload sound$/;"	p
UnloadSoundAlias	.\include\raylib.h	/^RLAPI void UnloadSoundAlias(Sound alias);                             \/\/ Unload a sound alias (does not deallocate sample data)$/;"	p
UnloadTexture	.\include\raylib.h	/^RLAPI void UnloadTexture(Texture2D texture);                                                             \/\/ Unload texture from GPU memory (VRAM)$/;"	p
UnloadUTF8	.\include\raylib.h	/^RLAPI void UnloadUTF8(char *text);                                      \/\/ Unload UTF-8 text encoded from codepoints array$/;"	p
UnloadVrStereoConfig	.\include\raylib.h	/^RLAPI void UnloadVrStereoConfig(VrStereoConfig config);           \/\/ Unload VR stereo config$/;"	p
UnloadWave	.\include\raylib.h	/^RLAPI void UnloadWave(Wave wave);                                     \/\/ Unload wave data$/;"	p
UnloadWaveSamples	.\include\raylib.h	/^RLAPI void UnloadWaveSamples(float *samples);                         \/\/ Unload samples data loaded with LoadWaveSamples()$/;"	p
UpdateAudioStream	.\include\raylib.h	/^RLAPI void UpdateAudioStream(AudioStream stream, const void *data, int frameCount); \/\/ Update audio stream buffers with data$/;"	p
UpdateCamera	.\include\raylib.h	/^RLAPI void UpdateCamera(Camera *camera, int mode);      \/\/ Update camera position for selected mode$/;"	p
UpdateCameraPro	.\include\raylib.h	/^RLAPI void UpdateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom); \/\/ Update camera movement\/rotation$/;"	p
UpdateMeshBuffer	.\include\raylib.h	/^RLAPI void UpdateMeshBuffer(Mesh mesh, int index, const void *data, int dataSize, int offset); \/\/ Update mesh vertex data in GPU for a specific buffer index$/;"	p
UpdateModelAnimation	.\include\raylib.h	/^RLAPI void UpdateModelAnimation(Model model, ModelAnimation anim, int frame);               \/\/ Update model animation pose$/;"	p
UpdateMusicStream	.\include\raylib.h	/^RLAPI void UpdateMusicStream(Music music);                            \/\/ Updates buffers for music streaming$/;"	p
UpdateSound	.\include\raylib.h	/^RLAPI void UpdateSound(Sound sound, const void *data, int sampleCount); \/\/ Update sound buffer with new data$/;"	p
UpdateTexture	.\include\raylib.h	/^RLAPI void UpdateTexture(Texture2D texture, const void *pixels);                                         \/\/ Update GPU texture with new data$/;"	p
UpdateTextureRec	.\include\raylib.h	/^RLAPI void UpdateTextureRec(Texture2D texture, Rectangle rec, const void *pixels);                       \/\/ Update GPU texture rectangle with new data$/;"	p
UploadMesh	.\include\raylib.h	/^RLAPI void UploadMesh(Mesh *mesh, bool dynamic);                                            \/\/ Upload mesh vertex data in GPU and provide VAO\/VBO ids$/;"	p
VIOLET	.\include\raylib.h	180;"	d
Vector2	.\include\raylib.h	/^typedef struct Vector2 {$/;"	s
Vector2	.\include\raylib.h	/^} Vector2;$/;"	t	typeref:struct:Vector2
Vector2	.\include\raymath.h	/^typedef struct Vector2 {$/;"	s
Vector2	.\include\raymath.h	/^} Vector2;$/;"	t	typeref:struct:Vector2
Vector2Add	.\include\raymath.h	/^RMAPI Vector2 Vector2Add(Vector2 v1, Vector2 v2)$/;"	f
Vector2AddValue	.\include\raymath.h	/^RMAPI Vector2 Vector2AddValue(Vector2 v, float add)$/;"	f
Vector2Angle	.\include\raymath.h	/^RMAPI float Vector2Angle(Vector2 v1, Vector2 v2)$/;"	f
Vector2Clamp	.\include\raymath.h	/^RMAPI Vector2 Vector2Clamp(Vector2 v, Vector2 min, Vector2 max)$/;"	f
Vector2ClampValue	.\include\raymath.h	/^RMAPI Vector2 Vector2ClampValue(Vector2 v, float min, float max)$/;"	f
Vector2Distance	.\include\raymath.h	/^RMAPI float Vector2Distance(Vector2 v1, Vector2 v2)$/;"	f
Vector2DistanceSqr	.\include\raymath.h	/^RMAPI float Vector2DistanceSqr(Vector2 v1, Vector2 v2)$/;"	f
Vector2Divide	.\include\raymath.h	/^RMAPI Vector2 Vector2Divide(Vector2 v1, Vector2 v2)$/;"	f
Vector2DotProduct	.\include\raymath.h	/^RMAPI float Vector2DotProduct(Vector2 v1, Vector2 v2)$/;"	f
Vector2Equals	.\include\raymath.h	/^RMAPI int Vector2Equals(Vector2 p, Vector2 q)$/;"	f
Vector2Invert	.\include\raymath.h	/^RMAPI Vector2 Vector2Invert(Vector2 v)$/;"	f
Vector2Length	.\include\raymath.h	/^RMAPI float Vector2Length(Vector2 v)$/;"	f
Vector2LengthSqr	.\include\raymath.h	/^RMAPI float Vector2LengthSqr(Vector2 v)$/;"	f
Vector2Lerp	.\include\raymath.h	/^RMAPI Vector2 Vector2Lerp(Vector2 v1, Vector2 v2, float amount)$/;"	f
Vector2LineAngle	.\include\raymath.h	/^RMAPI float Vector2LineAngle(Vector2 start, Vector2 end)$/;"	f
Vector2MoveTowards	.\include\raymath.h	/^RMAPI Vector2 Vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance)$/;"	f
Vector2Multiply	.\include\raymath.h	/^RMAPI Vector2 Vector2Multiply(Vector2 v1, Vector2 v2)$/;"	f
Vector2Negate	.\include\raymath.h	/^RMAPI Vector2 Vector2Negate(Vector2 v)$/;"	f
Vector2Normalize	.\include\raymath.h	/^RMAPI Vector2 Vector2Normalize(Vector2 v)$/;"	f
Vector2One	.\include\raymath.h	/^RMAPI Vector2 Vector2One(void)$/;"	f
Vector2Reflect	.\include\raymath.h	/^RMAPI Vector2 Vector2Reflect(Vector2 v, Vector2 normal)$/;"	f
Vector2Rotate	.\include\raymath.h	/^RMAPI Vector2 Vector2Rotate(Vector2 v, float angle)$/;"	f
Vector2Scale	.\include\raymath.h	/^RMAPI Vector2 Vector2Scale(Vector2 v, float scale)$/;"	f
Vector2Subtract	.\include\raymath.h	/^RMAPI Vector2 Vector2Subtract(Vector2 v1, Vector2 v2)$/;"	f
Vector2SubtractValue	.\include\raymath.h	/^RMAPI Vector2 Vector2SubtractValue(Vector2 v, float sub)$/;"	f
Vector2Transform	.\include\raymath.h	/^RMAPI Vector2 Vector2Transform(Vector2 v, Matrix mat)$/;"	f
Vector2Zero	.\include\raymath.h	/^RMAPI Vector2 Vector2Zero(void)$/;"	f
Vector3	.\include\raylib.h	/^typedef struct Vector3 {$/;"	s
Vector3	.\include\raylib.h	/^} Vector3;$/;"	t	typeref:struct:Vector3
Vector3	.\include\raymath.h	/^typedef struct Vector3 {$/;"	s
Vector3	.\include\raymath.h	/^} Vector3;$/;"	t	typeref:struct:Vector3
Vector3Add	.\include\raymath.h	/^RMAPI Vector3 Vector3Add(Vector3 v1, Vector3 v2)$/;"	f
Vector3AddValue	.\include\raymath.h	/^RMAPI Vector3 Vector3AddValue(Vector3 v, float add)$/;"	f
Vector3Angle	.\include\raymath.h	/^RMAPI float Vector3Angle(Vector3 v1, Vector3 v2)$/;"	f
Vector3Barycenter	.\include\raymath.h	/^RMAPI Vector3 Vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c)$/;"	f
Vector3Clamp	.\include\raymath.h	/^RMAPI Vector3 Vector3Clamp(Vector3 v, Vector3 min, Vector3 max)$/;"	f
Vector3ClampValue	.\include\raymath.h	/^RMAPI Vector3 Vector3ClampValue(Vector3 v, float min, float max)$/;"	f
Vector3CrossProduct	.\include\raymath.h	/^RMAPI Vector3 Vector3CrossProduct(Vector3 v1, Vector3 v2)$/;"	f
Vector3Distance	.\include\raymath.h	/^RMAPI float Vector3Distance(Vector3 v1, Vector3 v2)$/;"	f
Vector3DistanceSqr	.\include\raymath.h	/^RMAPI float Vector3DistanceSqr(Vector3 v1, Vector3 v2)$/;"	f
Vector3Divide	.\include\raymath.h	/^RMAPI Vector3 Vector3Divide(Vector3 v1, Vector3 v2)$/;"	f
Vector3DotProduct	.\include\raymath.h	/^RMAPI float Vector3DotProduct(Vector3 v1, Vector3 v2)$/;"	f
Vector3Equals	.\include\raymath.h	/^RMAPI int Vector3Equals(Vector3 p, Vector3 q)$/;"	f
Vector3Invert	.\include\raymath.h	/^RMAPI Vector3 Vector3Invert(Vector3 v)$/;"	f
Vector3Length	.\include\raymath.h	/^RMAPI float Vector3Length(const Vector3 v)$/;"	f
Vector3LengthSqr	.\include\raymath.h	/^RMAPI float Vector3LengthSqr(const Vector3 v)$/;"	f
Vector3Lerp	.\include\raymath.h	/^RMAPI Vector3 Vector3Lerp(Vector3 v1, Vector3 v2, float amount)$/;"	f
Vector3Max	.\include\raymath.h	/^RMAPI Vector3 Vector3Max(Vector3 v1, Vector3 v2)$/;"	f
Vector3Min	.\include\raymath.h	/^RMAPI Vector3 Vector3Min(Vector3 v1, Vector3 v2)$/;"	f
Vector3Multiply	.\include\raymath.h	/^RMAPI Vector3 Vector3Multiply(Vector3 v1, Vector3 v2)$/;"	f
Vector3Negate	.\include\raymath.h	/^RMAPI Vector3 Vector3Negate(Vector3 v)$/;"	f
Vector3Normalize	.\include\raymath.h	/^RMAPI Vector3 Vector3Normalize(Vector3 v)$/;"	f
Vector3One	.\include\raymath.h	/^RMAPI Vector3 Vector3One(void)$/;"	f
Vector3OrthoNormalize	.\include\raymath.h	/^RMAPI void Vector3OrthoNormalize(Vector3 *v1, Vector3 *v2)$/;"	f
Vector3Perpendicular	.\include\raymath.h	/^RMAPI Vector3 Vector3Perpendicular(Vector3 v)$/;"	f
Vector3Project	.\include\raymath.h	/^RMAPI Vector3 Vector3Project(Vector3 v1, Vector3 v2)$/;"	f
Vector3Reflect	.\include\raymath.h	/^RMAPI Vector3 Vector3Reflect(Vector3 v, Vector3 normal)$/;"	f
Vector3Refract	.\include\raymath.h	/^RMAPI Vector3 Vector3Refract(Vector3 v, Vector3 n, float r)$/;"	f
Vector3Reject	.\include\raymath.h	/^RMAPI Vector3 Vector3Reject(Vector3 v1, Vector3 v2)$/;"	f
Vector3RotateByAxisAngle	.\include\raymath.h	/^RMAPI Vector3 Vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle)$/;"	f
Vector3RotateByQuaternion	.\include\raymath.h	/^RMAPI Vector3 Vector3RotateByQuaternion(Vector3 v, Quaternion q)$/;"	f
Vector3Scale	.\include\raymath.h	/^RMAPI Vector3 Vector3Scale(Vector3 v, float scalar)$/;"	f
Vector3Subtract	.\include\raymath.h	/^RMAPI Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)$/;"	f
Vector3SubtractValue	.\include\raymath.h	/^RMAPI Vector3 Vector3SubtractValue(Vector3 v, float sub)$/;"	f
Vector3ToFloat	.\include\raymath.h	104;"	d
Vector3ToFloatV	.\include\raymath.h	/^RMAPI float3 Vector3ToFloatV(Vector3 v)$/;"	f
Vector3Transform	.\include\raymath.h	/^RMAPI Vector3 Vector3Transform(Vector3 v, Matrix mat)$/;"	f
Vector3Unproject	.\include\raymath.h	/^RMAPI Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)$/;"	f
Vector3Zero	.\include\raymath.h	/^RMAPI Vector3 Vector3Zero(void)$/;"	f
Vector4	.\include\raylib.h	/^typedef struct Vector4 {$/;"	s
Vector4	.\include\raylib.h	/^} Vector4;$/;"	t	typeref:struct:Vector4
Vector4	.\include\raymath.h	/^typedef struct Vector4 {$/;"	s
Vector4	.\include\raymath.h	/^} Vector4;$/;"	t	typeref:struct:Vector4
VrDeviceInfo	.\include\raylib.h	/^typedef struct VrDeviceInfo {$/;"	s
VrDeviceInfo	.\include\raylib.h	/^} VrDeviceInfo;$/;"	t	typeref:struct:VrDeviceInfo
VrStereoConfig	.\include\raylib.h	/^typedef struct VrStereoConfig {$/;"	s
VrStereoConfig	.\include\raylib.h	/^} VrStereoConfig;$/;"	t	typeref:struct:VrStereoConfig
WHITE	.\include\raylib.h	186;"	d
WINGDIAPI	.\include\rlgl.h	791;"	d
WaitTime	.\include\raylib.h	/^RLAPI void WaitTime(double seconds);                              \/\/ Wait for some time (halt program execution)$/;"	p
Wave	.\include\raylib.h	/^typedef struct Wave {$/;"	s
Wave	.\include\raylib.h	/^} Wave;$/;"	t	typeref:struct:Wave
WaveCopy	.\include\raylib.h	/^RLAPI Wave WaveCopy(Wave wave);                                       \/\/ Copy a wave to a new wave$/;"	p
WaveCrop	.\include\raylib.h	/^RLAPI void WaveCrop(Wave *wave, int initSample, int finalSample);     \/\/ Crop a wave to defined samples range$/;"	p
WaveFormat	.\include\raylib.h	/^RLAPI void WaveFormat(Wave *wave, int sampleRate, int sampleSize, int channels); \/\/ Convert wave data to desired format$/;"	p
WindowShouldClose	.\include\raylib.h	/^RLAPI bool WindowShouldClose(void);                               \/\/ Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)$/;"	p
Wrap	.\include\raymath.h	/^RMAPI float Wrap(float value, float min, float max)$/;"	f
YELLOW	.\include\raylib.h	167;"	d
__declspec	.\include\raylib.h	94;"	d
a	.\include\raylib.h	/^    unsigned char a;        \/\/ Color alpha value$/;"	m	struct:Color
a	.\src\utils.c	/^    Vector2 a;$/;"	m	struct:__anon41	file:
activeTextureId	.\include\rlgl.h	/^        unsigned int activeTextureId[RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS];    \/\/ Active texture ids to be enabled on batch drawing (0 active by default)$/;"	m	struct:rlglData::__anon33
advanceX	.\include\raylib.h	/^    int advanceX;           \/\/ Character advance position X$/;"	m	struct:GlyphInfo
animNormals	.\include\raylib.h	/^    float *animNormals;     \/\/ Animated normals (after bones transformations)$/;"	m	struct:Mesh
animVertices	.\include\raylib.h	/^    float *animVertices;    \/\/ Animated vertex positions (after bones transformations)$/;"	m	struct:Mesh
arena	.\src\memory.c	/^    mem_arena *arena;$/;"	m	struct:__anon36	file:
array_length	.\src\utils.c	9;"	d	file:
assert	.\src\utils.c	35;"	d	file:
b	.\include\raylib.h	/^    unsigned char b;        \/\/ Color blue value$/;"	m	struct:Color
b	.\src\utils.c	/^    Vector2 b;$/;"	m	struct:__anon41	file:
baseSize	.\include\raylib.h	/^    int baseSize;           \/\/ Base size (default chars height)$/;"	m	struct:Font
bindPose	.\include\raylib.h	/^    Transform *bindPose;    \/\/ Bones base transformation (pose)$/;"	m	struct:Model
boneCount	.\include\raylib.h	/^    int boneCount;          \/\/ Number of bones$/;"	m	struct:Model
boneCount	.\include\raylib.h	/^    int boneCount;          \/\/ Number of bones$/;"	m	struct:ModelAnimation
boneIds	.\include\raylib.h	/^    unsigned char *boneIds; \/\/ Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)$/;"	m	struct:Mesh
boneWeights	.\include\raylib.h	/^    float *boneWeights;     \/\/ Vertex bone weight, up to 4 bones influence by vertex (skinning)$/;"	m	struct:Mesh
bones	.\include\raylib.h	/^    BoneInfo *bones;        \/\/ Bones information (skeleton)$/;"	m	struct:Model
bones	.\include\raylib.h	/^    BoneInfo *bones;        \/\/ Bones information (skeleton)$/;"	m	struct:ModelAnimation
bool	.\include\raylib.h	/^    typedef enum bool { false = 0, true = !false } bool;$/;"	g
bool	.\include\raylib.h	/^    typedef enum bool { false = 0, true = !false } bool;$/;"	t	typeref:enum:bool
bool	.\include\rlgl.h	/^typedef enum bool { false = 0, true = !false } bool;$/;"	g
bool	.\include\rlgl.h	/^typedef enum bool { false = 0, true = !false } bool;$/;"	t	typeref:enum:bool
bottom	.\include\raylib.h	/^    int bottom;             \/\/ Bottom border offset$/;"	m	struct:NPatchInfo
buffer	.\include\raylib.h	/^    rAudioBuffer *buffer;       \/\/ Pointer to internal data used by the audio system$/;"	m	struct:AudioStream
bufferCount	.\include\rlgl.h	/^    int bufferCount;            \/\/ Number of vertex buffers (multi-buffering support)$/;"	m	struct:rlRenderBatch
capacity	.\include\raylib.h	/^    unsigned int capacity;          \/\/ Events max entries (MAX_AUTOMATION_EVENTS)$/;"	m	struct:AutomationEventList
capacity	.\include\raylib.h	/^    unsigned int capacity;          \/\/ Filepaths max entries$/;"	m	struct:FilePathList
channels	.\include\raylib.h	/^    unsigned int channels;      \/\/ Number of channels (1-mono, 2-stereo, ...)$/;"	m	struct:AudioStream
channels	.\include\raylib.h	/^    unsigned int channels;      \/\/ Number of channels (1-mono, 2-stereo, ...)$/;"	m	struct:Wave
chromaAbCorrection	.\include\raylib.h	/^    float chromaAbCorrection[4];    \/\/ Chromatic aberration correction parameters$/;"	m	struct:VrDeviceInfo
color	.\include\raylib.h	/^    Color color;            \/\/ Material map color$/;"	m	struct:MaterialMap
color	.\src\render.h	/^    Color color;$/;"	m	struct:__anon38
colora	.\include\rlgl.h	/^        unsigned char colorr, colorg, colorb, colora;   \/\/ Current active color (added on glVertex*())$/;"	m	struct:rlglData::__anon33
colorb	.\include\rlgl.h	/^        unsigned char colorr, colorg, colorb, colora;   \/\/ Current active color (added on glVertex*())$/;"	m	struct:rlglData::__anon33
colorg	.\include\rlgl.h	/^        unsigned char colorr, colorg, colorb, colora;   \/\/ Current active color (added on glVertex*())$/;"	m	struct:rlglData::__anon33
colorr	.\include\rlgl.h	/^        unsigned char colorr, colorg, colorb, colora;   \/\/ Current active color (added on glVertex*())$/;"	m	struct:rlglData::__anon33
colors	.\include\raylib.h	/^    unsigned char *colors;      \/\/ Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)$/;"	m	struct:Mesh
colors	.\include\rlgl.h	/^    unsigned char *colors;      \/\/ Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)$/;"	m	struct:rlVertexBuffer
computeShader	.\include\rlgl.h	/^        bool computeShader;                 \/\/ Compute shaders support (GL_ARB_compute_shader)$/;"	m	struct:rlglData::__anon34
count	.\include\raylib.h	/^    unsigned int count;             \/\/ Events entries count$/;"	m	struct:AutomationEventList
count	.\include\raylib.h	/^    unsigned int count;             \/\/ Filepaths entries count$/;"	m	struct:FilePathList
count	.\src\render.h	/^    i32 count;$/;"	m	struct:__anon39
ctxData	.\include\raylib.h	/^    void *ctxData;              \/\/ Audio context data, depends on type$/;"	m	struct:Music
ctxType	.\include\raylib.h	/^    int ctxType;                \/\/ Type of music context (audio filetype)$/;"	m	struct:Music
currentBatch	.\include\rlgl.h	/^    rlRenderBatch *currentBatch;            \/\/ Current render batch$/;"	m	struct:rlglData
currentBlendMode	.\include\rlgl.h	/^        int currentBlendMode;               \/\/ Blending mode active$/;"	m	struct:rlglData::__anon33
currentBuffer	.\include\rlgl.h	/^    int currentBuffer;          \/\/ Current buffer tracking in case of multi-buffering$/;"	m	struct:rlRenderBatch
currentDepth	.\include\rlgl.h	/^    float currentDepth;         \/\/ Current depth value for next draw$/;"	m	struct:rlRenderBatch
currentMatrix	.\include\rlgl.h	/^        Matrix *currentMatrix;              \/\/ Current matrix pointer$/;"	m	struct:rlglData::__anon33
currentMatrixMode	.\include\rlgl.h	/^        int currentMatrixMode;              \/\/ Current matrix mode$/;"	m	struct:rlglData::__anon33
currentShaderId	.\include\rlgl.h	/^        unsigned int currentShaderId;       \/\/ Current shader id to be used on rendering (by default, defaultShaderId)$/;"	m	struct:rlglData::__anon33
currentShaderLocs	.\include\rlgl.h	/^        int *currentShaderLocs;             \/\/ Current shader locations pointer to be used on rendering (by default, defaultShaderLocs)$/;"	m	struct:rlglData::__anon33
data	.\include\raylib.h	/^    void *data;                 \/\/ Buffer data pointer$/;"	m	struct:Wave
data	.\include\raylib.h	/^    void *data;             \/\/ Image raw data$/;"	m	struct:Image
defaultBatch	.\include\rlgl.h	/^    rlRenderBatch defaultBatch;             \/\/ Default internal render batch$/;"	m	struct:rlglData
defaultFShaderId	.\include\rlgl.h	/^        unsigned int defaultFShaderId;      \/\/ Default fragment shader id (used by default shader program)$/;"	m	struct:rlglData::__anon33
defaultShaderId	.\include\rlgl.h	/^        unsigned int defaultShaderId;       \/\/ Default shader program id, supports vertex color and diffuse texture$/;"	m	struct:rlglData::__anon33
defaultShaderLocs	.\include\rlgl.h	/^        int *defaultShaderLocs;             \/\/ Default shader locations pointer to be used on rendering$/;"	m	struct:rlglData::__anon33
defaultTextureId	.\include\rlgl.h	/^        unsigned int defaultTextureId;      \/\/ Default texture used on shapes\/poly drawing (required by shader)$/;"	m	struct:rlglData::__anon33
defaultVShaderId	.\include\rlgl.h	/^        unsigned int defaultVShaderId;      \/\/ Default vertex shader id (used by default shader program)$/;"	m	struct:rlglData::__anon33
depth	.\include\raylib.h	/^    Texture depth;          \/\/ Depth buffer attachment texture$/;"	m	struct:RenderTexture
direction	.\include\raylib.h	/^    Vector3 direction;      \/\/ Ray direction$/;"	m	struct:Ray
distance	.\include\raylib.h	/^    float distance;         \/\/ Distance to the nearest hit$/;"	m	struct:RayCollision
drawCounter	.\include\rlgl.h	/^    int drawCounter;            \/\/ Draw calls counter$/;"	m	struct:rlRenderBatch
draw_grids	.\src\main.c	/^draw_grids(render_group *render, range guide_limits, vector2i grid_count) {$/;"	f
draw_guides	.\src\main.c	/^draw_guides(render_group *render) {$/;"	f
draws	.\include\rlgl.h	/^    rlDrawCall *draws;          \/\/ Draw calls array, depends on textureId$/;"	m	struct:rlRenderBatch
elementCount	.\include\rlgl.h	/^    int elementCount;           \/\/ Number of elements in the buffer (QUADS)$/;"	m	struct:rlVertexBuffer
elements	.\src\render.h	/^    mem_arena *elements;$/;"	m	struct:__anon39
end	.\src\render.h	/^    Vector2 end;$/;"	m	struct:__anon38
events	.\include\raylib.h	/^    AutomationEvent *events;        \/\/ Events entries$/;"	m	struct:AutomationEventList
eyeToScreenDistance	.\include\raylib.h	/^    float eyeToScreenDistance;      \/\/ Distance between eye and display in meters$/;"	m	struct:VrDeviceInfo
f32	.\src\utils.c	/^typedef float f32;$/;"	t	file:
f64	.\src\utils.c	/^typedef double f64;$/;"	t	file:
false	.\include\raylib.h	/^    typedef enum bool { false = 0, true = !false } bool;$/;"	e	enum:bool
false	.\include\rlgl.h	/^typedef enum bool { false = 0, true = !false } bool;$/;"	e	enum:bool
false	.\src\utils.c	30;"	d	file:
float16	.\include\raymath.h	/^typedef struct float16 {$/;"	s
float16	.\include\raymath.h	/^} float16;$/;"	t	typeref:struct:float16
float3	.\include\raymath.h	/^typedef struct float3 {$/;"	s
float3	.\include\raymath.h	/^} float3;$/;"	t	typeref:struct:float3
format	.\include\raylib.h	/^    int format;             \/\/ Data format (PixelFormat type)$/;"	m	struct:Image
format	.\include\raylib.h	/^    int format;             \/\/ Data format (PixelFormat type)$/;"	m	struct:Texture
fovy	.\include\raylib.h	/^    float fovy;             \/\/ Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic$/;"	m	struct:Camera3D
frame	.\include\raylib.h	/^    unsigned int frame;             \/\/ Event frame$/;"	m	struct:AutomationEvent
frameCount	.\include\raylib.h	/^    int frameCount;         \/\/ Number of animation frames$/;"	m	struct:ModelAnimation
frameCount	.\include\raylib.h	/^    unsigned int frameCount;    \/\/ Total number of frames (considering channels)$/;"	m	struct:Music
frameCount	.\include\raylib.h	/^    unsigned int frameCount;    \/\/ Total number of frames (considering channels)$/;"	m	struct:Sound
frameCount	.\include\raylib.h	/^    unsigned int frameCount;    \/\/ Total number of frames (considering channels)$/;"	m	struct:Wave
framePoses	.\include\raylib.h	/^    Transform **framePoses; \/\/ Poses array by frame$/;"	m	struct:ModelAnimation
framebufferHeight	.\include\rlgl.h	/^        int framebufferHeight;              \/\/ Current framebuffer height$/;"	m	struct:rlglData::__anon33
framebufferWidth	.\include\rlgl.h	/^        int framebufferWidth;               \/\/ Current framebuffer width$/;"	m	struct:rlglData::__anon33
g	.\include\raylib.h	/^    unsigned char g;        \/\/ Color green value$/;"	m	struct:Color
gigabyte	.\src\utils.c	14;"	d	file:
glBindVertexArray	.\include\rlgl.h	/^static PFNGLBINDVERTEXARRAYOESPROC glBindVertexArray = NULL;$/;"	v
glBlendDestFactorAlpha	.\include\rlgl.h	/^        int glBlendDestFactorAlpha;         \/\/ Blending destination alpha factor$/;"	m	struct:rlglData::__anon33
glBlendDestFactorRGB	.\include\rlgl.h	/^        int glBlendDestFactorRGB;           \/\/ Blending destination RGB factor$/;"	m	struct:rlglData::__anon33
glBlendDstFactor	.\include\rlgl.h	/^        int glBlendDstFactor;               \/\/ Blending destination factor$/;"	m	struct:rlglData::__anon33
glBlendEquation	.\include\rlgl.h	/^        int glBlendEquation;                \/\/ Blending equation$/;"	m	struct:rlglData::__anon33
glBlendEquationAlpha	.\include\rlgl.h	/^        int glBlendEquationAlpha;           \/\/ Blending equation for alpha$/;"	m	struct:rlglData::__anon33
glBlendEquationRGB	.\include\rlgl.h	/^        int glBlendEquationRGB;             \/\/ Blending equation for RGB$/;"	m	struct:rlglData::__anon33
glBlendSrcFactor	.\include\rlgl.h	/^        int glBlendSrcFactor;               \/\/ Blending source factor$/;"	m	struct:rlglData::__anon33
glBlendSrcFactorAlpha	.\include\rlgl.h	/^        int glBlendSrcFactorAlpha;          \/\/ Blending source alpha factor$/;"	m	struct:rlglData::__anon33
glBlendSrcFactorRGB	.\include\rlgl.h	/^        int glBlendSrcFactorRGB;            \/\/ Blending source RGB factor$/;"	m	struct:rlglData::__anon33
glClearDepth	.\include\rlgl.h	906;"	d
glCustomBlendModeModified	.\include\rlgl.h	/^        bool glCustomBlendModeModified;     \/\/ Custom blending factor and equation modification status$/;"	m	struct:rlglData::__anon33
glDeleteVertexArrays	.\include\rlgl.h	/^static PFNGLDELETEVERTEXARRAYSOESPROC glDeleteVertexArrays = NULL;$/;"	v
glDrawArraysInstanced	.\include\rlgl.h	/^static PFNGLDRAWARRAYSINSTANCEDEXTPROC glDrawArraysInstanced = NULL;$/;"	v
glDrawElementsInstanced	.\include\rlgl.h	/^static PFNGLDRAWELEMENTSINSTANCEDEXTPROC glDrawElementsInstanced = NULL;$/;"	v
glGenVertexArrays	.\include\rlgl.h	/^static PFNGLGENVERTEXARRAYSOESPROC glGenVertexArrays = NULL;$/;"	v
glVertexAttribDivisor	.\include\rlgl.h	/^static PFNGLVERTEXATTRIBDIVISOREXTPROC glVertexAttribDivisor = NULL;$/;"	v
global_var	.\src\utils.c	33;"	d	file:
glyphCount	.\include\raylib.h	/^    int glyphCount;         \/\/ Number of glyph characters$/;"	m	struct:Font
glyphPadding	.\include\raylib.h	/^    int glyphPadding;       \/\/ Padding around the glyph characters$/;"	m	struct:Font
glyphs	.\include\raylib.h	/^    GlyphInfo *glyphs;      \/\/ Glyphs info data$/;"	m	struct:Font
hResolution	.\include\raylib.h	/^    int hResolution;                \/\/ Horizontal resolution in pixels$/;"	m	struct:VrDeviceInfo
hScreenSize	.\include\raylib.h	/^    float hScreenSize;              \/\/ Horizontal size in meters$/;"	m	struct:VrDeviceInfo
height	.\include\raylib.h	/^    float height;           \/\/ Rectangle height$/;"	m	struct:Rectangle
height	.\include\raylib.h	/^    int height;             \/\/ Image base height$/;"	m	struct:Image
height	.\include\raylib.h	/^    int height;             \/\/ Texture base height$/;"	m	struct:Texture
hit	.\include\raylib.h	/^    bool hit;               \/\/ Did the ray hit something?$/;"	m	struct:RayCollision
i32	.\src\utils.c	/^typedef int32_t i32;$/;"	t	file:
i64	.\src\utils.c	/^typedef int64_t i64;$/;"	t	file:
i8	.\src\utils.c	/^typedef int8_t i8;$/;"	t	file:
id	.\include\raylib.h	/^    unsigned int id;        \/\/ OpenGL framebuffer object id$/;"	m	struct:RenderTexture
id	.\include\raylib.h	/^    unsigned int id;        \/\/ OpenGL texture id$/;"	m	struct:Texture
id	.\include\raylib.h	/^    unsigned int id;        \/\/ Shader program id$/;"	m	struct:Shader
image	.\include\raylib.h	/^    Image image;            \/\/ Character image data$/;"	m	struct:GlyphInfo
indices	.\include\raylib.h	/^    unsigned short *indices;    \/\/ Vertex indices (in case vertex data comes indexed)$/;"	m	struct:Mesh
indices	.\include\rlgl.h	/^    unsigned int *indices;      \/\/ Vertex indices (in case vertex data comes indexed) (6 indices per quad)$/;"	m	struct:rlVertexBuffer
indices	.\include\rlgl.h	/^    unsigned short *indices;    \/\/ Vertex indices (in case vertex data comes indexed) (6 indices per quad)$/;"	m	struct:rlVertexBuffer
instancing	.\include\rlgl.h	/^        bool instancing;                    \/\/ Instancing supported (GL_ANGLE_instanced_arrays, GL_EXT_draw_instanced + GL_EXT_instanced_arrays)$/;"	m	struct:rlglData::__anon34
internal	.\src\utils.c	31;"	d	file:
interpupillaryDistance	.\include\raylib.h	/^    float interpupillaryDistance;   \/\/ IPD (distance between pupils) in meters$/;"	m	struct:VrDeviceInfo
kilobyte	.\src\utils.c	12;"	d	file:
layout	.\include\raylib.h	/^    int layout;             \/\/ Layout of the n-patch: 3x3, 1x3 or 3x1$/;"	m	struct:NPatchInfo
left	.\include\raylib.h	/^    int left;               \/\/ Left border offset$/;"	m	struct:NPatchInfo
leftLensCenter	.\include\raylib.h	/^    float leftLensCenter[2];        \/\/ VR left lens center$/;"	m	struct:VrStereoConfig
leftScreenCenter	.\include\raylib.h	/^    float leftScreenCenter[2];      \/\/ VR left screen center$/;"	m	struct:VrStereoConfig
lensDistortionValues	.\include\raylib.h	/^    float lensDistortionValues[4];  \/\/ Lens distortion constant parameters$/;"	m	struct:VrDeviceInfo
lensSeparationDistance	.\include\raylib.h	/^    float lensSeparationDistance;   \/\/ Lens separation distance in meters$/;"	m	struct:VrDeviceInfo
local_persist	.\src\utils.c	32;"	d	file:
locs	.\include\raylib.h	/^    int *locs;              \/\/ Shader locations array (RL_MAX_SHADER_LOCATIONS)$/;"	m	struct:Shader
looping	.\include\raylib.h	/^    bool looping;               \/\/ Music looping enable$/;"	m	struct:Music
m0	.\include\raylib.h	/^    float m0, m4, m8, m12;  \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m0	.\include\raymath.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m0	.\include\rlgl.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m1	.\include\raylib.h	/^    float m1, m5, m9, m13;  \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m1	.\include\raymath.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m1	.\include\rlgl.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m10	.\include\raylib.h	/^    float m2, m6, m10, m14; \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m10	.\include\raymath.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m10	.\include\rlgl.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m11	.\include\raylib.h	/^    float m3, m7, m11, m15; \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m11	.\include\raymath.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m11	.\include\rlgl.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m12	.\include\raylib.h	/^    float m0, m4, m8, m12;  \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m12	.\include\raymath.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m12	.\include\rlgl.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m13	.\include\raylib.h	/^    float m1, m5, m9, m13;  \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m13	.\include\raymath.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m13	.\include\rlgl.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m14	.\include\raylib.h	/^    float m2, m6, m10, m14; \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m14	.\include\raymath.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m14	.\include\rlgl.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m15	.\include\raylib.h	/^    float m3, m7, m11, m15; \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m15	.\include\raymath.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m15	.\include\rlgl.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m2	.\include\raylib.h	/^    float m2, m6, m10, m14; \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m2	.\include\raymath.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m2	.\include\rlgl.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m3	.\include\raylib.h	/^    float m3, m7, m11, m15; \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m3	.\include\raymath.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m3	.\include\rlgl.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m4	.\include\raylib.h	/^    float m0, m4, m8, m12;  \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m4	.\include\raymath.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m4	.\include\rlgl.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m5	.\include\raylib.h	/^    float m1, m5, m9, m13;  \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m5	.\include\raymath.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m5	.\include\rlgl.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m6	.\include\raylib.h	/^    float m2, m6, m10, m14; \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m6	.\include\raymath.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m6	.\include\rlgl.h	/^    float m2, m6, m10, m14;     \/\/ Matrix third row (4 components)$/;"	m	struct:Matrix
m7	.\include\raylib.h	/^    float m3, m7, m11, m15; \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m7	.\include\raymath.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m7	.\include\rlgl.h	/^    float m3, m7, m11, m15;     \/\/ Matrix fourth row (4 components)$/;"	m	struct:Matrix
m8	.\include\raylib.h	/^    float m0, m4, m8, m12;  \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m8	.\include\raymath.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m8	.\include\rlgl.h	/^    float m0, m4, m8, m12;      \/\/ Matrix first row (4 components)$/;"	m	struct:Matrix
m9	.\include\raylib.h	/^    float m1, m5, m9, m13;  \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m9	.\include\raymath.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
m9	.\include\rlgl.h	/^    float m1, m5, m9, m13;      \/\/ Matrix second row (4 components)$/;"	m	struct:Matrix
main	.\src\main.c	/^i32 main() {$/;"	f
maps	.\include\raylib.h	/^    MaterialMap *maps;      \/\/ Material maps array (MAX_MATERIAL_MAPS)$/;"	m	struct:Material
materialCount	.\include\raylib.h	/^    int materialCount;      \/\/ Number of materials$/;"	m	struct:Model
materials	.\include\raylib.h	/^    Material *materials;    \/\/ Materials array$/;"	m	struct:Model
max	.\include\raylib.h	/^    Vector3 max;            \/\/ Maximum vertex box-corner$/;"	m	struct:BoundingBox
maxAnisotropyLevel	.\include\rlgl.h	/^        float maxAnisotropyLevel;           \/\/ Maximum anisotropy level supported (minimum is 2.0f)$/;"	m	struct:rlglData::__anon34
maxDepthBits	.\include\rlgl.h	/^        int maxDepthBits;                   \/\/ Maximum bits for depth component$/;"	m	struct:rlglData::__anon34
megabyte	.\src\utils.c	13;"	d	file:
mem_aligment_offset	.\src\memory.c	/^mem_aligment_offset(mem_arena *arena, usize alignment) {$/;"	f
mem_arena	.\src\memory.c	/^} mem_arena;$/;"	t	typeref:struct:__anon35	file:
mem_arena_allocate	.\src\memory.c	/^mem_arena_allocate(usize bytes_to_allocate) {$/;"	f
mem_push_array	.\src\memory.c	91;"	d	file:
mem_push_size	.\src\memory.c	/^mem_push_size(mem_arena *arena, usize size) {$/;"	f
mem_push_struct	.\src\memory.c	90;"	d	file:
mem_temp_begin	.\src\memory.c	/^mem_temp_begin(mem_arena *arena) {$/;"	f
mem_temp_end	.\src\memory.c	/^mem_temp_end(temp_memory temp_mem) {$/;"	f
meshCount	.\include\raylib.h	/^    int meshCount;          \/\/ Number of meshes$/;"	m	struct:Model
meshMaterial	.\include\raylib.h	/^    int *meshMaterial;      \/\/ Mesh material number$/;"	m	struct:Model
meshes	.\include\raylib.h	/^    Mesh *meshes;           \/\/ Meshes array$/;"	m	struct:Model
min	.\include\raylib.h	/^    Vector3 min;            \/\/ Minimum vertex box-corner$/;"	m	struct:BoundingBox
mipmaps	.\include\raylib.h	/^    int mipmaps;            \/\/ Mipmap levels, 1 by default$/;"	m	struct:Image
mipmaps	.\include\raylib.h	/^    int mipmaps;            \/\/ Mipmap levels, 1 by default$/;"	m	struct:Texture
mode	.\include\rlgl.h	/^    int mode;                   \/\/ Drawing mode: LINES, TRIANGLES, QUADS$/;"	m	struct:rlDrawCall
modelview	.\include\rlgl.h	/^        Matrix modelview;                   \/\/ Default modelview matrix$/;"	m	struct:rlglData::__anon33
name	.\include\raylib.h	/^    char name[32];          \/\/ Animation name$/;"	m	struct:ModelAnimation
name	.\include\raylib.h	/^    char name[32];          \/\/ Bone name$/;"	m	struct:BoneInfo
normal	.\include\raylib.h	/^    Vector3 normal;         \/\/ Surface normal of hit$/;"	m	struct:RayCollision
normals	.\include\raylib.h	/^    float *normals;         \/\/ Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)$/;"	m	struct:Mesh
normalx	.\include\rlgl.h	/^        float normalx, normaly, normalz;    \/\/ Current active normal (added on glVertex*())$/;"	m	struct:rlglData::__anon33
normaly	.\include\rlgl.h	/^        float normalx, normaly, normalz;    \/\/ Current active normal (added on glVertex*())$/;"	m	struct:rlglData::__anon33
normalz	.\include\rlgl.h	/^        float normalx, normaly, normalz;    \/\/ Current active normal (added on glVertex*())$/;"	m	struct:rlglData::__anon33
offset	.\include\raylib.h	/^    Vector2 offset;         \/\/ Camera offset (displacement from target)$/;"	m	struct:Camera2D
offsetX	.\include\raylib.h	/^    int offsetX;            \/\/ Character offset X when drawing$/;"	m	struct:GlyphInfo
offsetY	.\include\raylib.h	/^    int offsetY;            \/\/ Character offset Y when drawing$/;"	m	struct:GlyphInfo
params	.\include\raylib.h	/^    float params[4];        \/\/ Material generic parameters (if required)$/;"	m	struct:Material
params	.\include\raylib.h	/^    int params[4];                  \/\/ Event parameters (if required)$/;"	m	struct:AutomationEvent
parent	.\include\raylib.h	/^    int parent;             \/\/ Bone parent$/;"	m	struct:BoneInfo
paths	.\include\raylib.h	/^    char **paths;                   \/\/ Filepaths entries$/;"	m	struct:FilePathList
platform_mem_allocate	.\src\memory.c	/^platform_mem_allocate(usize size) {$/;"	f
point	.\include\raylib.h	/^    Vector3 point;          \/\/ Point of the nearest hit$/;"	m	struct:RayCollision
position	.\include\raylib.h	/^    Vector3 position;       \/\/ Camera position$/;"	m	struct:Camera3D
position	.\include\raylib.h	/^    Vector3 position;       \/\/ Ray position (origin)$/;"	m	struct:Ray
processor	.\include\raylib.h	/^    rAudioProcessor *processor; \/\/ Pointer to internal data processor, useful for audio effects$/;"	m	struct:AudioStream
projection	.\include\raylib.h	/^    Matrix projection[2];           \/\/ VR projection matrices (per eye)$/;"	m	struct:VrStereoConfig
projection	.\include\raylib.h	/^    int projection;         \/\/ Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC$/;"	m	struct:Camera3D
projection	.\include\rlgl.h	/^        Matrix projection;                  \/\/ Default projection matrix$/;"	m	struct:rlglData::__anon33
projectionStereo	.\include\rlgl.h	/^        Matrix projectionStereo[2];         \/\/ VR stereo rendering eyes projection matrices$/;"	m	struct:rlglData::__anon33
ptr	.\src\memory.c	/^    void *ptr;$/;"	m	struct:__anon35	file:
push_line_to_render	.\src\render.c	/^push_line_to_render(render_group *render, render_line line) {$/;"	f
r	.\include\raylib.h	/^    unsigned char r;        \/\/ Color red value$/;"	m	struct:Color
rAudioBuffer	.\include\raylib.h	/^typedef struct rAudioBuffer rAudioBuffer;$/;"	t	typeref:struct:rAudioBuffer
rAudioProcessor	.\include\raylib.h	/^typedef struct rAudioProcessor rAudioProcessor;$/;"	t	typeref:struct:rAudioProcessor
range	.\src\utils.c	/^} range;$/;"	t	typeref:struct:__anon41	file:
recs	.\include\raylib.h	/^    Rectangle *recs;        \/\/ Rectangles in texture for the glyphs$/;"	m	struct:Font
render	.\src\render.c	/^render(render_group *group) {$/;"	f
render_group	.\src\render.h	/^} render_group;$/;"	t	typeref:struct:__anon39
render_line	.\src\render.h	/^} render_line;$/;"	t	typeref:struct:__anon38
render_reset	.\src\render.c	/^render_reset(render_group *group) {$/;"	f
render_type	.\src\render.h	/^} render_type;$/;"	t	typeref:enum:__anon37
render_type_count	.\src\render.h	/^    render_type_count,$/;"	e	enum:__anon37
render_type_line	.\src\render.h	/^    render_type_line,$/;"	e	enum:__anon37
right	.\include\raylib.h	/^    int right;              \/\/ Right border offset$/;"	m	struct:NPatchInfo
rightLensCenter	.\include\raylib.h	/^    float rightLensCenter[2];       \/\/ VR right lens center$/;"	m	struct:VrStereoConfig
rightScreenCenter	.\include\raylib.h	/^    float rightScreenCenter[2];     \/\/ VR right screen center$/;"	m	struct:VrStereoConfig
rlActiveDrawBuffers	.\include\rlgl.h	/^RLAPI void rlActiveDrawBuffers(int count);              \/\/ Activate multiple draw color buffers$/;"	p
rlActiveDrawBuffers	.\include\rlgl.h	/^void rlActiveDrawBuffers(int count)$/;"	f
rlActiveTextureSlot	.\include\rlgl.h	/^RLAPI void rlActiveTextureSlot(int slot);               \/\/ Select and active a texture slot$/;"	p
rlActiveTextureSlot	.\include\rlgl.h	/^void rlActiveTextureSlot(int slot)$/;"	f
rlBegin	.\include\rlgl.h	/^RLAPI void rlBegin(int mode);                         \/\/ Initialize drawing mode (how to organize vertex)$/;"	p
rlBegin	.\include\rlgl.h	/^void rlBegin(int mode)$/;"	f
rlBindImageTexture	.\include\rlgl.h	/^RLAPI void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly);  \/\/ Bind image texture$/;"	p
rlBindImageTexture	.\include\rlgl.h	/^void rlBindImageTexture(unsigned int id, unsigned int index, int format, bool readonly)$/;"	f
rlBindShaderBuffer	.\include\rlgl.h	/^RLAPI void rlBindShaderBuffer(unsigned int id, unsigned int index);             \/\/ Bind SSBO buffer$/;"	p
rlBindShaderBuffer	.\include\rlgl.h	/^void rlBindShaderBuffer(unsigned int id, unsigned int index)$/;"	f
rlBlendMode	.\include\rlgl.h	/^} rlBlendMode;$/;"	t	typeref:enum:__anon26
rlBlitFramebuffer	.\include\rlgl.h	/^RLAPI void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask); \/\/ Blit active framebuffer to main framebuffer$/;"	p
rlBlitFramebuffer	.\include\rlgl.h	/^void rlBlitFramebuffer(int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight, int bufferMask)$/;"	f
rlCheckErrors	.\include\rlgl.h	/^RLAPI void rlCheckErrors(void);                         \/\/ Check and log OpenGL error codes$/;"	p
rlCheckErrors	.\include\rlgl.h	/^void rlCheckErrors()$/;"	f
rlCheckRenderBatchLimit	.\include\rlgl.h	/^RLAPI bool rlCheckRenderBatchLimit(int vCount);                             \/\/ Check internal buffer overflow for a given number of vertex$/;"	p
rlCheckRenderBatchLimit	.\include\rlgl.h	/^bool rlCheckRenderBatchLimit(int vCount)$/;"	f
rlClearColor	.\include\rlgl.h	/^RLAPI void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a); \/\/ Clear color buffer with color$/;"	p
rlClearColor	.\include\rlgl.h	/^void rlClearColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)$/;"	f
rlClearScreenBuffers	.\include\rlgl.h	/^RLAPI void rlClearScreenBuffers(void);                  \/\/ Clear used screen buffers (color and depth)$/;"	p
rlClearScreenBuffers	.\include\rlgl.h	/^void rlClearScreenBuffers(void)$/;"	f
rlColor3f	.\include\rlgl.h	/^RLAPI void rlColor3f(float x, float y, float z);          \/\/ Define one vertex (color) - 3 float$/;"	p
rlColor3f	.\include\rlgl.h	/^void rlColor3f(float x, float y, float z) { glColor3f(x, y, z); }$/;"	f
rlColor3f	.\include\rlgl.h	/^void rlColor3f(float x, float y, float z)$/;"	f
rlColor4f	.\include\rlgl.h	/^RLAPI void rlColor4f(float x, float y, float z, float w); \/\/ Define one vertex (color) - 4 float$/;"	p
rlColor4f	.\include\rlgl.h	/^void rlColor4f(float r, float g, float b, float a)$/;"	f
rlColor4f	.\include\rlgl.h	/^void rlColor4f(float x, float y, float z, float w) { glColor4f(x, y, z, w); }$/;"	f
rlColor4ub	.\include\rlgl.h	/^RLAPI void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a);  \/\/ Define one vertex (color) - 4 byte$/;"	p
rlColor4ub	.\include\rlgl.h	/^void rlColor4ub(unsigned char r, unsigned char g, unsigned char b, unsigned char a) { glColor4ub(r, g, b, a); }$/;"	f
rlColor4ub	.\include\rlgl.h	/^void rlColor4ub(unsigned char x, unsigned char y, unsigned char z, unsigned char w)$/;"	f
rlCompileShader	.\include\rlgl.h	/^RLAPI unsigned int rlCompileShader(const char *shaderCode, int type);           \/\/ Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)$/;"	p
rlCompileShader	.\include\rlgl.h	/^unsigned int rlCompileShader(const char *shaderCode, int type)$/;"	f
rlComputeShaderDispatch	.\include\rlgl.h	/^RLAPI void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ);  \/\/ Dispatch compute shader (equivalent to *draw* for graphics pipeline)$/;"	p
rlComputeShaderDispatch	.\include\rlgl.h	/^void rlComputeShaderDispatch(unsigned int groupX, unsigned int groupY, unsigned int groupZ)$/;"	f
rlCopyShaderBuffer	.\include\rlgl.h	/^RLAPI void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count); \/\/ Copy SSBO data between buffers$/;"	p
rlCopyShaderBuffer	.\include\rlgl.h	/^void rlCopyShaderBuffer(unsigned int destId, unsigned int srcId, unsigned int destOffset, unsigned int srcOffset, unsigned int count)$/;"	f
rlCubemapParameters	.\include\rlgl.h	/^RLAPI void rlCubemapParameters(unsigned int id, int param, int value); \/\/ Set cubemap parameters (filter, wrap)$/;"	p
rlCubemapParameters	.\include\rlgl.h	/^void rlCubemapParameters(unsigned int id, int param, int value)$/;"	f
rlCullMode	.\include\rlgl.h	/^} rlCullMode;$/;"	t	typeref:enum:__anon32
rlDebugMessageCallback	.\include\rlgl.h	/^static void GLAPIENTRY rlDebugMessageCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *message, const void *userParam)$/;"	f
rlDisableBackfaceCulling	.\include\rlgl.h	/^RLAPI void rlDisableBackfaceCulling(void);              \/\/ Disable backface culling$/;"	p
rlDisableBackfaceCulling	.\include\rlgl.h	/^void rlDisableBackfaceCulling(void) { glDisable(GL_CULL_FACE); }$/;"	f
rlDisableColorBlend	.\include\rlgl.h	/^RLAPI void rlDisableColorBlend(void);                   \/\/ Disable color blending$/;"	p
rlDisableColorBlend	.\include\rlgl.h	/^void rlDisableColorBlend(void) { glDisable(GL_BLEND); }$/;"	f
rlDisableDepthMask	.\include\rlgl.h	/^RLAPI void rlDisableDepthMask(void);                    \/\/ Disable depth write$/;"	p
rlDisableDepthMask	.\include\rlgl.h	/^void rlDisableDepthMask(void) { glDepthMask(GL_FALSE); }$/;"	f
rlDisableDepthTest	.\include\rlgl.h	/^RLAPI void rlDisableDepthTest(void);                    \/\/ Disable depth test$/;"	p
rlDisableDepthTest	.\include\rlgl.h	/^void rlDisableDepthTest(void) { glDisable(GL_DEPTH_TEST); }$/;"	f
rlDisableFramebuffer	.\include\rlgl.h	/^RLAPI void rlDisableFramebuffer(void);                  \/\/ Disable render texture (fbo), return to default framebuffer$/;"	p
rlDisableFramebuffer	.\include\rlgl.h	/^void rlDisableFramebuffer(void)$/;"	f
rlDisableScissorTest	.\include\rlgl.h	/^RLAPI void rlDisableScissorTest(void);                  \/\/ Disable scissor test$/;"	p
rlDisableScissorTest	.\include\rlgl.h	/^void rlDisableScissorTest(void) { glDisable(GL_SCISSOR_TEST); }$/;"	f
rlDisableShader	.\include\rlgl.h	/^RLAPI void rlDisableShader(void);                       \/\/ Disable shader program$/;"	p
rlDisableShader	.\include\rlgl.h	/^void rlDisableShader(void)$/;"	f
rlDisableSmoothLines	.\include\rlgl.h	/^RLAPI void rlDisableSmoothLines(void);                  \/\/ Disable line aliasing$/;"	p
rlDisableSmoothLines	.\include\rlgl.h	/^void rlDisableSmoothLines(void)$/;"	f
rlDisableStatePointer	.\include\rlgl.h	/^RLAPI void rlDisableStatePointer(int vertexAttribType);                 \/\/ Disable attribute state pointer$/;"	p
rlDisableStatePointer	.\include\rlgl.h	/^void rlDisableStatePointer(int vertexAttribType)$/;"	f
rlDisableStereoRender	.\include\rlgl.h	/^RLAPI void rlDisableStereoRender(void);                 \/\/ Disable stereo rendering$/;"	p
rlDisableStereoRender	.\include\rlgl.h	/^void rlDisableStereoRender(void)$/;"	f
rlDisableTexture	.\include\rlgl.h	/^RLAPI void rlDisableTexture(void);                      \/\/ Disable texture$/;"	p
rlDisableTexture	.\include\rlgl.h	/^void rlDisableTexture(void)$/;"	f
rlDisableTextureCubemap	.\include\rlgl.h	/^RLAPI void rlDisableTextureCubemap(void);               \/\/ Disable texture cubemap$/;"	p
rlDisableTextureCubemap	.\include\rlgl.h	/^void rlDisableTextureCubemap(void)$/;"	f
rlDisableVertexArray	.\include\rlgl.h	/^RLAPI void rlDisableVertexArray(void);                  \/\/ Disable vertex array (VAO, if supported)$/;"	p
rlDisableVertexArray	.\include\rlgl.h	/^void rlDisableVertexArray(void)$/;"	f
rlDisableVertexAttribute	.\include\rlgl.h	/^RLAPI void rlDisableVertexAttribute(unsigned int index);\/\/ Disable vertex attribute index$/;"	p
rlDisableVertexAttribute	.\include\rlgl.h	/^void rlDisableVertexAttribute(unsigned int index)$/;"	f
rlDisableVertexBuffer	.\include\rlgl.h	/^RLAPI void rlDisableVertexBuffer(void);                 \/\/ Disable vertex buffer (VBO)$/;"	p
rlDisableVertexBuffer	.\include\rlgl.h	/^void rlDisableVertexBuffer(void)$/;"	f
rlDisableVertexBufferElement	.\include\rlgl.h	/^RLAPI void rlDisableVertexBufferElement(void);          \/\/ Disable vertex buffer element (VBO element)$/;"	p
rlDisableVertexBufferElement	.\include\rlgl.h	/^void rlDisableVertexBufferElement(void)$/;"	f
rlDisableWireMode	.\include\rlgl.h	/^RLAPI void rlDisableWireMode(void);                     \/\/ Disable wire mode ( and point ) maybe rename$/;"	p
rlDisableWireMode	.\include\rlgl.h	/^void rlDisableWireMode(void)$/;"	f
rlDrawCall	.\include\rlgl.h	/^typedef struct rlDrawCall {$/;"	s
rlDrawCall	.\include\rlgl.h	/^} rlDrawCall;$/;"	t	typeref:struct:rlDrawCall
rlDrawRenderBatch	.\include\rlgl.h	/^RLAPI void rlDrawRenderBatch(rlRenderBatch *batch);                         \/\/ Draw render batch data (Update->Draw->Reset)$/;"	p
rlDrawRenderBatch	.\include\rlgl.h	/^void rlDrawRenderBatch(rlRenderBatch *batch)$/;"	f
rlDrawRenderBatchActive	.\include\rlgl.h	/^RLAPI void rlDrawRenderBatchActive(void);                                   \/\/ Update and draw internal render batch$/;"	p
rlDrawRenderBatchActive	.\include\rlgl.h	/^void rlDrawRenderBatchActive(void)$/;"	f
rlDrawVertexArray	.\include\rlgl.h	/^RLAPI void rlDrawVertexArray(int offset, int count);$/;"	p
rlDrawVertexArray	.\include\rlgl.h	/^void rlDrawVertexArray(int offset, int count)$/;"	f
rlDrawVertexArrayElements	.\include\rlgl.h	/^RLAPI void rlDrawVertexArrayElements(int offset, int count, const void *buffer);$/;"	p
rlDrawVertexArrayElements	.\include\rlgl.h	/^void rlDrawVertexArrayElements(int offset, int count, const void *buffer)$/;"	f
rlDrawVertexArrayElementsInstanced	.\include\rlgl.h	/^RLAPI void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances);$/;"	p
rlDrawVertexArrayElementsInstanced	.\include\rlgl.h	/^void rlDrawVertexArrayElementsInstanced(int offset, int count, const void *buffer, int instances)$/;"	f
rlDrawVertexArrayInstanced	.\include\rlgl.h	/^RLAPI void rlDrawVertexArrayInstanced(int offset, int count, int instances);$/;"	p
rlDrawVertexArrayInstanced	.\include\rlgl.h	/^void rlDrawVertexArrayInstanced(int offset, int count, int instances)$/;"	f
rlEnableBackfaceCulling	.\include\rlgl.h	/^RLAPI void rlEnableBackfaceCulling(void);               \/\/ Enable backface culling$/;"	p
rlEnableBackfaceCulling	.\include\rlgl.h	/^void rlEnableBackfaceCulling(void) { glEnable(GL_CULL_FACE); }$/;"	f
rlEnableColorBlend	.\include\rlgl.h	/^RLAPI void rlEnableColorBlend(void);                     \/\/ Enable color blending$/;"	p
rlEnableColorBlend	.\include\rlgl.h	/^void rlEnableColorBlend(void) { glEnable(GL_BLEND); }$/;"	f
rlEnableDepthMask	.\include\rlgl.h	/^RLAPI void rlEnableDepthMask(void);                     \/\/ Enable depth write$/;"	p
rlEnableDepthMask	.\include\rlgl.h	/^void rlEnableDepthMask(void) { glDepthMask(GL_TRUE); }$/;"	f
rlEnableDepthTest	.\include\rlgl.h	/^RLAPI void rlEnableDepthTest(void);                     \/\/ Enable depth test$/;"	p
rlEnableDepthTest	.\include\rlgl.h	/^void rlEnableDepthTest(void) { glEnable(GL_DEPTH_TEST); }$/;"	f
rlEnableFramebuffer	.\include\rlgl.h	/^RLAPI void rlEnableFramebuffer(unsigned int id);        \/\/ Enable render texture (fbo)$/;"	p
rlEnableFramebuffer	.\include\rlgl.h	/^void rlEnableFramebuffer(unsigned int id)$/;"	f
rlEnablePointMode	.\include\rlgl.h	/^RLAPI void rlEnablePointMode(void);                     \/\/  Enable point mode$/;"	p
rlEnablePointMode	.\include\rlgl.h	/^void rlEnablePointMode(void)$/;"	f
rlEnableScissorTest	.\include\rlgl.h	/^RLAPI void rlEnableScissorTest(void);                   \/\/ Enable scissor test$/;"	p
rlEnableScissorTest	.\include\rlgl.h	/^void rlEnableScissorTest(void) { glEnable(GL_SCISSOR_TEST); }$/;"	f
rlEnableShader	.\include\rlgl.h	/^RLAPI void rlEnableShader(unsigned int id);             \/\/ Enable shader program$/;"	p
rlEnableShader	.\include\rlgl.h	/^void rlEnableShader(unsigned int id)$/;"	f
rlEnableSmoothLines	.\include\rlgl.h	/^RLAPI void rlEnableSmoothLines(void);                   \/\/ Enable line aliasing$/;"	p
rlEnableSmoothLines	.\include\rlgl.h	/^void rlEnableSmoothLines(void)$/;"	f
rlEnableStatePointer	.\include\rlgl.h	/^RLAPI void rlEnableStatePointer(int vertexAttribType, void *buffer);    \/\/ Enable attribute state pointer$/;"	p
rlEnableStatePointer	.\include\rlgl.h	/^void rlEnableStatePointer(int vertexAttribType, void *buffer)$/;"	f
rlEnableStereoRender	.\include\rlgl.h	/^RLAPI void rlEnableStereoRender(void);                  \/\/ Enable stereo rendering$/;"	p
rlEnableStereoRender	.\include\rlgl.h	/^void rlEnableStereoRender(void)$/;"	f
rlEnableTexture	.\include\rlgl.h	/^RLAPI void rlEnableTexture(unsigned int id);            \/\/ Enable texture$/;"	p
rlEnableTexture	.\include\rlgl.h	/^void rlEnableTexture(unsigned int id)$/;"	f
rlEnableTextureCubemap	.\include\rlgl.h	/^RLAPI void rlEnableTextureCubemap(unsigned int id);     \/\/ Enable texture cubemap$/;"	p
rlEnableTextureCubemap	.\include\rlgl.h	/^void rlEnableTextureCubemap(unsigned int id)$/;"	f
rlEnableVertexArray	.\include\rlgl.h	/^RLAPI bool rlEnableVertexArray(unsigned int vaoId);     \/\/ Enable vertex array (VAO, if supported)$/;"	p
rlEnableVertexArray	.\include\rlgl.h	/^bool rlEnableVertexArray(unsigned int vaoId)$/;"	f
rlEnableVertexAttribute	.\include\rlgl.h	/^RLAPI void rlEnableVertexAttribute(unsigned int index); \/\/ Enable vertex attribute index$/;"	p
rlEnableVertexAttribute	.\include\rlgl.h	/^void rlEnableVertexAttribute(unsigned int index)$/;"	f
rlEnableVertexBuffer	.\include\rlgl.h	/^RLAPI void rlEnableVertexBuffer(unsigned int id);       \/\/ Enable vertex buffer (VBO)$/;"	p
rlEnableVertexBuffer	.\include\rlgl.h	/^void rlEnableVertexBuffer(unsigned int id)$/;"	f
rlEnableVertexBufferElement	.\include\rlgl.h	/^RLAPI void rlEnableVertexBufferElement(unsigned int id);\/\/ Enable vertex buffer element (VBO element)$/;"	p
rlEnableVertexBufferElement	.\include\rlgl.h	/^void rlEnableVertexBufferElement(unsigned int id)$/;"	f
rlEnableWireMode	.\include\rlgl.h	/^RLAPI void rlEnableWireMode(void);                      \/\/ Enable wire mode$/;"	p
rlEnableWireMode	.\include\rlgl.h	/^void rlEnableWireMode(void)$/;"	f
rlEnd	.\include\rlgl.h	/^RLAPI void rlEnd(void);                               \/\/ Finish vertex providing$/;"	p
rlEnd	.\include\rlgl.h	/^void rlEnd() { glEnd(); }$/;"	f
rlEnd	.\include\rlgl.h	/^void rlEnd(void)$/;"	f
rlFramebufferAttach	.\include\rlgl.h	/^RLAPI void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel);  \/\/ Attach texture\/renderbuffer to a framebuffer$/;"	p
rlFramebufferAttach	.\include\rlgl.h	/^void rlFramebufferAttach(unsigned int fboId, unsigned int texId, int attachType, int texType, int mipLevel)$/;"	f
rlFramebufferAttachTextureType	.\include\rlgl.h	/^} rlFramebufferAttachTextureType;$/;"	t	typeref:enum:__anon31
rlFramebufferAttachType	.\include\rlgl.h	/^} rlFramebufferAttachType;$/;"	t	typeref:enum:__anon30
rlFramebufferComplete	.\include\rlgl.h	/^RLAPI bool rlFramebufferComplete(unsigned int id);                        \/\/ Verify framebuffer is complete$/;"	p
rlFramebufferComplete	.\include\rlgl.h	/^bool rlFramebufferComplete(unsigned int id)$/;"	f
rlFrustum	.\include\rlgl.h	/^RLAPI void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar);$/;"	p
rlFrustum	.\include\rlgl.h	/^void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar)$/;"	f
rlGenTextureMipmaps	.\include\rlgl.h	/^RLAPI void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps); \/\/ Generate mipmap data for selected texture$/;"	p
rlGenTextureMipmaps	.\include\rlgl.h	/^void rlGenTextureMipmaps(unsigned int id, int width, int height, int format, int *mipmaps)$/;"	f
rlGetCompressedFormatName	.\include\rlgl.h	/^static const char *rlGetCompressedFormatName(int format)$/;"	f
rlGetCompressedFormatName	.\include\rlgl.h	/^static const char *rlGetCompressedFormatName(int format); \/\/ Get compressed format official GL identifier name$/;"	p
rlGetFramebufferHeight	.\include\rlgl.h	/^RLAPI int rlGetFramebufferHeight(void);                 \/\/ Get default framebuffer height$/;"	p
rlGetFramebufferHeight	.\include\rlgl.h	/^int rlGetFramebufferHeight(void)$/;"	f
rlGetFramebufferWidth	.\include\rlgl.h	/^RLAPI int rlGetFramebufferWidth(void);                  \/\/ Get default framebuffer width$/;"	p
rlGetFramebufferWidth	.\include\rlgl.h	/^int rlGetFramebufferWidth(void)$/;"	f
rlGetGlTextureFormats	.\include\rlgl.h	/^RLAPI void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType);  \/\/ Get OpenGL internal formats$/;"	p
rlGetGlTextureFormats	.\include\rlgl.h	/^void rlGetGlTextureFormats(int format, unsigned int *glInternalFormat, unsigned int *glFormat, unsigned int *glType)$/;"	f
rlGetLineWidth	.\include\rlgl.h	/^RLAPI float rlGetLineWidth(void);                       \/\/ Get the line drawing width$/;"	p
rlGetLineWidth	.\include\rlgl.h	/^float rlGetLineWidth(void)$/;"	f
rlGetLocationAttrib	.\include\rlgl.h	/^RLAPI int rlGetLocationAttrib(unsigned int shaderId, const char *attribName);   \/\/ Get shader location attribute$/;"	p
rlGetLocationAttrib	.\include\rlgl.h	/^int rlGetLocationAttrib(unsigned int shaderId, const char *attribName)$/;"	f
rlGetLocationUniform	.\include\rlgl.h	/^RLAPI int rlGetLocationUniform(unsigned int shaderId, const char *uniformName); \/\/ Get shader location uniform$/;"	p
rlGetLocationUniform	.\include\rlgl.h	/^int rlGetLocationUniform(unsigned int shaderId, const char *uniformName)$/;"	f
rlGetMatrixModelview	.\include\rlgl.h	/^Matrix rlGetMatrixModelview(void)$/;"	f
rlGetMatrixModelview	.\include\rlgl.h	/^RLAPI Matrix rlGetMatrixModelview(void);                                  \/\/ Get internal modelview matrix$/;"	p
rlGetMatrixProjection	.\include\rlgl.h	/^Matrix rlGetMatrixProjection(void)$/;"	f
rlGetMatrixProjection	.\include\rlgl.h	/^RLAPI Matrix rlGetMatrixProjection(void);                                 \/\/ Get internal projection matrix$/;"	p
rlGetMatrixProjectionStereo	.\include\rlgl.h	/^RLAPI Matrix rlGetMatrixProjectionStereo(int eye)$/;"	f
rlGetMatrixProjectionStereo	.\include\rlgl.h	/^RLAPI Matrix rlGetMatrixProjectionStereo(int eye);                        \/\/ Get internal projection matrix for stereo render (selected eye)$/;"	p
rlGetMatrixTransform	.\include\rlgl.h	/^Matrix rlGetMatrixTransform(void)$/;"	f
rlGetMatrixTransform	.\include\rlgl.h	/^RLAPI Matrix rlGetMatrixTransform(void);                                  \/\/ Get internal accumulated transform matrix$/;"	p
rlGetMatrixViewOffsetStereo	.\include\rlgl.h	/^RLAPI Matrix rlGetMatrixViewOffsetStereo(int eye)$/;"	f
rlGetMatrixViewOffsetStereo	.\include\rlgl.h	/^RLAPI Matrix rlGetMatrixViewOffsetStereo(int eye);                        \/\/ Get internal view offset matrix for stereo render (selected eye)$/;"	p
rlGetPixelDataSize	.\include\rlgl.h	/^static int rlGetPixelDataSize(int width, int height, int format)$/;"	f
rlGetPixelDataSize	.\include\rlgl.h	/^static int rlGetPixelDataSize(int width, int height, int format);   \/\/ Get pixel data size in bytes (image or texture)$/;"	p
rlGetPixelFormatName	.\include\rlgl.h	/^RLAPI const char *rlGetPixelFormatName(unsigned int format);              \/\/ Get name string for pixel format$/;"	p
rlGetPixelFormatName	.\include\rlgl.h	/^const char *rlGetPixelFormatName(unsigned int format)$/;"	f
rlGetShaderBufferSize	.\include\rlgl.h	/^RLAPI unsigned int rlGetShaderBufferSize(unsigned int id);                      \/\/ Get SSBO buffer size$/;"	p
rlGetShaderBufferSize	.\include\rlgl.h	/^unsigned int rlGetShaderBufferSize(unsigned int id)$/;"	f
rlGetShaderIdDefault	.\include\rlgl.h	/^RLAPI unsigned int rlGetShaderIdDefault(void);          \/\/ Get default shader id$/;"	p
rlGetShaderIdDefault	.\include\rlgl.h	/^unsigned int rlGetShaderIdDefault(void)$/;"	f
rlGetShaderLocsDefault	.\include\rlgl.h	/^RLAPI int *rlGetShaderLocsDefault(void);                \/\/ Get default shader locations$/;"	p
rlGetShaderLocsDefault	.\include\rlgl.h	/^int *rlGetShaderLocsDefault(void)$/;"	f
rlGetTextureIdDefault	.\include\rlgl.h	/^RLAPI unsigned int rlGetTextureIdDefault(void);         \/\/ Get default texture id$/;"	p
rlGetTextureIdDefault	.\include\rlgl.h	/^unsigned int rlGetTextureIdDefault(void)$/;"	f
rlGetVersion	.\include\rlgl.h	/^RLAPI int rlGetVersion(void);                           \/\/ Get current OpenGL version$/;"	p
rlGetVersion	.\include\rlgl.h	/^int rlGetVersion(void)$/;"	f
rlGlVersion	.\include\rlgl.h	/^} rlGlVersion;$/;"	t	typeref:enum:__anon22
rlIsStereoRenderEnabled	.\include\rlgl.h	/^RLAPI bool rlIsStereoRenderEnabled(void);               \/\/ Check if stereo render is enabled$/;"	p
rlIsStereoRenderEnabled	.\include\rlgl.h	/^bool rlIsStereoRenderEnabled(void)$/;"	f
rlLoadComputeShaderProgram	.\include\rlgl.h	/^RLAPI unsigned int rlLoadComputeShaderProgram(unsigned int shaderId);           \/\/ Load compute shader program$/;"	p
rlLoadComputeShaderProgram	.\include\rlgl.h	/^unsigned int rlLoadComputeShaderProgram(unsigned int shaderId)$/;"	f
rlLoadDrawCube	.\include\rlgl.h	/^RLAPI void rlLoadDrawCube(void);     \/\/ Load and draw a cube$/;"	p
rlLoadDrawCube	.\include\rlgl.h	/^void rlLoadDrawCube(void)$/;"	f
rlLoadDrawQuad	.\include\rlgl.h	/^RLAPI void rlLoadDrawQuad(void);     \/\/ Load and draw a quad$/;"	p
rlLoadDrawQuad	.\include\rlgl.h	/^void rlLoadDrawQuad(void)$/;"	f
rlLoadExtensions	.\include\rlgl.h	/^RLAPI void rlLoadExtensions(void *loader);              \/\/ Load OpenGL extensions (loader function required)$/;"	p
rlLoadExtensions	.\include\rlgl.h	/^void rlLoadExtensions(void *loader)$/;"	f
rlLoadFramebuffer	.\include\rlgl.h	/^RLAPI unsigned int rlLoadFramebuffer(int width, int height);              \/\/ Load an empty framebuffer$/;"	p
rlLoadFramebuffer	.\include\rlgl.h	/^unsigned int rlLoadFramebuffer(int width, int height)$/;"	f
rlLoadIdentity	.\include\rlgl.h	/^RLAPI void rlLoadIdentity(void);                      \/\/ Reset current matrix to identity matrix$/;"	p
rlLoadIdentity	.\include\rlgl.h	/^void rlLoadIdentity(void) { glLoadIdentity(); }$/;"	f
rlLoadIdentity	.\include\rlgl.h	/^void rlLoadIdentity(void)$/;"	f
rlLoadRenderBatch	.\include\rlgl.h	/^RLAPI rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements);  \/\/ Load a render batch system$/;"	p
rlLoadRenderBatch	.\include\rlgl.h	/^rlRenderBatch rlLoadRenderBatch(int numBuffers, int bufferElements)$/;"	f
rlLoadShaderBuffer	.\include\rlgl.h	/^RLAPI unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint); \/\/ Load shader storage buffer object (SSBO)$/;"	p
rlLoadShaderBuffer	.\include\rlgl.h	/^unsigned int rlLoadShaderBuffer(unsigned int size, const void *data, int usageHint)$/;"	f
rlLoadShaderCode	.\include\rlgl.h	/^RLAPI unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode);    \/\/ Load shader from code strings$/;"	p
rlLoadShaderCode	.\include\rlgl.h	/^unsigned int rlLoadShaderCode(const char *vsCode, const char *fsCode)$/;"	f
rlLoadShaderDefault	.\include\rlgl.h	/^static void rlLoadShaderDefault(void)$/;"	f
rlLoadShaderDefault	.\include\rlgl.h	/^static void rlLoadShaderDefault(void);      \/\/ Load default shader$/;"	p
rlLoadShaderProgram	.\include\rlgl.h	/^RLAPI unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId); \/\/ Load custom shader program$/;"	p
rlLoadShaderProgram	.\include\rlgl.h	/^unsigned int rlLoadShaderProgram(unsigned int vShaderId, unsigned int fShaderId)$/;"	f
rlLoadTexture	.\include\rlgl.h	/^RLAPI unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount); \/\/ Load texture in GPU$/;"	p
rlLoadTexture	.\include\rlgl.h	/^unsigned int rlLoadTexture(const void *data, int width, int height, int format, int mipmapCount)$/;"	f
rlLoadTextureCubemap	.\include\rlgl.h	/^RLAPI unsigned int rlLoadTextureCubemap(const void *data, int size, int format);                        \/\/ Load texture cubemap$/;"	p
rlLoadTextureCubemap	.\include\rlgl.h	/^unsigned int rlLoadTextureCubemap(const void *data, int size, int format)$/;"	f
rlLoadTextureDepth	.\include\rlgl.h	/^RLAPI unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer);               \/\/ Load depth texture\/renderbuffer (to be attached to fbo)$/;"	p
rlLoadTextureDepth	.\include\rlgl.h	/^unsigned int rlLoadTextureDepth(int width, int height, bool useRenderBuffer)$/;"	f
rlLoadVertexArray	.\include\rlgl.h	/^RLAPI unsigned int rlLoadVertexArray(void);                               \/\/ Load vertex array (vao) if supported$/;"	p
rlLoadVertexArray	.\include\rlgl.h	/^unsigned int rlLoadVertexArray(void)$/;"	f
rlLoadVertexBuffer	.\include\rlgl.h	/^RLAPI unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic);            \/\/ Load a vertex buffer attribute$/;"	p
rlLoadVertexBuffer	.\include\rlgl.h	/^unsigned int rlLoadVertexBuffer(const void *buffer, int size, bool dynamic)$/;"	f
rlLoadVertexBufferElement	.\include\rlgl.h	/^RLAPI unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic);     \/\/ Load a new attributes element buffer$/;"	p
rlLoadVertexBufferElement	.\include\rlgl.h	/^unsigned int rlLoadVertexBufferElement(const void *buffer, int size, bool dynamic)$/;"	f
rlMatrixIdentity	.\include\rlgl.h	/^static Matrix rlMatrixIdentity(void)$/;"	f
rlMatrixIdentity	.\include\rlgl.h	/^static Matrix rlMatrixIdentity(void);                       \/\/ Get identity matrix$/;"	p
rlMatrixMode	.\include\rlgl.h	/^RLAPI void rlMatrixMode(int mode);                    \/\/ Choose the current matrix to be transformed$/;"	p
rlMatrixMode	.\include\rlgl.h	/^void rlMatrixMode(int mode)$/;"	f
rlMatrixMultiply	.\include\rlgl.h	/^static Matrix rlMatrixMultiply(Matrix left, Matrix right)$/;"	f
rlMatrixMultiply	.\include\rlgl.h	/^static Matrix rlMatrixMultiply(Matrix left, Matrix right);  \/\/ Multiply two matrices$/;"	p
rlMultMatrixf	.\include\rlgl.h	/^RLAPI void rlMultMatrixf(const float *matf);                \/\/ Multiply the current matrix by another matrix$/;"	p
rlMultMatrixf	.\include\rlgl.h	/^void rlMultMatrixf(const float *matf) { glMultMatrixf(matf); }$/;"	f
rlMultMatrixf	.\include\rlgl.h	/^void rlMultMatrixf(const float *matf)$/;"	f
rlNormal3f	.\include\rlgl.h	/^RLAPI void rlNormal3f(float x, float y, float z);     \/\/ Define one vertex (normal) - 3 float$/;"	p
rlNormal3f	.\include\rlgl.h	/^void rlNormal3f(float x, float y, float z) { glNormal3f(x, y, z); }$/;"	f
rlNormal3f	.\include\rlgl.h	/^void rlNormal3f(float x, float y, float z)$/;"	f
rlOrtho	.\include\rlgl.h	/^RLAPI void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar);$/;"	p
rlOrtho	.\include\rlgl.h	/^void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar)$/;"	f
rlPixelFormat	.\include\rlgl.h	/^} rlPixelFormat;$/;"	t	typeref:enum:__anon24
rlPopMatrix	.\include\rlgl.h	/^RLAPI void rlPopMatrix(void);                         \/\/ Pop latest inserted matrix from stack$/;"	p
rlPopMatrix	.\include\rlgl.h	/^void rlPopMatrix(void) { glPopMatrix(); }$/;"	f
rlPopMatrix	.\include\rlgl.h	/^void rlPopMatrix(void)$/;"	f
rlPushMatrix	.\include\rlgl.h	/^RLAPI void rlPushMatrix(void);                        \/\/ Push the current matrix to stack$/;"	p
rlPushMatrix	.\include\rlgl.h	/^void rlPushMatrix(void) { glPushMatrix(); }$/;"	f
rlPushMatrix	.\include\rlgl.h	/^void rlPushMatrix(void)$/;"	f
rlReadScreenPixels	.\include\rlgl.h	/^RLAPI unsigned char *rlReadScreenPixels(int width, int height);           \/\/ Read screen pixel data (color buffer)$/;"	p
rlReadScreenPixels	.\include\rlgl.h	/^unsigned char *rlReadScreenPixels(int width, int height)$/;"	f
rlReadShaderBuffer	.\include\rlgl.h	/^RLAPI void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset); \/\/ Read SSBO buffer data (GPU->CPU)$/;"	p
rlReadShaderBuffer	.\include\rlgl.h	/^void rlReadShaderBuffer(unsigned int id, void *dest, unsigned int count, unsigned int offset)$/;"	f
rlReadTexturePixels	.\include\rlgl.h	/^RLAPI void *rlReadTexturePixels(unsigned int id, int width, int height, int format);              \/\/ Read texture pixel data$/;"	p
rlReadTexturePixels	.\include\rlgl.h	/^void *rlReadTexturePixels(unsigned int id, int width, int height, int format)$/;"	f
rlRenderBatch	.\include\rlgl.h	/^typedef struct rlRenderBatch {$/;"	s
rlRenderBatch	.\include\rlgl.h	/^} rlRenderBatch;$/;"	t	typeref:struct:rlRenderBatch
rlRotatef	.\include\rlgl.h	/^RLAPI void rlRotatef(float angle, float x, float y, float z);  \/\/ Multiply the current matrix by a rotation matrix$/;"	p
rlRotatef	.\include\rlgl.h	/^void rlRotatef(float angle, float x, float y, float z) { glRotatef(angle, x, y, z); }$/;"	f
rlRotatef	.\include\rlgl.h	/^void rlRotatef(float angle, float x, float y, float z)$/;"	f
rlScalef	.\include\rlgl.h	/^RLAPI void rlScalef(float x, float y, float z);       \/\/ Multiply the current matrix by a scaling matrix$/;"	p
rlScalef	.\include\rlgl.h	/^void rlScalef(float x, float y, float z) { glScalef(x, y, z); }$/;"	f
rlScalef	.\include\rlgl.h	/^void rlScalef(float x, float y, float z)$/;"	f
rlScissor	.\include\rlgl.h	/^RLAPI void rlScissor(int x, int y, int width, int height); \/\/ Scissor test$/;"	p
rlScissor	.\include\rlgl.h	/^void rlScissor(int x, int y, int width, int height) { glScissor(x, y, width, height); }$/;"	f
rlSetBlendFactors	.\include\rlgl.h	/^RLAPI void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation); \/\/ Set blending mode factor and equation (using OpenGL factors)$/;"	p
rlSetBlendFactors	.\include\rlgl.h	/^void rlSetBlendFactors(int glSrcFactor, int glDstFactor, int glEquation)$/;"	f
rlSetBlendFactorsSeparate	.\include\rlgl.h	/^RLAPI void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha); \/\/ Set blending mode factors and equations separately (using OpenGL factors)$/;"	p
rlSetBlendFactorsSeparate	.\include\rlgl.h	/^void rlSetBlendFactorsSeparate(int glSrcRGB, int glDstRGB, int glSrcAlpha, int glDstAlpha, int glEqRGB, int glEqAlpha)$/;"	f
rlSetBlendMode	.\include\rlgl.h	/^RLAPI void rlSetBlendMode(int mode);                    \/\/ Set blending mode$/;"	p
rlSetBlendMode	.\include\rlgl.h	/^void rlSetBlendMode(int mode)$/;"	f
rlSetCullFace	.\include\rlgl.h	/^RLAPI void rlSetCullFace(int mode);                     \/\/ Set face culling mode$/;"	p
rlSetCullFace	.\include\rlgl.h	/^void rlSetCullFace(int mode)$/;"	f
rlSetFramebufferHeight	.\include\rlgl.h	/^RLAPI void rlSetFramebufferHeight(int height);          \/\/ Set current framebuffer height$/;"	p
rlSetFramebufferHeight	.\include\rlgl.h	/^void rlSetFramebufferHeight(int height)$/;"	f
rlSetFramebufferWidth	.\include\rlgl.h	/^RLAPI void rlSetFramebufferWidth(int width);            \/\/ Set current framebuffer width$/;"	p
rlSetFramebufferWidth	.\include\rlgl.h	/^void rlSetFramebufferWidth(int width)$/;"	f
rlSetLineWidth	.\include\rlgl.h	/^RLAPI void rlSetLineWidth(float width);                 \/\/ Set the line drawing width$/;"	p
rlSetLineWidth	.\include\rlgl.h	/^void rlSetLineWidth(float width) { glLineWidth(width); }$/;"	f
rlSetMatrixModelview	.\include\rlgl.h	/^RLAPI void rlSetMatrixModelview(Matrix view);                             \/\/ Set a custom modelview matrix (replaces internal modelview matrix)$/;"	p
rlSetMatrixModelview	.\include\rlgl.h	/^void rlSetMatrixModelview(Matrix view)$/;"	f
rlSetMatrixProjection	.\include\rlgl.h	/^RLAPI void rlSetMatrixProjection(Matrix proj);                            \/\/ Set a custom projection matrix (replaces internal projection matrix)$/;"	p
rlSetMatrixProjection	.\include\rlgl.h	/^void rlSetMatrixProjection(Matrix projection)$/;"	f
rlSetMatrixProjectionStereo	.\include\rlgl.h	/^RLAPI void rlSetMatrixProjectionStereo(Matrix right, Matrix left);        \/\/ Set eyes projection matrices for stereo rendering$/;"	p
rlSetMatrixProjectionStereo	.\include\rlgl.h	/^void rlSetMatrixProjectionStereo(Matrix right, Matrix left)$/;"	f
rlSetMatrixViewOffsetStereo	.\include\rlgl.h	/^RLAPI void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left);        \/\/ Set eyes view offsets matrices for stereo rendering$/;"	p
rlSetMatrixViewOffsetStereo	.\include\rlgl.h	/^void rlSetMatrixViewOffsetStereo(Matrix right, Matrix left)$/;"	f
rlSetRenderBatchActive	.\include\rlgl.h	/^RLAPI void rlSetRenderBatchActive(rlRenderBatch *batch);                    \/\/ Set the active render batch for rlgl (NULL for default internal)$/;"	p
rlSetRenderBatchActive	.\include\rlgl.h	/^void rlSetRenderBatchActive(rlRenderBatch *batch)$/;"	f
rlSetShader	.\include\rlgl.h	/^RLAPI void rlSetShader(unsigned int id, int *locs);                             \/\/ Set shader currently active (id and locations)$/;"	p
rlSetShader	.\include\rlgl.h	/^void rlSetShader(unsigned int id, int *locs)$/;"	f
rlSetTexture	.\include\rlgl.h	/^RLAPI void rlSetTexture(unsigned int id);               \/\/ Set current texture for render batch and check buffers limits$/;"	p
rlSetTexture	.\include\rlgl.h	/^void rlSetTexture(unsigned int id)$/;"	f
rlSetUniform	.\include\rlgl.h	/^RLAPI void rlSetUniform(int locIndex, const void *value, int uniformType, int count);   \/\/ Set shader value uniform$/;"	p
rlSetUniform	.\include\rlgl.h	/^void rlSetUniform(int locIndex, const void *value, int uniformType, int count)$/;"	f
rlSetUniformMatrix	.\include\rlgl.h	/^RLAPI void rlSetUniformMatrix(int locIndex, Matrix mat);                        \/\/ Set shader value matrix$/;"	p
rlSetUniformMatrix	.\include\rlgl.h	/^void rlSetUniformMatrix(int locIndex, Matrix mat)$/;"	f
rlSetUniformSampler	.\include\rlgl.h	/^RLAPI void rlSetUniformSampler(int locIndex, unsigned int textureId);           \/\/ Set shader value sampler$/;"	p
rlSetUniformSampler	.\include\rlgl.h	/^void rlSetUniformSampler(int locIndex, unsigned int textureId)$/;"	f
rlSetVertexAttribute	.\include\rlgl.h	/^RLAPI void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, const void *pointer);$/;"	p
rlSetVertexAttribute	.\include\rlgl.h	/^void rlSetVertexAttribute(unsigned int index, int compSize, int type, bool normalized, int stride, const void *pointer)$/;"	f
rlSetVertexAttributeDefault	.\include\rlgl.h	/^RLAPI void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count); \/\/ Set vertex attribute default value$/;"	p
rlSetVertexAttributeDefault	.\include\rlgl.h	/^void rlSetVertexAttributeDefault(int locIndex, const void *value, int attribType, int count)$/;"	f
rlSetVertexAttributeDivisor	.\include\rlgl.h	/^RLAPI void rlSetVertexAttributeDivisor(unsigned int index, int divisor);$/;"	p
rlSetVertexAttributeDivisor	.\include\rlgl.h	/^void rlSetVertexAttributeDivisor(unsigned int index, int divisor)$/;"	f
rlShaderAttributeDataType	.\include\rlgl.h	/^} rlShaderAttributeDataType;$/;"	t	typeref:enum:__anon29
rlShaderLocationIndex	.\include\rlgl.h	/^} rlShaderLocationIndex;$/;"	t	typeref:enum:__anon27
rlShaderUniformDataType	.\include\rlgl.h	/^} rlShaderUniformDataType;$/;"	t	typeref:enum:__anon28
rlTexCoord2f	.\include\rlgl.h	/^RLAPI void rlTexCoord2f(float x, float y);            \/\/ Define one vertex (texture coordinate) - 2 float$/;"	p
rlTexCoord2f	.\include\rlgl.h	/^void rlTexCoord2f(float x, float y) { glTexCoord2f(x, y); }$/;"	f
rlTexCoord2f	.\include\rlgl.h	/^void rlTexCoord2f(float x, float y)$/;"	f
rlTextureFilter	.\include\rlgl.h	/^} rlTextureFilter;$/;"	t	typeref:enum:__anon25
rlTextureParameters	.\include\rlgl.h	/^RLAPI void rlTextureParameters(unsigned int id, int param, int value); \/\/ Set texture parameters (filter, wrap)$/;"	p
rlTextureParameters	.\include\rlgl.h	/^void rlTextureParameters(unsigned int id, int param, int value)$/;"	f
rlTraceLogLevel	.\include\rlgl.h	/^} rlTraceLogLevel;$/;"	t	typeref:enum:__anon23
rlTranslatef	.\include\rlgl.h	/^RLAPI void rlTranslatef(float x, float y, float z);   \/\/ Multiply the current matrix by a translation matrix$/;"	p
rlTranslatef	.\include\rlgl.h	/^void rlTranslatef(float x, float y, float z) { glTranslatef(x, y, z); }$/;"	f
rlTranslatef	.\include\rlgl.h	/^void rlTranslatef(float x, float y, float z)$/;"	f
rlUnloadFramebuffer	.\include\rlgl.h	/^RLAPI void rlUnloadFramebuffer(unsigned int id);                          \/\/ Delete framebuffer from GPU$/;"	p
rlUnloadFramebuffer	.\include\rlgl.h	/^void rlUnloadFramebuffer(unsigned int id)$/;"	f
rlUnloadRenderBatch	.\include\rlgl.h	/^RLAPI void rlUnloadRenderBatch(rlRenderBatch batch);                        \/\/ Unload render batch system$/;"	p
rlUnloadRenderBatch	.\include\rlgl.h	/^void rlUnloadRenderBatch(rlRenderBatch batch)$/;"	f
rlUnloadShaderBuffer	.\include\rlgl.h	/^RLAPI void rlUnloadShaderBuffer(unsigned int ssboId);                           \/\/ Unload shader storage buffer object (SSBO)$/;"	p
rlUnloadShaderBuffer	.\include\rlgl.h	/^void rlUnloadShaderBuffer(unsigned int ssboId)$/;"	f
rlUnloadShaderDefault	.\include\rlgl.h	/^static void rlUnloadShaderDefault(void)$/;"	f
rlUnloadShaderDefault	.\include\rlgl.h	/^static void rlUnloadShaderDefault(void);    \/\/ Unload default shader$/;"	p
rlUnloadShaderProgram	.\include\rlgl.h	/^RLAPI void rlUnloadShaderProgram(unsigned int id);                              \/\/ Unload shader program$/;"	p
rlUnloadShaderProgram	.\include\rlgl.h	/^void rlUnloadShaderProgram(unsigned int id)$/;"	f
rlUnloadTexture	.\include\rlgl.h	/^RLAPI void rlUnloadTexture(unsigned int id);                              \/\/ Unload texture from GPU memory$/;"	p
rlUnloadTexture	.\include\rlgl.h	/^void rlUnloadTexture(unsigned int id)$/;"	f
rlUnloadVertexArray	.\include\rlgl.h	/^RLAPI void rlUnloadVertexArray(unsigned int vaoId);$/;"	p
rlUnloadVertexArray	.\include\rlgl.h	/^void rlUnloadVertexArray(unsigned int vaoId)$/;"	f
rlUnloadVertexBuffer	.\include\rlgl.h	/^RLAPI void rlUnloadVertexBuffer(unsigned int vboId);$/;"	p
rlUnloadVertexBuffer	.\include\rlgl.h	/^void rlUnloadVertexBuffer(unsigned int vboId)$/;"	f
rlUpdateShaderBuffer	.\include\rlgl.h	/^RLAPI void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset); \/\/ Update SSBO buffer data$/;"	p
rlUpdateShaderBuffer	.\include\rlgl.h	/^void rlUpdateShaderBuffer(unsigned int id, const void *data, unsigned int dataSize, unsigned int offset)$/;"	f
rlUpdateTexture	.\include\rlgl.h	/^RLAPI void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data);  \/\/ Update GPU texture with new data$/;"	p
rlUpdateTexture	.\include\rlgl.h	/^void rlUpdateTexture(unsigned int id, int offsetX, int offsetY, int width, int height, int format, const void *data)$/;"	f
rlUpdateVertexBuffer	.\include\rlgl.h	/^RLAPI void rlUpdateVertexBuffer(unsigned int bufferId, const void *data, int dataSize, int offset);     \/\/ Update GPU buffer with new data$/;"	p
rlUpdateVertexBuffer	.\include\rlgl.h	/^void rlUpdateVertexBuffer(unsigned int id, const void *data, int dataSize, int offset)$/;"	f
rlUpdateVertexBufferElements	.\include\rlgl.h	/^RLAPI void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset);   \/\/ Update vertex buffer elements with new data$/;"	p
rlUpdateVertexBufferElements	.\include\rlgl.h	/^void rlUpdateVertexBufferElements(unsigned int id, const void *data, int dataSize, int offset)$/;"	f
rlVertex2f	.\include\rlgl.h	/^RLAPI void rlVertex2f(float x, float y);              \/\/ Define one vertex (position) - 2 float$/;"	p
rlVertex2f	.\include\rlgl.h	/^void rlVertex2f(float x, float y) { glVertex2f(x, y); }$/;"	f
rlVertex2f	.\include\rlgl.h	/^void rlVertex2f(float x, float y)$/;"	f
rlVertex2i	.\include\rlgl.h	/^RLAPI void rlVertex2i(int x, int y);                  \/\/ Define one vertex (position) - 2 int$/;"	p
rlVertex2i	.\include\rlgl.h	/^void rlVertex2i(int x, int y) { glVertex2i(x, y); }$/;"	f
rlVertex2i	.\include\rlgl.h	/^void rlVertex2i(int x, int y)$/;"	f
rlVertex3f	.\include\rlgl.h	/^RLAPI void rlVertex3f(float x, float y, float z);     \/\/ Define one vertex (position) - 3 float$/;"	p
rlVertex3f	.\include\rlgl.h	/^void rlVertex3f(float x, float y, float z) { glVertex3f(x, y, z); }$/;"	f
rlVertex3f	.\include\rlgl.h	/^void rlVertex3f(float x, float y, float z)$/;"	f
rlVertexBuffer	.\include\rlgl.h	/^typedef struct rlVertexBuffer {$/;"	s
rlVertexBuffer	.\include\rlgl.h	/^} rlVertexBuffer;$/;"	t	typeref:struct:rlVertexBuffer
rlViewport	.\include\rlgl.h	/^RLAPI void rlViewport(int x, int y, int width, int height); \/\/ Set the viewport area$/;"	p
rlViewport	.\include\rlgl.h	/^void rlViewport(int x, int y, int width, int height)$/;"	f
rlglClose	.\include\rlgl.h	/^RLAPI void rlglClose(void);                             \/\/ De-initialize rlgl (buffers, shaders, textures)$/;"	p
rlglClose	.\include\rlgl.h	/^void rlglClose(void)$/;"	f
rlglData	.\include\rlgl.h	/^typedef struct rlglData {$/;"	s
rlglData	.\include\rlgl.h	/^} rlglData;$/;"	t	typeref:struct:rlglData
rlglInit	.\include\rlgl.h	/^RLAPI void rlglInit(int width, int height);             \/\/ Initialize rlgl (buffers, shaders, textures, states)$/;"	p
rlglInit	.\include\rlgl.h	/^void rlglInit(int width, int height)$/;"	f
rlglLoadProc	.\include\rlgl.h	/^typedef void *(*rlglLoadProc)(const char *name);   \/\/ OpenGL extension functions loader signature (same as GLADloadproc)$/;"	t
rotation	.\include\raylib.h	/^    Quaternion rotation;    \/\/ Rotation$/;"	m	struct:Transform
rotation	.\include\raylib.h	/^    float rotation;         \/\/ Camera rotation in degrees$/;"	m	struct:Camera2D
sampleRate	.\include\raylib.h	/^    unsigned int sampleRate;    \/\/ Frequency (samples per second)$/;"	m	struct:AudioStream
sampleRate	.\include\raylib.h	/^    unsigned int sampleRate;    \/\/ Frequency (samples per second)$/;"	m	struct:Wave
sampleSize	.\include\raylib.h	/^    unsigned int sampleSize;    \/\/ Bit depth (bits per sample): 8, 16, 32 (24 not supported)$/;"	m	struct:AudioStream
sampleSize	.\include\raylib.h	/^    unsigned int sampleSize;    \/\/ Bit depth (bits per sample): 8, 16, 32 (24 not supported)$/;"	m	struct:Wave
scale	.\include\raylib.h	/^    Vector3 scale;          \/\/ Scale$/;"	m	struct:Transform
scale	.\include\raylib.h	/^    float scale[2];                 \/\/ VR distortion scale$/;"	m	struct:VrStereoConfig
scaleIn	.\include\raylib.h	/^    float scaleIn[2];               \/\/ VR distortion scale in$/;"	m	struct:VrStereoConfig
screen_dim	.\src\render.h	/^    vector2i screen_dim;$/;"	m	struct:__anon39
screen_padding	.\src\render.h	/^    Vector2 screen_padding; \/\/ Essentially it defines the padding around the plot.$/;"	m	struct:__anon39
shader	.\include\raylib.h	/^    Shader shader;          \/\/ Material shader$/;"	m	struct:Material
size	.\src\memory.c	/^    usize size;$/;"	m	struct:__anon35	file:
source	.\include\raylib.h	/^    Rectangle source;       \/\/ Texture source rectangle$/;"	m	struct:NPatchInfo
ssbo	.\include\rlgl.h	/^        bool ssbo;                          \/\/ Shader storage buffer object support (GL_ARB_shader_storage_buffer_object)$/;"	m	struct:rlglData::__anon34
stack	.\include\rlgl.h	/^        Matrix stack[RL_MAX_MATRIX_STACK_SIZE];\/\/ Matrix stack for push\/pop$/;"	m	struct:rlglData::__anon33
stackCounter	.\include\rlgl.h	/^        int stackCounter;                   \/\/ Matrix stack counter$/;"	m	struct:rlglData::__anon33
start	.\src\render.h	/^    Vector2 start;$/;"	m	struct:__anon38
stereoRender	.\include\rlgl.h	/^        bool stereoRender;                  \/\/ Stereo rendering flag$/;"	m	struct:rlglData::__anon33
stream	.\include\raylib.h	/^    AudioStream stream;         \/\/ Audio stream$/;"	m	struct:Music
stream	.\include\raylib.h	/^    AudioStream stream;         \/\/ Audio stream$/;"	m	struct:Sound
tangents	.\include\raylib.h	/^    float *tangents;        \/\/ Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)$/;"	m	struct:Mesh
target	.\include\raylib.h	/^    Vector2 target;         \/\/ Camera target (rotation and zoom origin)$/;"	m	struct:Camera2D
target	.\include\raylib.h	/^    Vector3 target;         \/\/ Camera target it looks-at$/;"	m	struct:Camera3D
temp_count	.\src\memory.c	/^    u32 temp_count;$/;"	m	struct:__anon35	file:
temp_memory	.\src\memory.c	/^} temp_memory;$/;"	t	typeref:struct:__anon36	file:
terabyte	.\src\utils.c	15;"	d	file:
texAnisoFilter	.\include\rlgl.h	/^        bool texAnisoFilter;                \/\/ Anisotropic texture filtering support (GL_EXT_texture_filter_anisotropic)$/;"	m	struct:rlglData::__anon34
texCompASTC	.\include\rlgl.h	/^        bool texCompASTC;                   \/\/ ASTC texture compression support (GL_KHR_texture_compression_astc_hdr, GL_KHR_texture_compression_astc_ldr)$/;"	m	struct:rlglData::__anon34
texCompDXT	.\include\rlgl.h	/^        bool texCompDXT;                    \/\/ DDS texture compression support (GL_EXT_texture_compression_s3tc, GL_WEBGL_compressed_texture_s3tc, GL_WEBKIT_WEBGL_compressed_texture_s3tc)$/;"	m	struct:rlglData::__anon34
texCompETC1	.\include\rlgl.h	/^        bool texCompETC1;                   \/\/ ETC1 texture compression support (GL_OES_compressed_ETC1_RGB8_texture, GL_WEBGL_compressed_texture_etc1)$/;"	m	struct:rlglData::__anon34
texCompETC2	.\include\rlgl.h	/^        bool texCompETC2;                   \/\/ ETC2\/EAC texture compression support (GL_ARB_ES3_compatibility)$/;"	m	struct:rlglData::__anon34
texCompPVRT	.\include\rlgl.h	/^        bool texCompPVRT;                   \/\/ PVR texture compression support (GL_IMG_texture_compression_pvrtc)$/;"	m	struct:rlglData::__anon34
texDepth	.\include\rlgl.h	/^        bool texDepth;                      \/\/ Depth textures supported (GL_ARB_depth_texture, GL_OES_depth_texture)$/;"	m	struct:rlglData::__anon34
texDepthWebGL	.\include\rlgl.h	/^        bool texDepthWebGL;                 \/\/ Depth textures supported WebGL specific (GL_WEBGL_depth_texture)$/;"	m	struct:rlglData::__anon34
texFloat16	.\include\rlgl.h	/^        bool texFloat16;                    \/\/ half float textures support (16 bit per channel) (GL_OES_texture_half_float)$/;"	m	struct:rlglData::__anon34
texFloat32	.\include\rlgl.h	/^        bool texFloat32;                    \/\/ float textures support (32 bit per channel) (GL_OES_texture_float)$/;"	m	struct:rlglData::__anon34
texMirrorClamp	.\include\rlgl.h	/^        bool texMirrorClamp;                \/\/ Clamp mirror wrap mode supported (GL_EXT_texture_mirror_clamp)$/;"	m	struct:rlglData::__anon34
texNPOT	.\include\rlgl.h	/^        bool texNPOT;                       \/\/ NPOT textures full support (GL_ARB_texture_non_power_of_two, GL_OES_texture_npot)$/;"	m	struct:rlglData::__anon34
texcoords	.\include\raylib.h	/^    float *texcoords;       \/\/ Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)$/;"	m	struct:Mesh
texcoords	.\include\rlgl.h	/^    float *texcoords;           \/\/ Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)$/;"	m	struct:rlVertexBuffer
texcoords2	.\include\raylib.h	/^    float *texcoords2;      \/\/ Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)$/;"	m	struct:Mesh
texcoordx	.\include\rlgl.h	/^        float texcoordx, texcoordy;         \/\/ Current active texture coordinate (added on glVertex*())$/;"	m	struct:rlglData::__anon33
texcoordy	.\include\rlgl.h	/^        float texcoordx, texcoordy;         \/\/ Current active texture coordinate (added on glVertex*())$/;"	m	struct:rlglData::__anon33
texture	.\include\raylib.h	/^    Texture texture;        \/\/ Color buffer attachment texture$/;"	m	struct:RenderTexture
texture	.\include\raylib.h	/^    Texture2D texture;      \/\/ Material map texture$/;"	m	struct:MaterialMap
texture	.\include\raylib.h	/^    Texture2D texture;      \/\/ Texture atlas containing the glyphs$/;"	m	struct:Font
textureId	.\include\rlgl.h	/^    unsigned int textureId;     \/\/ Texture id to be used on the draw -> Use to create new draw call if changes$/;"	m	struct:rlDrawCall
thickness	.\src\render.h	/^    i32 thickness;$/;"	m	struct:__anon38
top	.\include\raylib.h	/^    int top;                \/\/ Top border offset$/;"	m	struct:NPatchInfo
transform	.\include\raylib.h	/^    Matrix transform;       \/\/ Local transform matrix$/;"	m	struct:Model
transform	.\include\rlgl.h	/^        Matrix transform;                   \/\/ Transform matrix to be used with rlTranslate, rlRotate, rlScale$/;"	m	struct:rlglData::__anon33
transformRequired	.\include\rlgl.h	/^        bool transformRequired;             \/\/ Require transform matrix application to current draw-call vertex (if required)$/;"	m	struct:rlglData::__anon33
translation	.\include\raylib.h	/^    Vector3 translation;    \/\/ Translation$/;"	m	struct:Transform
triangleCount	.\include\raylib.h	/^    int triangleCount;      \/\/ Number of triangles stored (indexed or not)$/;"	m	struct:Mesh
true	.\include\raylib.h	/^    typedef enum bool { false = 0, true = !false } bool;$/;"	e	enum:bool
true	.\include\rlgl.h	/^typedef enum bool { false = 0, true = !false } bool;$/;"	e	enum:bool
true	.\src\utils.c	29;"	d	file:
type	.\include\raylib.h	/^    unsigned int type;              \/\/ Event type (AutomationEventType)$/;"	m	struct:AutomationEvent
u16	.\src\utils.c	/^typedef uint16_t u16;$/;"	t	file:
u32	.\src\utils.c	/^typedef uint32_t u32;$/;"	t	file:
u64	.\src\utils.c	/^typedef uint64_t u64;$/;"	t	file:
u8	.\src\utils.c	/^typedef uint8_t u8;$/;"	t	file:
uintptr	.\src\utils.c	/^typedef uintptr_t uintptr;$/;"	t	file:
up	.\include\raylib.h	/^    Vector3 up;             \/\/ Camera up vector (rotation over its axis)$/;"	m	struct:Camera3D
used	.\src\memory.c	/^    usize used;$/;"	m	struct:__anon35	file:
used	.\src\memory.c	/^    usize used;$/;"	m	struct:__anon36	file:
usize	.\src\utils.c	/^typedef size_t usize;$/;"	t	file:
v	.\include\raymath.h	/^    float v[16];$/;"	m	struct:float16
v	.\include\raymath.h	/^    float v[3];$/;"	m	struct:float3
vResolution	.\include\raylib.h	/^    int vResolution;                \/\/ Vertical resolution in pixels$/;"	m	struct:VrDeviceInfo
vScreenCenter	.\include\raylib.h	/^    float vScreenCenter;            \/\/ Screen center in meters$/;"	m	struct:VrDeviceInfo
vScreenSize	.\include\raylib.h	/^    float vScreenSize;              \/\/ Vertical size in meters$/;"	m	struct:VrDeviceInfo
value	.\include\raylib.h	/^    float value;            \/\/ Material map value$/;"	m	struct:MaterialMap
value	.\include\raylib.h	/^    int value;              \/\/ Character value (Unicode)$/;"	m	struct:GlyphInfo
vao	.\include\rlgl.h	/^        bool vao;                           \/\/ VAO support (OpenGL ES2 could not support VAO extension) (GL_ARB_vertex_array_object)$/;"	m	struct:rlglData::__anon34
vaoId	.\include\raylib.h	/^    unsigned int vaoId;     \/\/ OpenGL Vertex Array Object id$/;"	m	struct:Mesh
vaoId	.\include\rlgl.h	/^    unsigned int vaoId;         \/\/ OpenGL Vertex Array Object id$/;"	m	struct:rlVertexBuffer
vboId	.\include\raylib.h	/^    unsigned int *vboId;    \/\/ OpenGL Vertex Buffer Objects id (default vertex data)$/;"	m	struct:Mesh
vboId	.\include\rlgl.h	/^    unsigned int vboId[4];      \/\/ OpenGL Vertex Buffer Objects id (4 types of vertex data)$/;"	m	struct:rlVertexBuffer
vector2i	.\src\utils.c	/^} vector2i;$/;"	t	typeref:struct:__anon40	file:
vector_to_screen_space	.\src\render.c	/^vector_to_screen_space(render_group *group, Vector2 vector) {$/;"	f
vertexAlignment	.\include\rlgl.h	/^    int vertexAlignment;        \/\/ Number of vertex required for index alignment (LINES, TRIANGLES)$/;"	m	struct:rlDrawCall
vertexBuffer	.\include\rlgl.h	/^    rlVertexBuffer *vertexBuffer; \/\/ Dynamic buffer(s) for vertex data$/;"	m	struct:rlRenderBatch
vertexCount	.\include\raylib.h	/^    int vertexCount;        \/\/ Number of vertices stored in arrays$/;"	m	struct:Mesh
vertexCount	.\include\rlgl.h	/^    int vertexCount;            \/\/ Number of vertex of the draw$/;"	m	struct:rlDrawCall
vertexCounter	.\include\rlgl.h	/^        int vertexCounter;                  \/\/ Current active render batch vertex counter (generic, used for all batches)$/;"	m	struct:rlglData::__anon33
vertices	.\include\raylib.h	/^    float *vertices;        \/\/ Vertex position (XYZ - 3 components per vertex) (shader-location = 0)$/;"	m	struct:Mesh
vertices	.\include\rlgl.h	/^    float *vertices;            \/\/ Vertex position (XYZ - 3 components per vertex) (shader-location = 0)$/;"	m	struct:rlVertexBuffer
viewOffset	.\include\raylib.h	/^    Matrix viewOffset[2];           \/\/ VR view offset matrices (per eye)$/;"	m	struct:VrStereoConfig
viewOffsetStereo	.\include\rlgl.h	/^        Matrix viewOffsetStereo[2];         \/\/ VR stereo rendering eyes view offset matrices$/;"	m	struct:rlglData::__anon33
w	.\include\raylib.h	/^    float w;                \/\/ Vector w component$/;"	m	struct:Vector4
w	.\include\raymath.h	/^    float w;$/;"	m	struct:Vector4
width	.\include\raylib.h	/^    float width;            \/\/ Rectangle width$/;"	m	struct:Rectangle
width	.\include\raylib.h	/^    int width;              \/\/ Image base width$/;"	m	struct:Image
width	.\include\raylib.h	/^    int width;              \/\/ Texture base width$/;"	m	struct:Texture
win32_allocate	.\src\memory.c	/^void *win32_allocate(usize);$/;"	p	file:
win32_allocate	.\src\win32.c	/^void *win32_allocate(SIZE_T size) {$/;"	f
x	.\include\raylib.h	/^    float x;                \/\/ Rectangle top-left corner position x$/;"	m	struct:Rectangle
x	.\include\raylib.h	/^    float x;                \/\/ Vector x component$/;"	m	struct:Vector2
x	.\include\raylib.h	/^    float x;                \/\/ Vector x component$/;"	m	struct:Vector3
x	.\include\raylib.h	/^    float x;                \/\/ Vector x component$/;"	m	struct:Vector4
x	.\include\raymath.h	/^    float x;$/;"	m	struct:Vector2
x	.\include\raymath.h	/^    float x;$/;"	m	struct:Vector3
x	.\include\raymath.h	/^    float x;$/;"	m	struct:Vector4
x	.\src\utils.c	/^    i32 x;$/;"	m	struct:__anon40	file:
y	.\include\raylib.h	/^    float y;                \/\/ Rectangle top-left corner position y$/;"	m	struct:Rectangle
y	.\include\raylib.h	/^    float y;                \/\/ Vector y component$/;"	m	struct:Vector2
y	.\include\raylib.h	/^    float y;                \/\/ Vector y component$/;"	m	struct:Vector3
y	.\include\raylib.h	/^    float y;                \/\/ Vector y component$/;"	m	struct:Vector4
y	.\include\raymath.h	/^    float y;$/;"	m	struct:Vector2
y	.\include\raymath.h	/^    float y;$/;"	m	struct:Vector3
y	.\include\raymath.h	/^    float y;$/;"	m	struct:Vector4
y	.\src\utils.c	/^    i32 y;$/;"	m	struct:__anon40	file:
z	.\include\raylib.h	/^    float z;                \/\/ Vector z component$/;"	m	struct:Vector3
z	.\include\raylib.h	/^    float z;                \/\/ Vector z component$/;"	m	struct:Vector4
z	.\include\raymath.h	/^    float z;$/;"	m	struct:Vector3
z	.\include\raymath.h	/^    float z;$/;"	m	struct:Vector4
zoom	.\include\raylib.h	/^    float zoom;             \/\/ Camera zoom (scaling), should be 1.0f by default$/;"	m	struct:Camera2D
